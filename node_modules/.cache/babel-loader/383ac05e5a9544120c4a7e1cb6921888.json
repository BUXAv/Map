{"ast":null,"code":"require(\"core-js/modules/es.typed-array.at.js\");\n\nrequire(\"core-js/modules/es.typed-array.set.js\");\n\nrequire(\"core-js/modules/esnext.typed-array.find-last.js\");\n\nrequire(\"core-js/modules/esnext.typed-array.find-last-index.js\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar _symbol = require(\"../../util/symbol\");\n\nvar createSymbol = _symbol.createSymbol;\n\nvar IncrementalDisplayable = require(\"zrender/lib/graphic/IncrementalDisplayable\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// TODO Batch by color\n\n\nvar BOOST_SIZE_THRESHOLD = 4;\nvar LargeSymbolPath = graphic.extendShape({\n  shape: {\n    points: null\n  },\n  symbolProxy: null,\n  buildPath: function (path, shape) {\n    var points = shape.points;\n    var size = shape.size;\n    var symbolProxy = this.symbolProxy;\n    var symbolProxyShape = symbolProxy.shape;\n    var ctx = path.getContext ? path.getContext() : path;\n    var canBoost = ctx && size[0] < BOOST_SIZE_THRESHOLD; // Do draw in afterBrush.\n\n    if (canBoost) {\n      return;\n    }\n\n    for (var i = 0; i < points.length;) {\n      var x = points[i++];\n      var y = points[i++];\n\n      if (isNaN(x) || isNaN(y)) {\n        continue;\n      }\n\n      symbolProxyShape.x = x - size[0] / 2;\n      symbolProxyShape.y = y - size[1] / 2;\n      symbolProxyShape.width = size[0];\n      symbolProxyShape.height = size[1];\n      symbolProxy.buildPath(path, symbolProxyShape, true);\n    }\n  },\n  afterBrush: function (ctx) {\n    var shape = this.shape;\n    var points = shape.points;\n    var size = shape.size;\n    var canBoost = size[0] < BOOST_SIZE_THRESHOLD;\n\n    if (!canBoost) {\n      return;\n    }\n\n    this.setTransform(ctx); // PENDING If style or other canvas status changed?\n\n    for (var i = 0; i < points.length;) {\n      var x = points[i++];\n      var y = points[i++];\n\n      if (isNaN(x) || isNaN(y)) {\n        continue;\n      } // fillRect is faster than building a rect path and draw.\n      // And it support light globalCompositeOperation.\n\n\n      ctx.fillRect(x - size[0] / 2, y - size[1] / 2, size[0], size[1]);\n    }\n\n    this.restoreTransform(ctx);\n  },\n  findDataIndex: function (x, y) {\n    // TODO ???\n    // Consider transform\n    var shape = this.shape;\n    var points = shape.points;\n    var size = shape.size;\n    var w = Math.max(size[0], 4);\n    var h = Math.max(size[1], 4); // Not consider transform\n    // Treat each element as a rect\n    // top down traverse\n\n    for (var idx = points.length / 2 - 1; idx >= 0; idx--) {\n      var i = idx * 2;\n      var x0 = points[i] - w / 2;\n      var y0 = points[i + 1] - h / 2;\n\n      if (x >= x0 && y >= y0 && x <= x0 + w && y <= y0 + h) {\n        return idx;\n      }\n    }\n\n    return -1;\n  }\n});\n\nfunction LargeSymbolDraw() {\n  this.group = new graphic.Group();\n}\n\nvar largeSymbolProto = LargeSymbolDraw.prototype;\n\nlargeSymbolProto.isPersistent = function () {\n  return !this._incremental;\n};\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n */\n\n\nlargeSymbolProto.updateData = function (data) {\n  this.group.removeAll();\n  var symbolEl = new LargeSymbolPath({\n    rectHover: true,\n    cursor: 'default'\n  });\n  symbolEl.setShape({\n    points: data.getLayout('symbolPoints')\n  });\n\n  this._setCommon(symbolEl, data);\n\n  this.group.add(symbolEl);\n  this._incremental = null;\n};\n\nlargeSymbolProto.updateLayout = function (data) {\n  if (this._incremental) {\n    return;\n  }\n\n  var points = data.getLayout('symbolPoints');\n  this.group.eachChild(function (child) {\n    if (child.startIndex != null) {\n      var len = (child.endIndex - child.startIndex) * 2;\n      var byteOffset = child.startIndex * 4 * 2;\n      points = new Float32Array(points.buffer, byteOffset, len);\n    }\n\n    child.setShape('points', points);\n  });\n};\n\nlargeSymbolProto.incrementalPrepareUpdate = function (data) {\n  this.group.removeAll();\n\n  this._clearIncremental(); // Only use incremental displayables when data amount is larger than 2 million.\n  // PENDING Incremental data?\n\n\n  if (data.count() > 2e6) {\n    if (!this._incremental) {\n      this._incremental = new IncrementalDisplayable({\n        silent: true\n      });\n    }\n\n    this.group.add(this._incremental);\n  } else {\n    this._incremental = null;\n  }\n};\n\nlargeSymbolProto.incrementalUpdate = function (taskParams, data) {\n  var symbolEl;\n\n  if (this._incremental) {\n    symbolEl = new LargeSymbolPath();\n\n    this._incremental.addDisplayable(symbolEl, true);\n  } else {\n    symbolEl = new LargeSymbolPath({\n      rectHover: true,\n      cursor: 'default',\n      startIndex: taskParams.start,\n      endIndex: taskParams.end\n    });\n    symbolEl.incremental = true;\n    this.group.add(symbolEl);\n  }\n\n  symbolEl.setShape({\n    points: data.getLayout('symbolPoints')\n  });\n\n  this._setCommon(symbolEl, data, !!this._incremental);\n};\n\nlargeSymbolProto._setCommon = function (symbolEl, data, isIncremental) {\n  var hostModel = data.hostModel; // TODO\n  // if (data.hasItemVisual.symbolSize) {\n  //     // TODO typed array?\n  //     symbolEl.setShape('sizes', data.mapArray(\n  //         function (idx) {\n  //             var size = data.getItemVisual(idx, 'symbolSize');\n  //             return (size instanceof Array) ? size : [size, size];\n  //         }\n  //     ));\n  // }\n  // else {\n\n  var size = data.getVisual('symbolSize');\n  symbolEl.setShape('size', size instanceof Array ? size : [size, size]); // }\n  // Create symbolProxy to build path for each data\n\n  symbolEl.symbolProxy = createSymbol(data.getVisual('symbol'), 0, 0, 0, 0); // Use symbolProxy setColor method\n\n  symbolEl.setColor = symbolEl.symbolProxy.setColor;\n  var extrudeShadow = symbolEl.shape.size[0] < BOOST_SIZE_THRESHOLD;\n  symbolEl.useStyle( // Draw shadow when doing fillRect is extremely slow.\n  hostModel.getModel('itemStyle').getItemStyle(extrudeShadow ? ['color', 'shadowBlur', 'shadowColor'] : ['color']));\n  var visualColor = data.getVisual('color');\n\n  if (visualColor) {\n    symbolEl.setColor(visualColor);\n  }\n\n  if (!isIncremental) {\n    // Enable tooltip\n    // PENDING May have performance issue when path is extremely large\n    symbolEl.seriesIndex = hostModel.seriesIndex;\n    symbolEl.on('mousemove', function (e) {\n      symbolEl.dataIndex = null;\n      var dataIndex = symbolEl.findDataIndex(e.offsetX, e.offsetY);\n\n      if (dataIndex >= 0) {\n        // Provide dataIndex for tooltip\n        symbolEl.dataIndex = dataIndex + (symbolEl.startIndex || 0);\n      }\n    });\n  }\n};\n\nlargeSymbolProto.remove = function () {\n  this._clearIncremental();\n\n  this._incremental = null;\n  this.group.removeAll();\n};\n\nlargeSymbolProto._clearIncremental = function () {\n  var incremental = this._incremental;\n\n  if (incremental) {\n    incremental.clearDisplaybles();\n  }\n};\n\nvar _default = LargeSymbolDraw;\nmodule.exports = _default;","map":{"version":3,"names":["graphic","require","_symbol","createSymbol","IncrementalDisplayable","BOOST_SIZE_THRESHOLD","LargeSymbolPath","extendShape","shape","points","symbolProxy","buildPath","path","size","symbolProxyShape","ctx","getContext","canBoost","i","length","x","y","isNaN","width","height","afterBrush","setTransform","fillRect","restoreTransform","findDataIndex","w","Math","max","h","idx","x0","y0","LargeSymbolDraw","group","Group","largeSymbolProto","prototype","isPersistent","_incremental","updateData","data","removeAll","symbolEl","rectHover","cursor","setShape","getLayout","_setCommon","add","updateLayout","eachChild","child","startIndex","len","endIndex","byteOffset","Float32Array","buffer","incrementalPrepareUpdate","_clearIncremental","count","silent","incrementalUpdate","taskParams","addDisplayable","start","end","incremental","isIncremental","hostModel","getVisual","Array","setColor","extrudeShadow","useStyle","getModel","getItemStyle","visualColor","seriesIndex","on","e","dataIndex","offsetX","offsetY","remove","clearDisplaybles","_default","module","exports"],"sources":["C:/Users/W/Desktop/vue_map/node_modules/echarts/lib/chart/helper/LargeSymbolDraw.js"],"sourcesContent":["var graphic = require(\"../../util/graphic\");\n\nvar _symbol = require(\"../../util/symbol\");\n\nvar createSymbol = _symbol.createSymbol;\n\nvar IncrementalDisplayable = require(\"zrender/lib/graphic/IncrementalDisplayable\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// TODO Batch by color\nvar BOOST_SIZE_THRESHOLD = 4;\nvar LargeSymbolPath = graphic.extendShape({\n  shape: {\n    points: null\n  },\n  symbolProxy: null,\n  buildPath: function (path, shape) {\n    var points = shape.points;\n    var size = shape.size;\n    var symbolProxy = this.symbolProxy;\n    var symbolProxyShape = symbolProxy.shape;\n    var ctx = path.getContext ? path.getContext() : path;\n    var canBoost = ctx && size[0] < BOOST_SIZE_THRESHOLD; // Do draw in afterBrush.\n\n    if (canBoost) {\n      return;\n    }\n\n    for (var i = 0; i < points.length;) {\n      var x = points[i++];\n      var y = points[i++];\n\n      if (isNaN(x) || isNaN(y)) {\n        continue;\n      }\n\n      symbolProxyShape.x = x - size[0] / 2;\n      symbolProxyShape.y = y - size[1] / 2;\n      symbolProxyShape.width = size[0];\n      symbolProxyShape.height = size[1];\n      symbolProxy.buildPath(path, symbolProxyShape, true);\n    }\n  },\n  afterBrush: function (ctx) {\n    var shape = this.shape;\n    var points = shape.points;\n    var size = shape.size;\n    var canBoost = size[0] < BOOST_SIZE_THRESHOLD;\n\n    if (!canBoost) {\n      return;\n    }\n\n    this.setTransform(ctx); // PENDING If style or other canvas status changed?\n\n    for (var i = 0; i < points.length;) {\n      var x = points[i++];\n      var y = points[i++];\n\n      if (isNaN(x) || isNaN(y)) {\n        continue;\n      } // fillRect is faster than building a rect path and draw.\n      // And it support light globalCompositeOperation.\n\n\n      ctx.fillRect(x - size[0] / 2, y - size[1] / 2, size[0], size[1]);\n    }\n\n    this.restoreTransform(ctx);\n  },\n  findDataIndex: function (x, y) {\n    // TODO ???\n    // Consider transform\n    var shape = this.shape;\n    var points = shape.points;\n    var size = shape.size;\n    var w = Math.max(size[0], 4);\n    var h = Math.max(size[1], 4); // Not consider transform\n    // Treat each element as a rect\n    // top down traverse\n\n    for (var idx = points.length / 2 - 1; idx >= 0; idx--) {\n      var i = idx * 2;\n      var x0 = points[i] - w / 2;\n      var y0 = points[i + 1] - h / 2;\n\n      if (x >= x0 && y >= y0 && x <= x0 + w && y <= y0 + h) {\n        return idx;\n      }\n    }\n\n    return -1;\n  }\n});\n\nfunction LargeSymbolDraw() {\n  this.group = new graphic.Group();\n}\n\nvar largeSymbolProto = LargeSymbolDraw.prototype;\n\nlargeSymbolProto.isPersistent = function () {\n  return !this._incremental;\n};\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n */\n\n\nlargeSymbolProto.updateData = function (data) {\n  this.group.removeAll();\n  var symbolEl = new LargeSymbolPath({\n    rectHover: true,\n    cursor: 'default'\n  });\n  symbolEl.setShape({\n    points: data.getLayout('symbolPoints')\n  });\n\n  this._setCommon(symbolEl, data);\n\n  this.group.add(symbolEl);\n  this._incremental = null;\n};\n\nlargeSymbolProto.updateLayout = function (data) {\n  if (this._incremental) {\n    return;\n  }\n\n  var points = data.getLayout('symbolPoints');\n  this.group.eachChild(function (child) {\n    if (child.startIndex != null) {\n      var len = (child.endIndex - child.startIndex) * 2;\n      var byteOffset = child.startIndex * 4 * 2;\n      points = new Float32Array(points.buffer, byteOffset, len);\n    }\n\n    child.setShape('points', points);\n  });\n};\n\nlargeSymbolProto.incrementalPrepareUpdate = function (data) {\n  this.group.removeAll();\n\n  this._clearIncremental(); // Only use incremental displayables when data amount is larger than 2 million.\n  // PENDING Incremental data?\n\n\n  if (data.count() > 2e6) {\n    if (!this._incremental) {\n      this._incremental = new IncrementalDisplayable({\n        silent: true\n      });\n    }\n\n    this.group.add(this._incremental);\n  } else {\n    this._incremental = null;\n  }\n};\n\nlargeSymbolProto.incrementalUpdate = function (taskParams, data) {\n  var symbolEl;\n\n  if (this._incremental) {\n    symbolEl = new LargeSymbolPath();\n\n    this._incremental.addDisplayable(symbolEl, true);\n  } else {\n    symbolEl = new LargeSymbolPath({\n      rectHover: true,\n      cursor: 'default',\n      startIndex: taskParams.start,\n      endIndex: taskParams.end\n    });\n    symbolEl.incremental = true;\n    this.group.add(symbolEl);\n  }\n\n  symbolEl.setShape({\n    points: data.getLayout('symbolPoints')\n  });\n\n  this._setCommon(symbolEl, data, !!this._incremental);\n};\n\nlargeSymbolProto._setCommon = function (symbolEl, data, isIncremental) {\n  var hostModel = data.hostModel; // TODO\n  // if (data.hasItemVisual.symbolSize) {\n  //     // TODO typed array?\n  //     symbolEl.setShape('sizes', data.mapArray(\n  //         function (idx) {\n  //             var size = data.getItemVisual(idx, 'symbolSize');\n  //             return (size instanceof Array) ? size : [size, size];\n  //         }\n  //     ));\n  // }\n  // else {\n\n  var size = data.getVisual('symbolSize');\n  symbolEl.setShape('size', size instanceof Array ? size : [size, size]); // }\n  // Create symbolProxy to build path for each data\n\n  symbolEl.symbolProxy = createSymbol(data.getVisual('symbol'), 0, 0, 0, 0); // Use symbolProxy setColor method\n\n  symbolEl.setColor = symbolEl.symbolProxy.setColor;\n  var extrudeShadow = symbolEl.shape.size[0] < BOOST_SIZE_THRESHOLD;\n  symbolEl.useStyle( // Draw shadow when doing fillRect is extremely slow.\n  hostModel.getModel('itemStyle').getItemStyle(extrudeShadow ? ['color', 'shadowBlur', 'shadowColor'] : ['color']));\n  var visualColor = data.getVisual('color');\n\n  if (visualColor) {\n    symbolEl.setColor(visualColor);\n  }\n\n  if (!isIncremental) {\n    // Enable tooltip\n    // PENDING May have performance issue when path is extremely large\n    symbolEl.seriesIndex = hostModel.seriesIndex;\n    symbolEl.on('mousemove', function (e) {\n      symbolEl.dataIndex = null;\n      var dataIndex = symbolEl.findDataIndex(e.offsetX, e.offsetY);\n\n      if (dataIndex >= 0) {\n        // Provide dataIndex for tooltip\n        symbolEl.dataIndex = dataIndex + (symbolEl.startIndex || 0);\n      }\n    });\n  }\n};\n\nlargeSymbolProto.remove = function () {\n  this._clearIncremental();\n\n  this._incremental = null;\n  this.group.removeAll();\n};\n\nlargeSymbolProto._clearIncremental = function () {\n  var incremental = this._incremental;\n\n  if (incremental) {\n    incremental.clearDisplaybles();\n  }\n};\n\nvar _default = LargeSymbolDraw;\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}