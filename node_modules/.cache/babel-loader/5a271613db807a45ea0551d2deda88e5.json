{"ast":null,"code":"require(\"core-js/modules/es.typed-array.at.js\");\n\nrequire(\"core-js/modules/es.typed-array.set.js\");\n\nrequire(\"core-js/modules/esnext.typed-array.find-last.js\");\n\nrequire(\"core-js/modules/esnext.typed-array.find-last-index.js\");\n\nvar _config = require(\"../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar Model = require(\"../model/Model\");\n\nvar DataDiffer = require(\"./DataDiffer\");\n\nvar Source = require(\"./Source\");\n\nvar _dataProvider = require(\"./helper/dataProvider\");\n\nvar defaultDimValueGetters = _dataProvider.defaultDimValueGetters;\nvar DefaultDataProvider = _dataProvider.DefaultDataProvider;\n\nvar _dimensionHelper = require(\"./helper/dimensionHelper\");\n\nvar summarizeDimensions = _dimensionHelper.summarizeDimensions;\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * List for data storage\n * @module echarts/data/List\n */\n\nvar isObject = zrUtil.isObject;\nvar UNDEFINED = 'undefined'; // Use prefix to avoid index to be the same as otherIdList[idx],\n// which will cause weird udpate animation.\n\nvar ID_PREFIX = 'e\\0\\0';\nvar dataCtors = {\n  'float': typeof Float64Array === UNDEFINED ? Array : Float64Array,\n  'int': typeof Int32Array === UNDEFINED ? Array : Int32Array,\n  // Ordinal data type can be string or int\n  'ordinal': Array,\n  'number': Array,\n  'time': Array\n}; // Caution: MUST not use `new CtorUint32Array(arr, 0, len)`, because the Ctor of array is\n// different from the Ctor of typed array.\n\nvar CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;\nvar CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;\n\nfunction getIndicesCtor(list) {\n  // The possible max value in this._indicies is always this._rawCount despite of filtering.\n  return list._rawCount > 65535 ? CtorUint32Array : CtorUint16Array;\n}\n\nfunction cloneChunk(originalChunk) {\n  var Ctor = originalChunk.constructor; // Only shallow clone is enough when Array.\n\n  return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);\n}\n\nvar TRANSFERABLE_PROPERTIES = ['hasItemOption', '_nameList', '_idList', '_invertedIndicesMap', '_rawData', '_chunkSize', '_chunkCount', '_dimValueGetter', '_count', '_rawCount', '_nameDimIdx', '_idDimIdx'];\nvar CLONE_PROPERTIES = ['_extent', '_approximateExtent', '_rawExtent'];\n\nfunction transferProperties(target, source) {\n  zrUtil.each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function (propName) {\n    if (source.hasOwnProperty(propName)) {\n      target[propName] = source[propName];\n    }\n  });\n  target.__wrappedMethods = source.__wrappedMethods;\n  zrUtil.each(CLONE_PROPERTIES, function (propName) {\n    target[propName] = zrUtil.clone(source[propName]);\n  });\n  target._calculationInfo = zrUtil.extend(source._calculationInfo);\n}\n/**\n * @constructor\n * @alias module:echarts/data/List\n *\n * @param {Array.<string|Object>} dimensions\n *      For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].\n *      Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n *      Spetial fields: {\n *          ordinalMeta: <module:echarts/data/OrdinalMeta>\n *          createInvertedIndices: <boolean>\n *      }\n * @param {module:echarts/model/Model} hostModel\n */\n\n\nvar List = function (dimensions, hostModel) {\n  dimensions = dimensions || ['x', 'y'];\n  var dimensionInfos = {};\n  var dimensionNames = [];\n  var invertedIndicesMap = {};\n\n  for (var i = 0; i < dimensions.length; i++) {\n    // Use the original dimensions[i], where other flag props may exists.\n    var dimensionInfo = dimensions[i];\n\n    if (zrUtil.isString(dimensionInfo)) {\n      dimensionInfo = {\n        name: dimensionInfo\n      };\n    }\n\n    var dimensionName = dimensionInfo.name;\n    dimensionInfo.type = dimensionInfo.type || 'float';\n\n    if (!dimensionInfo.coordDim) {\n      dimensionInfo.coordDim = dimensionName;\n      dimensionInfo.coordDimIndex = 0;\n    }\n\n    dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n    dimensionNames.push(dimensionName);\n    dimensionInfos[dimensionName] = dimensionInfo;\n    dimensionInfo.index = i;\n\n    if (dimensionInfo.createInvertedIndices) {\n      invertedIndicesMap[dimensionName] = [];\n    }\n  }\n  /**\n   * @readOnly\n   * @type {Array.<string>}\n   */\n\n\n  this.dimensions = dimensionNames;\n  /**\n   * Infomation of each data dimension, like data type.\n   * @type {Object}\n   */\n\n  this._dimensionInfos = dimensionInfos;\n  /**\n   * @type {module:echarts/model/Model}\n   */\n\n  this.hostModel = hostModel;\n  /**\n   * @type {module:echarts/model/Model}\n   */\n\n  this.dataType;\n  /**\n   * Indices stores the indices of data subset after filtered.\n   * This data subset will be used in chart.\n   * @type {Array.<number>}\n   * @readOnly\n   */\n\n  this._indices = null;\n  this._count = 0;\n  this._rawCount = 0;\n  /**\n   * Data storage\n   * @type {Object.<key, Array.<TypedArray|Array>>}\n   * @private\n   */\n\n  this._storage = {};\n  /**\n   * @type {Array.<string>}\n   */\n\n  this._nameList = [];\n  /**\n   * @type {Array.<string>}\n   */\n\n  this._idList = [];\n  /**\n   * Models of data option is stored sparse for optimizing memory cost\n   * @type {Array.<module:echarts/model/Model>}\n   * @private\n   */\n\n  this._optionModels = [];\n  /**\n   * Global visual properties after visual coding\n   * @type {Object}\n   * @private\n   */\n\n  this._visual = {};\n  /**\n   * Globel layout properties.\n   * @type {Object}\n   * @private\n   */\n\n  this._layout = {};\n  /**\n   * Item visual properties after visual coding\n   * @type {Array.<Object>}\n   * @private\n   */\n\n  this._itemVisuals = [];\n  /**\n   * Key: visual type, Value: boolean\n   * @type {Object}\n   * @readOnly\n   */\n\n  this.hasItemVisual = {};\n  /**\n   * Item layout properties after layout\n   * @type {Array.<Object>}\n   * @private\n   */\n\n  this._itemLayouts = [];\n  /**\n   * Graphic elemnents\n   * @type {Array.<module:zrender/Element>}\n   * @private\n   */\n\n  this._graphicEls = [];\n  /**\n   * Max size of each chunk.\n   * @type {number}\n   * @private\n   */\n\n  this._chunkSize = 1e5;\n  /**\n   * @type {number}\n   * @private\n   */\n\n  this._chunkCount = 0;\n  /**\n   * @type {Array.<Array|Object>}\n   * @private\n   */\n\n  this._rawData;\n  /**\n   * Raw extent will not be cloned, but only transfered.\n   * It will not be calculated util needed.\n   * key: dim,\n   * value: {end: number, extent: Array.<number>}\n   * @type {Object}\n   * @private\n   */\n\n  this._rawExtent = {};\n  /**\n   * @type {Object}\n   * @private\n   */\n\n  this._extent = {};\n  /**\n   * key: dim\n   * value: extent\n   * @type {Object}\n   * @private\n   */\n\n  this._approximateExtent = {};\n  /**\n   * Cache summary info for fast visit. See \"dimensionHelper\".\n   * @type {Object}\n   * @private\n   */\n\n  this._dimensionsSummary = summarizeDimensions(this);\n  /**\n   * @type {Object.<Array|TypedArray>}\n   * @private\n   */\n\n  this._invertedIndicesMap = invertedIndicesMap;\n  /**\n   * @type {Object}\n   * @private\n   */\n\n  this._calculationInfo = {};\n};\n\nvar listProto = List.prototype;\nlistProto.type = 'list';\n/**\n * If each data item has it's own option\n * @type {boolean}\n */\n\nlistProto.hasItemOption = true;\n/**\n * Get dimension name\n * @param {string|number} dim\n *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n * @return {string} Concrete dim name.\n */\n\nlistProto.getDimension = function (dim) {\n  if (!isNaN(dim)) {\n    dim = this.dimensions[dim] || dim;\n  }\n\n  return dim;\n};\n/**\n * Get type and calculation info of particular dimension\n * @param {string|number} dim\n *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n */\n\n\nlistProto.getDimensionInfo = function (dim) {\n  // Do not clone, because there may be categories in dimInfo.\n  return this._dimensionInfos[this.getDimension(dim)];\n};\n/**\n * @return {Array.<string>} concrete dimension name list on coord.\n */\n\n\nlistProto.getDimensionsOnCoord = function () {\n  return this._dimensionsSummary.dataDimsOnCoord.slice();\n};\n/**\n * @param {string} coordDim\n * @param {number} [idx] A coordDim may map to more than one data dim.\n *        If idx is `true`, return a array of all mapped dims.\n *        If idx is not specified, return the first dim not extra.\n * @return {string|Array.<string>} concrete data dim.\n *        If idx is number, and not found, return null/undefined.\n *        If idx is `true`, and not found, return empty array (always return array).\n */\n\n\nlistProto.mapDimension = function (coordDim, idx) {\n  var dimensionsSummary = this._dimensionsSummary;\n\n  if (idx == null) {\n    return dimensionsSummary.encodeFirstDimNotExtra[coordDim];\n  }\n\n  var dims = dimensionsSummary.encode[coordDim];\n  return idx === true // always return array if idx is `true`\n  ? (dims || []).slice() : dims && dims[idx];\n};\n/**\n * Initialize from data\n * @param {Array.<Object|number|Array>} data source or data or data provider.\n * @param {Array.<string>} [nameLIst] The name of a datum is used on data diff and\n *        defualt label/tooltip.\n *        A name can be specified in encode.itemName,\n *        or dataItem.name (only for series option data),\n *        or provided in nameList from outside.\n * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n */\n\n\nlistProto.initData = function (data, nameList, dimValueGetter) {\n  var notProvider = Source.isInstance(data) || zrUtil.isArrayLike(data);\n\n  if (notProvider) {\n    data = new DefaultDataProvider(data, this.dimensions.length);\n  }\n\n  this._rawData = data; // Clear\n\n  this._storage = {};\n  this._indices = null;\n  this._nameList = nameList || [];\n  this._idList = [];\n  this._nameRepeatCount = {};\n\n  if (!dimValueGetter) {\n    this.hasItemOption = false;\n  }\n  /**\n   * @readOnly\n   */\n\n\n  this.defaultDimValueGetter = defaultDimValueGetters[this._rawData.getSource().sourceFormat]; // Default dim value getter\n\n  this._dimValueGetter = dimValueGetter = dimValueGetter || this.defaultDimValueGetter; // Reset raw extent.\n\n  this._rawExtent = {};\n\n  this._initDataFromProvider(0, data.count()); // If data has no item option.\n\n\n  if (data.pure) {\n    this.hasItemOption = false;\n  }\n};\n\nlistProto.getProvider = function () {\n  return this._rawData;\n};\n\nlistProto.appendData = function (data) {\n  var rawData = this._rawData;\n  var start = this.count();\n  rawData.appendData(data);\n  var end = rawData.count();\n\n  if (!rawData.persistent) {\n    end += start;\n  }\n\n  this._initDataFromProvider(start, end);\n};\n\nlistProto._initDataFromProvider = function (start, end) {\n  // Optimize.\n  if (start >= end) {\n    return;\n  }\n\n  var chunkSize = this._chunkSize;\n  var rawData = this._rawData;\n  var storage = this._storage;\n  var dimensions = this.dimensions;\n  var dimLen = dimensions.length;\n  var dimensionInfoMap = this._dimensionInfos;\n  var nameList = this._nameList;\n  var idList = this._idList;\n  var rawExtent = this._rawExtent;\n  var nameRepeatCount = this._nameRepeatCount = {};\n  var nameDimIdx;\n  var chunkCount = this._chunkCount;\n  var lastChunkIndex = chunkCount - 1;\n\n  for (var i = 0; i < dimLen; i++) {\n    var dim = dimensions[i];\n\n    if (!rawExtent[dim]) {\n      rawExtent[dim] = getInitialExtent();\n    }\n\n    var dimInfo = dimensionInfoMap[dim];\n\n    if (dimInfo.otherDims.itemName === 0) {\n      nameDimIdx = this._nameDimIdx = i;\n    }\n\n    if (dimInfo.otherDims.itemId === 0) {\n      this._idDimIdx = i;\n    }\n\n    var DataCtor = dataCtors[dimInfo.type];\n\n    if (!storage[dim]) {\n      storage[dim] = [];\n    }\n\n    var resizeChunkArray = storage[dim][lastChunkIndex];\n\n    if (resizeChunkArray && resizeChunkArray.length < chunkSize) {\n      var newStore = new DataCtor(Math.min(end - lastChunkIndex * chunkSize, chunkSize)); // The cost of the copy is probably inconsiderable\n      // within the initial chunkSize.\n\n      for (var j = 0; j < resizeChunkArray.length; j++) {\n        newStore[j] = resizeChunkArray[j];\n      }\n\n      storage[dim][lastChunkIndex] = newStore;\n    } // Create new chunks.\n\n\n    for (var k = chunkCount * chunkSize; k < end; k += chunkSize) {\n      storage[dim].push(new DataCtor(Math.min(end - k, chunkSize)));\n    }\n\n    this._chunkCount = storage[dim].length;\n  }\n\n  var dataItem = new Array(dimLen);\n\n  for (var idx = start; idx < end; idx++) {\n    // NOTICE: Try not to write things into dataItem\n    dataItem = rawData.getItem(idx, dataItem); // Each data item is value\n    // [1, 2]\n    // 2\n    // Bar chart, line chart which uses category axis\n    // only gives the 'y' value. 'x' value is the indices of category\n    // Use a tempValue to normalize the value to be a (x, y) value\n\n    var chunkIndex = Math.floor(idx / chunkSize);\n    var chunkOffset = idx % chunkSize; // Store the data by dimensions\n\n    for (var k = 0; k < dimLen; k++) {\n      var dim = dimensions[k];\n      var dimStorage = storage[dim][chunkIndex]; // PENDING NULL is empty or zero\n\n      var val = this._dimValueGetter(dataItem, dim, idx, k);\n\n      dimStorage[chunkOffset] = val;\n      var dimRawExtent = rawExtent[dim];\n\n      if (val < dimRawExtent[0]) {\n        dimRawExtent[0] = val;\n      }\n\n      if (val > dimRawExtent[1]) {\n        dimRawExtent[1] = val;\n      }\n    } // ??? FIXME not check by pure but sourceFormat?\n    // TODO refactor these logic.\n\n\n    if (!rawData.pure) {\n      var name = nameList[idx];\n\n      if (dataItem && name == null) {\n        // If dataItem is {name: ...}, it has highest priority.\n        // That is appropriate for many common cases.\n        if (dataItem.name != null) {\n          // There is no other place to persistent dataItem.name,\n          // so save it to nameList.\n          nameList[idx] = name = dataItem.name;\n        } else if (nameDimIdx != null) {\n          var nameDim = dimensions[nameDimIdx];\n          var nameDimChunk = storage[nameDim][chunkIndex];\n\n          if (nameDimChunk) {\n            name = nameDimChunk[chunkOffset];\n            var ordinalMeta = dimensionInfoMap[nameDim].ordinalMeta;\n\n            if (ordinalMeta && ordinalMeta.categories.length) {\n              name = ordinalMeta.categories[name];\n            }\n          }\n        }\n      } // Try using the id in option\n      // id or name is used on dynamical data, mapping old and new items.\n\n\n      var id = dataItem == null ? null : dataItem.id;\n\n      if (id == null && name != null) {\n        // Use name as id and add counter to avoid same name\n        nameRepeatCount[name] = nameRepeatCount[name] || 0;\n        id = name;\n\n        if (nameRepeatCount[name] > 0) {\n          id += '__ec__' + nameRepeatCount[name];\n        }\n\n        nameRepeatCount[name]++;\n      }\n\n      id != null && (idList[idx] = id);\n    }\n  }\n\n  if (!rawData.persistent && rawData.clean) {\n    // Clean unused data if data source is typed array.\n    rawData.clean();\n  }\n\n  this._rawCount = this._count = end; // Reset data extent\n\n  this._extent = {};\n  prepareInvertedIndex(this);\n};\n\nfunction prepareInvertedIndex(list) {\n  var invertedIndicesMap = list._invertedIndicesMap;\n  zrUtil.each(invertedIndicesMap, function (invertedIndices, dim) {\n    var dimInfo = list._dimensionInfos[dim]; // Currently, only dimensions that has ordinalMeta can create inverted indices.\n\n    var ordinalMeta = dimInfo.ordinalMeta;\n\n    if (ordinalMeta) {\n      invertedIndices = invertedIndicesMap[dim] = new CtorUint32Array(ordinalMeta.categories.length); // The default value of TypedArray is 0. To avoid miss\n      // mapping to 0, we should set it as NaN.\n\n      for (var i = 0; i < invertedIndices.length; i++) {\n        invertedIndices[i] = NaN;\n      }\n\n      for (var i = 0; i < list._count; i++) {\n        // Only support the case that all values are distinct.\n        invertedIndices[list.get(dim, i)] = i;\n      }\n    }\n  });\n}\n\nfunction getRawValueFromStore(list, dimIndex, rawIndex) {\n  var val;\n\n  if (dimIndex != null) {\n    var chunkSize = list._chunkSize;\n    var chunkIndex = Math.floor(rawIndex / chunkSize);\n    var chunkOffset = rawIndex % chunkSize;\n    var dim = list.dimensions[dimIndex];\n    var chunk = list._storage[dim][chunkIndex];\n\n    if (chunk) {\n      val = chunk[chunkOffset];\n      var ordinalMeta = list._dimensionInfos[dim].ordinalMeta;\n\n      if (ordinalMeta && ordinalMeta.categories.length) {\n        val = ordinalMeta.categories[val];\n      }\n    }\n  }\n\n  return val;\n}\n/**\n * @return {number}\n */\n\n\nlistProto.count = function () {\n  return this._count;\n};\n\nlistProto.getIndices = function () {\n  var newIndices;\n  var indices = this._indices;\n\n  if (indices) {\n    var Ctor = indices.constructor;\n    var thisCount = this._count; // `new Array(a, b, c)` is different from `new Uint32Array(a, b, c)`.\n\n    if (Ctor === Array) {\n      newIndices = new Ctor(thisCount);\n\n      for (var i = 0; i < thisCount; i++) {\n        newIndices[i] = indices[i];\n      }\n    } else {\n      newIndices = new Ctor(indices.buffer, 0, thisCount);\n    }\n  } else {\n    var Ctor = getIndicesCtor(this);\n    var newIndices = new Ctor(this.count());\n\n    for (var i = 0; i < newIndices.length; i++) {\n      newIndices[i] = i;\n    }\n  }\n\n  return newIndices;\n};\n/**\n * Get value. Return NaN if idx is out of range.\n * @param {string} dim Dim must be concrete name.\n * @param {number} idx\n * @param {boolean} stack\n * @return {number}\n */\n\n\nlistProto.get = function (dim, idx\n/*, stack */\n) {\n  if (!(idx >= 0 && idx < this._count)) {\n    return NaN;\n  }\n\n  var storage = this._storage;\n\n  if (!storage[dim]) {\n    // TODO Warn ?\n    return NaN;\n  }\n\n  idx = this.getRawIndex(idx);\n  var chunkIndex = Math.floor(idx / this._chunkSize);\n  var chunkOffset = idx % this._chunkSize;\n  var chunkStore = storage[dim][chunkIndex];\n  var value = chunkStore[chunkOffset]; // FIXME ordinal data type is not stackable\n  // if (stack) {\n  //     var dimensionInfo = this._dimensionInfos[dim];\n  //     if (dimensionInfo && dimensionInfo.stackable) {\n  //         var stackedOn = this.stackedOn;\n  //         while (stackedOn) {\n  //             // Get no stacked data of stacked on\n  //             var stackedValue = stackedOn.get(dim, idx);\n  //             // Considering positive stack, negative stack and empty data\n  //             if ((value >= 0 && stackedValue > 0)  // Positive stack\n  //                 || (value <= 0 && stackedValue < 0) // Negative stack\n  //             ) {\n  //                 value += stackedValue;\n  //             }\n  //             stackedOn = stackedOn.stackedOn;\n  //         }\n  //     }\n  // }\n\n  return value;\n};\n/**\n * @param {string} dim concrete dim\n * @param {number} rawIndex\n * @return {number|string}\n */\n\n\nlistProto.getByRawIndex = function (dim, rawIdx) {\n  if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {\n    return NaN;\n  }\n\n  var dimStore = this._storage[dim];\n\n  if (!dimStore) {\n    // TODO Warn ?\n    return NaN;\n  }\n\n  var chunkIndex = Math.floor(rawIdx / this._chunkSize);\n  var chunkOffset = rawIdx % this._chunkSize;\n  var chunkStore = dimStore[chunkIndex];\n  return chunkStore[chunkOffset];\n};\n/**\n * FIXME Use `get` on chrome maybe slow(in filterSelf and selectRange).\n * Hack a much simpler _getFast\n * @private\n */\n\n\nlistProto._getFast = function (dim, rawIdx) {\n  var chunkIndex = Math.floor(rawIdx / this._chunkSize);\n  var chunkOffset = rawIdx % this._chunkSize;\n  var chunkStore = this._storage[dim][chunkIndex];\n  return chunkStore[chunkOffset];\n};\n/**\n * Get value for multi dimensions.\n * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getValues = function (dimensions, idx\n/*, stack */\n) {\n  var values = [];\n\n  if (!zrUtil.isArray(dimensions)) {\n    // stack = idx;\n    idx = dimensions;\n    dimensions = this.dimensions;\n  }\n\n  for (var i = 0, len = dimensions.length; i < len; i++) {\n    values.push(this.get(dimensions[i], idx\n    /*, stack */\n    ));\n  }\n\n  return values;\n};\n/**\n * If value is NaN. Inlcuding '-'\n * Only check the coord dimensions.\n * @param {string} dim\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.hasValue = function (idx) {\n  var dataDimsOnCoord = this._dimensionsSummary.dataDimsOnCoord;\n  var dimensionInfos = this._dimensionInfos;\n\n  for (var i = 0, len = dataDimsOnCoord.length; i < len; i++) {\n    if ( // Ordinal type can be string or number\n    dimensionInfos[dataDimsOnCoord[i]].type !== 'ordinal' // FIXME check ordinal when using index?\n    && isNaN(this.get(dataDimsOnCoord[i], idx))) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Get extent of data in one dimension\n * @param {string} dim\n * @param {boolean} stack\n */\n\n\nlistProto.getDataExtent = function (dim\n/*, stack */\n) {\n  // Make sure use concrete dim as cache name.\n  dim = this.getDimension(dim);\n  var dimData = this._storage[dim];\n  var initialExtent = getInitialExtent(); // stack = !!((stack || false) && this.getCalculationInfo(dim));\n\n  if (!dimData) {\n    return initialExtent;\n  } // Make more strict checkings to ensure hitting cache.\n\n\n  var currEnd = this.count(); // var cacheName = [dim, !!stack].join('_');\n  // var cacheName = dim;\n  // Consider the most cases when using data zoom, `getDataExtent`\n  // happened before filtering. We cache raw extent, which is not\n  // necessary to be cleared and recalculated when restore data.\n\n  var useRaw = !this._indices; // && !stack;\n\n  var dimExtent;\n\n  if (useRaw) {\n    return this._rawExtent[dim].slice();\n  }\n\n  dimExtent = this._extent[dim];\n\n  if (dimExtent) {\n    return dimExtent.slice();\n  }\n\n  dimExtent = initialExtent;\n  var min = dimExtent[0];\n  var max = dimExtent[1];\n\n  for (var i = 0; i < currEnd; i++) {\n    // var value = stack ? this.get(dim, i, true) : this._getFast(dim, this.getRawIndex(i));\n    var value = this._getFast(dim, this.getRawIndex(i));\n\n    value < min && (min = value);\n    value > max && (max = value);\n  }\n\n  dimExtent = [min, max];\n  this._extent[dim] = dimExtent;\n  return dimExtent;\n};\n/**\n * Optimize for the scenario that data is filtered by a given extent.\n * Consider that if data amount is more than hundreds of thousand,\n * extent calculation will cost more than 10ms and the cache will\n * be erased because of the filtering.\n */\n\n\nlistProto.getApproximateExtent = function (dim\n/*, stack */\n) {\n  dim = this.getDimension(dim);\n  return this._approximateExtent[dim] || this.getDataExtent(dim\n  /*, stack */\n  );\n};\n\nlistProto.setApproximateExtent = function (extent, dim\n/*, stack */\n) {\n  dim = this.getDimension(dim);\n  this._approximateExtent[dim] = extent.slice();\n};\n/**\n * @param {string} key\n * @return {*}\n */\n\n\nlistProto.getCalculationInfo = function (key) {\n  return this._calculationInfo[key];\n};\n/**\n * @param {string|Object} key or k-v object\n * @param {*} [value]\n */\n\n\nlistProto.setCalculationInfo = function (key, value) {\n  isObject(key) ? zrUtil.extend(this._calculationInfo, key) : this._calculationInfo[key] = value;\n};\n/**\n * Get sum of data in one dimension\n * @param {string} dim\n */\n\n\nlistProto.getSum = function (dim\n/*, stack */\n) {\n  var dimData = this._storage[dim];\n  var sum = 0;\n\n  if (dimData) {\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var value = this.get(dim, i\n      /*, stack */\n      );\n\n      if (!isNaN(value)) {\n        sum += value;\n      }\n    }\n  }\n\n  return sum;\n};\n/**\n * Get median of data in one dimension\n * @param {string} dim\n */\n\n\nlistProto.getMedian = function (dim\n/*, stack */\n) {\n  var dimDataArray = []; // map all data of one dimension\n\n  this.each(dim, function (val, idx) {\n    if (!isNaN(val)) {\n      dimDataArray.push(val);\n    }\n  }); // TODO\n  // Use quick select?\n  // immutability & sort\n\n  var sortedDimDataArray = [].concat(dimDataArray).sort(function (a, b) {\n    return a - b;\n  });\n  var len = this.count(); // calculate median\n\n  return len === 0 ? 0 : len % 2 === 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2;\n}; // /**\n//  * Retreive the index with given value\n//  * @param {string} dim Concrete dimension.\n//  * @param {number} value\n//  * @return {number}\n//  */\n// Currently incorrect: should return dataIndex but not rawIndex.\n// Do not fix it until this method is to be used somewhere.\n// FIXME Precision of float value\n// listProto.indexOf = function (dim, value) {\n//     var storage = this._storage;\n//     var dimData = storage[dim];\n//     var chunkSize = this._chunkSize;\n//     if (dimData) {\n//         for (var i = 0, len = this.count(); i < len; i++) {\n//             var chunkIndex = Math.floor(i / chunkSize);\n//             var chunkOffset = i % chunkSize;\n//             if (dimData[chunkIndex][chunkOffset] === value) {\n//                 return i;\n//             }\n//         }\n//     }\n//     return -1;\n// };\n\n/**\n * Only support the dimension which inverted index created.\n * Do not support other cases until required.\n * @param {string} concrete dim\n * @param {number|string} value\n * @return {number} rawIndex\n */\n\n\nlistProto.rawIndexOf = function (dim, value) {\n  var invertedIndices = dim && this._invertedIndicesMap[dim];\n  var rawIndex = invertedIndices[value];\n\n  if (rawIndex == null || isNaN(rawIndex)) {\n    return -1;\n  }\n\n  return rawIndex;\n};\n/**\n * Retreive the index with given name\n * @param {number} idx\n * @param {number} name\n * @return {number}\n */\n\n\nlistProto.indexOfName = function (name) {\n  for (var i = 0, len = this.count(); i < len; i++) {\n    if (this.getName(i) === name) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n/**\n * Retreive the index with given raw data index\n * @param {number} idx\n * @param {number} name\n * @return {number}\n */\n\n\nlistProto.indexOfRawIndex = function (rawIndex) {\n  if (!this._indices) {\n    return rawIndex;\n  }\n\n  if (rawIndex >= this._rawCount || rawIndex < 0) {\n    return -1;\n  } // Indices are ascending\n\n\n  var indices = this._indices; // If rawIndex === dataIndex\n\n  var rawDataIndex = indices[rawIndex];\n\n  if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {\n    return rawIndex;\n  }\n\n  var left = 0;\n  var right = this._count - 1;\n\n  while (left <= right) {\n    var mid = (left + right) / 2 | 0;\n\n    if (indices[mid] < rawIndex) {\n      left = mid + 1;\n    } else if (indices[mid] > rawIndex) {\n      right = mid - 1;\n    } else {\n      return mid;\n    }\n  }\n\n  return -1;\n};\n/**\n * Retreive the index of nearest value\n * @param {string} dim\n * @param {number} value\n * @param {number} [maxDistance=Infinity]\n * @return {Array.<number>} Considere multiple points has the same value.\n */\n\n\nlistProto.indicesOfNearest = function (dim, value, maxDistance) {\n  var storage = this._storage;\n  var dimData = storage[dim];\n  var nearestIndices = [];\n\n  if (!dimData) {\n    return nearestIndices;\n  }\n\n  if (maxDistance == null) {\n    maxDistance = Infinity;\n  }\n\n  var minDist = Number.MAX_VALUE;\n  var minDiff = -1;\n\n  for (var i = 0, len = this.count(); i < len; i++) {\n    var diff = value - this.get(dim, i\n    /*, stack */\n    );\n    var dist = Math.abs(diff);\n\n    if (diff <= maxDistance && dist <= minDist) {\n      // For the case of two data are same on xAxis, which has sequence data.\n      // Show the nearest index\n      // https://github.com/ecomfe/echarts/issues/2869\n      if (dist < minDist || diff >= 0 && minDiff < 0) {\n        minDist = dist;\n        minDiff = diff;\n        nearestIndices.length = 0;\n      }\n\n      nearestIndices.push(i);\n    }\n  }\n\n  return nearestIndices;\n};\n/**\n * Get raw data index\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getRawIndex = getRawIndexWithoutIndices;\n\nfunction getRawIndexWithoutIndices(idx) {\n  return idx;\n}\n\nfunction getRawIndexWithIndices(idx) {\n  if (idx < this._count && idx >= 0) {\n    return this._indices[idx];\n  }\n\n  return -1;\n}\n/**\n * Get raw data item\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getRawDataItem = function (idx) {\n  if (!this._rawData.persistent) {\n    var val = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      var dim = this.dimensions[i];\n      val.push(this.get(dim, idx));\n    }\n\n    return val;\n  } else {\n    return this._rawData.getItem(this.getRawIndex(idx));\n  }\n};\n/**\n * @param {number} idx\n * @param {boolean} [notDefaultIdx=false]\n * @return {string}\n */\n\n\nlistProto.getName = function (idx) {\n  var rawIndex = this.getRawIndex(idx);\n  return this._nameList[rawIndex] || getRawValueFromStore(this, this._nameDimIdx, rawIndex) || '';\n};\n/**\n * @param {number} idx\n * @param {boolean} [notDefaultIdx=false]\n * @return {string}\n */\n\n\nlistProto.getId = function (idx) {\n  return getId(this, this.getRawIndex(idx));\n};\n\nfunction getId(list, rawIndex) {\n  var id = list._idList[rawIndex];\n\n  if (id == null) {\n    id = getRawValueFromStore(list, list._idDimIdx, rawIndex);\n  }\n\n  if (id == null) {\n    // FIXME Check the usage in graph, should not use prefix.\n    id = ID_PREFIX + rawIndex;\n  }\n\n  return id;\n}\n\nfunction normalizeDimensions(dimensions) {\n  if (!zrUtil.isArray(dimensions)) {\n    dimensions = [dimensions];\n  }\n\n  return dimensions;\n}\n\nfunction validateDimensions(list, dims) {\n  for (var i = 0; i < dims.length; i++) {\n    // stroage may be empty when no data, so use\n    // dimensionInfos to check.\n    if (!list._dimensionInfos[dims[i]]) {\n      console.error('Unkown dimension ' + dims[i]);\n    }\n  }\n}\n/**\n * Data iteration\n * @param {string|Array.<string>}\n * @param {Function} cb\n * @param {*} [context=this]\n *\n * @example\n *  list.each('x', function (x, idx) {});\n *  list.each(['x', 'y'], function (x, y, idx) {});\n *  list.each(function (idx) {})\n */\n\n\nlistProto.each = function (dims, cb, context, contextCompat) {\n  'use strict';\n\n  if (!this._count) {\n    return;\n  }\n\n  if (typeof dims === 'function') {\n    contextCompat = context;\n    context = cb;\n    cb = dims;\n    dims = [];\n  } // contextCompat just for compat echarts3\n\n\n  context = context || contextCompat || this;\n  dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n  var dimSize = dims.length;\n\n  for (var i = 0; i < this.count(); i++) {\n    // Simple optimization\n    switch (dimSize) {\n      case 0:\n        cb.call(context, i);\n        break;\n\n      case 1:\n        cb.call(context, this.get(dims[0], i), i);\n        break;\n\n      case 2:\n        cb.call(context, this.get(dims[0], i), this.get(dims[1], i), i);\n        break;\n\n      default:\n        var k = 0;\n        var value = [];\n\n        for (; k < dimSize; k++) {\n          value[k] = this.get(dims[k], i);\n        } // Index\n\n\n        value[k] = i;\n        cb.apply(context, value);\n    }\n  }\n};\n/**\n * Data filter\n * @param {string|Array.<string>}\n * @param {Function} cb\n * @param {*} [context=this]\n */\n\n\nlistProto.filterSelf = function (dimensions, cb, context, contextCompat) {\n  'use strict';\n\n  if (!this._count) {\n    return;\n  }\n\n  if (typeof dimensions === 'function') {\n    contextCompat = context;\n    context = cb;\n    cb = dimensions;\n    dimensions = [];\n  } // contextCompat just for compat echarts3\n\n\n  context = context || contextCompat || this;\n  dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n  var count = this.count();\n  var Ctor = getIndicesCtor(this);\n  var newIndices = new Ctor(count);\n  var value = [];\n  var dimSize = dimensions.length;\n  var offset = 0;\n  var dim0 = dimensions[0];\n\n  for (var i = 0; i < count; i++) {\n    var keep;\n    var rawIdx = this.getRawIndex(i); // Simple optimization\n\n    if (dimSize === 0) {\n      keep = cb.call(context, i);\n    } else if (dimSize === 1) {\n      var val = this._getFast(dim0, rawIdx);\n\n      keep = cb.call(context, val, i);\n    } else {\n      for (var k = 0; k < dimSize; k++) {\n        value[k] = this._getFast(dim0, rawIdx);\n      }\n\n      value[k] = i;\n      keep = cb.apply(context, value);\n    }\n\n    if (keep) {\n      newIndices[offset++] = rawIdx;\n    }\n  } // Set indices after filtered.\n\n\n  if (offset < count) {\n    this._indices = newIndices;\n  }\n\n  this._count = offset; // Reset data extent\n\n  this._extent = {};\n  this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  return this;\n};\n/**\n * Select data in range. (For optimization of filter)\n * (Manually inline code, support 5 million data filtering in data zoom.)\n */\n\n\nlistProto.selectRange = function (range) {\n  'use strict';\n\n  if (!this._count) {\n    return;\n  }\n\n  var dimensions = [];\n\n  for (var dim in range) {\n    if (range.hasOwnProperty(dim)) {\n      dimensions.push(dim);\n    }\n  }\n\n  var dimSize = dimensions.length;\n\n  if (!dimSize) {\n    return;\n  }\n\n  var originalCount = this.count();\n  var Ctor = getIndicesCtor(this);\n  var newIndices = new Ctor(originalCount);\n  var offset = 0;\n  var dim0 = dimensions[0];\n  var min = range[dim0][0];\n  var max = range[dim0][1];\n  var quickFinished = false;\n\n  if (!this._indices) {\n    // Extreme optimization for common case. About 2x faster in chrome.\n    var idx = 0;\n\n    if (dimSize === 1) {\n      var dimStorage = this._storage[dimensions[0]];\n\n      for (var k = 0; k < this._chunkCount; k++) {\n        var chunkStorage = dimStorage[k];\n        var len = Math.min(this._count - k * this._chunkSize, this._chunkSize);\n\n        for (var i = 0; i < len; i++) {\n          var val = chunkStorage[i]; // NaN will not be filtered. Consider the case, in line chart, empty\n          // value indicates the line should be broken. But for the case like\n          // scatter plot, a data item with empty value will not be rendered,\n          // but the axis extent may be effected if some other dim of the data\n          // item has value. Fortunately it is not a significant negative effect.\n\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n      }\n\n      quickFinished = true;\n    } else if (dimSize === 2) {\n      var dimStorage = this._storage[dim0];\n      var dimStorage2 = this._storage[dimensions[1]];\n      var min2 = range[dimensions[1]][0];\n      var max2 = range[dimensions[1]][1];\n\n      for (var k = 0; k < this._chunkCount; k++) {\n        var chunkStorage = dimStorage[k];\n        var chunkStorage2 = dimStorage2[k];\n        var len = Math.min(this._count - k * this._chunkSize, this._chunkSize);\n\n        for (var i = 0; i < len; i++) {\n          var val = chunkStorage[i];\n          var val2 = chunkStorage2[i]; // Do not filter NaN, see comment above.\n\n          if ((val >= min && val <= max || isNaN(val)) && (val2 >= min2 && val2 <= max2 || isNaN(val2))) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n      }\n\n      quickFinished = true;\n    }\n  }\n\n  if (!quickFinished) {\n    if (dimSize === 1) {\n      for (var i = 0; i < originalCount; i++) {\n        var rawIndex = this.getRawIndex(i);\n\n        var val = this._getFast(dim0, rawIndex); // Do not filter NaN, see comment above.\n\n\n        if (val >= min && val <= max || isNaN(val)) {\n          newIndices[offset++] = rawIndex;\n        }\n      }\n    } else {\n      for (var i = 0; i < originalCount; i++) {\n        var keep = true;\n        var rawIndex = this.getRawIndex(i);\n\n        for (var k = 0; k < dimSize; k++) {\n          var dimk = dimensions[k];\n\n          var val = this._getFast(dim, rawIndex); // Do not filter NaN, see comment above.\n\n\n          if (val < range[dimk][0] || val > range[dimk][1]) {\n            keep = false;\n          }\n        }\n\n        if (keep) {\n          newIndices[offset++] = this.getRawIndex(i);\n        }\n      }\n    }\n  } // Set indices after filtered.\n\n\n  if (offset < originalCount) {\n    this._indices = newIndices;\n  }\n\n  this._count = offset; // Reset data extent\n\n  this._extent = {};\n  this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  return this;\n};\n/**\n * Data mapping to a plain array\n * @param {string|Array.<string>} [dimensions]\n * @param {Function} cb\n * @param {*} [context=this]\n * @return {Array}\n */\n\n\nlistProto.mapArray = function (dimensions, cb, context, contextCompat) {\n  'use strict';\n\n  if (typeof dimensions === 'function') {\n    contextCompat = context;\n    context = cb;\n    cb = dimensions;\n    dimensions = [];\n  } // contextCompat just for compat echarts3\n\n\n  context = context || contextCompat || this;\n  var result = [];\n  this.each(dimensions, function () {\n    result.push(cb && cb.apply(this, arguments));\n  }, context);\n  return result;\n}; // Data in excludeDimensions is copied, otherwise transfered.\n\n\nfunction cloneListForMapAndSample(original, excludeDimensions) {\n  var allDimensions = original.dimensions;\n  var list = new List(zrUtil.map(allDimensions, original.getDimensionInfo, original), original.hostModel); // FIXME If needs stackedOn, value may already been stacked\n\n  transferProperties(list, original);\n  var storage = list._storage = {};\n  var originalStorage = original._storage; // Init storage\n\n  for (var i = 0; i < allDimensions.length; i++) {\n    var dim = allDimensions[i];\n\n    if (originalStorage[dim]) {\n      // Notice that we do not reset invertedIndicesMap here, becuase\n      // there is no scenario of mapping or sampling ordinal dimension.\n      if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n        storage[dim] = cloneDimStore(originalStorage[dim]);\n        list._rawExtent[dim] = getInitialExtent();\n        list._extent[dim] = null;\n      } else {\n        // Direct reference for other dimensions\n        storage[dim] = originalStorage[dim];\n      }\n    }\n  }\n\n  return list;\n}\n\nfunction cloneDimStore(originalDimStore) {\n  var newDimStore = new Array(originalDimStore.length);\n\n  for (var j = 0; j < originalDimStore.length; j++) {\n    newDimStore[j] = cloneChunk(originalDimStore[j]);\n  }\n\n  return newDimStore;\n}\n\nfunction getInitialExtent() {\n  return [Infinity, -Infinity];\n}\n/**\n * Data mapping to a new List with given dimensions\n * @param {string|Array.<string>} dimensions\n * @param {Function} cb\n * @param {*} [context=this]\n * @return {Array}\n */\n\n\nlistProto.map = function (dimensions, cb, context, contextCompat) {\n  'use strict'; // contextCompat just for compat echarts3\n\n  context = context || contextCompat || this;\n  dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n  var list = cloneListForMapAndSample(this, dimensions); // Following properties are all immutable.\n  // So we can reference to the same value\n\n  list._indices = this._indices;\n  list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  var storage = list._storage;\n  var tmpRetValue = [];\n  var chunkSize = this._chunkSize;\n  var dimSize = dimensions.length;\n  var dataCount = this.count();\n  var values = [];\n  var rawExtent = list._rawExtent;\n\n  for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {\n    for (var dimIndex = 0; dimIndex < dimSize; dimIndex++) {\n      values[dimIndex] = this.get(dimensions[dimIndex], dataIndex\n      /*, stack */\n      );\n    }\n\n    values[dimSize] = dataIndex;\n    var retValue = cb && cb.apply(context, values);\n\n    if (retValue != null) {\n      // a number or string (in oridinal dimension)?\n      if (typeof retValue !== 'object') {\n        tmpRetValue[0] = retValue;\n        retValue = tmpRetValue;\n      }\n\n      var rawIndex = this.getRawIndex(dataIndex);\n      var chunkIndex = Math.floor(rawIndex / chunkSize);\n      var chunkOffset = rawIndex % chunkSize;\n\n      for (var i = 0; i < retValue.length; i++) {\n        var dim = dimensions[i];\n        var val = retValue[i];\n        var rawExtentOnDim = rawExtent[dim];\n        var dimStore = storage[dim];\n\n        if (dimStore) {\n          dimStore[chunkIndex][chunkOffset] = val;\n        }\n\n        if (val < rawExtentOnDim[0]) {\n          rawExtentOnDim[0] = val;\n        }\n\n        if (val > rawExtentOnDim[1]) {\n          rawExtentOnDim[1] = val;\n        }\n      }\n    }\n  }\n\n  return list;\n};\n/**\n * Large data down sampling on given dimension\n * @param {string} dimension\n * @param {number} rate\n * @param {Function} sampleValue\n * @param {Function} sampleIndex Sample index for name and id\n */\n\n\nlistProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n  var list = cloneListForMapAndSample(this, [dimension]);\n  var targetStorage = list._storage;\n  var frameValues = [];\n  var frameSize = Math.floor(1 / rate);\n  var dimStore = targetStorage[dimension];\n  var len = this.count();\n  var chunkSize = this._chunkSize;\n  var rawExtentOnDim = list._rawExtent[dimension];\n  var newIndices = new (getIndicesCtor(this))(len);\n  var offset = 0;\n\n  for (var i = 0; i < len; i += frameSize) {\n    // Last frame\n    if (frameSize > len - i) {\n      frameSize = len - i;\n      frameValues.length = frameSize;\n    }\n\n    for (var k = 0; k < frameSize; k++) {\n      var dataIdx = this.getRawIndex(i + k);\n      var originalChunkIndex = Math.floor(dataIdx / chunkSize);\n      var originalChunkOffset = dataIdx % chunkSize;\n      frameValues[k] = dimStore[originalChunkIndex][originalChunkOffset];\n    }\n\n    var value = sampleValue(frameValues);\n    var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1));\n    var sampleChunkIndex = Math.floor(sampleFrameIdx / chunkSize);\n    var sampleChunkOffset = sampleFrameIdx % chunkSize; // Only write value on the filtered data\n\n    dimStore[sampleChunkIndex][sampleChunkOffset] = value;\n\n    if (value < rawExtentOnDim[0]) {\n      rawExtentOnDim[0] = value;\n    }\n\n    if (value > rawExtentOnDim[1]) {\n      rawExtentOnDim[1] = value;\n    }\n\n    newIndices[offset++] = sampleFrameIdx;\n  }\n\n  list._count = offset;\n  list._indices = newIndices;\n  list.getRawIndex = getRawIndexWithIndices;\n  return list;\n};\n/**\n * Get model of one data item.\n *\n * @param {number} idx\n */\n// FIXME Model proxy ?\n\n\nlistProto.getItemModel = function (idx) {\n  var hostModel = this.hostModel;\n  return new Model(this.getRawDataItem(idx), hostModel, hostModel && hostModel.ecModel);\n};\n/**\n * Create a data differ\n * @param {module:echarts/data/List} otherList\n * @return {module:echarts/data/DataDiffer}\n */\n\n\nlistProto.diff = function (otherList) {\n  var thisList = this;\n  return new DataDiffer(otherList ? otherList.getIndices() : [], this.getIndices(), function (idx) {\n    return getId(otherList, idx);\n  }, function (idx) {\n    return getId(thisList, idx);\n  });\n};\n/**\n * Get visual property.\n * @param {string} key\n */\n\n\nlistProto.getVisual = function (key) {\n  var visual = this._visual;\n  return visual && visual[key];\n};\n/**\n * Set visual property\n * @param {string|Object} key\n * @param {*} [value]\n *\n * @example\n *  setVisual('color', color);\n *  setVisual({\n *      'color': color\n *  });\n */\n\n\nlistProto.setVisual = function (key, val) {\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        this.setVisual(name, key[name]);\n      }\n    }\n\n    return;\n  }\n\n  this._visual = this._visual || {};\n  this._visual[key] = val;\n};\n/**\n * Set layout property.\n * @param {string|Object} key\n * @param {*} [val]\n */\n\n\nlistProto.setLayout = function (key, val) {\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        this.setLayout(name, key[name]);\n      }\n    }\n\n    return;\n  }\n\n  this._layout[key] = val;\n};\n/**\n * Get layout property.\n * @param  {string} key.\n * @return {*}\n */\n\n\nlistProto.getLayout = function (key) {\n  return this._layout[key];\n};\n/**\n * Get layout of single data item\n * @param {number} idx\n */\n\n\nlistProto.getItemLayout = function (idx) {\n  return this._itemLayouts[idx];\n};\n/**\n * Set layout of single data item\n * @param {number} idx\n * @param {Object} layout\n * @param {boolean=} [merge=false]\n */\n\n\nlistProto.setItemLayout = function (idx, layout, merge) {\n  this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\n};\n/**\n * Clear all layout of single data item\n */\n\n\nlistProto.clearItemLayouts = function () {\n  this._itemLayouts.length = 0;\n};\n/**\n * Get visual property of single data item\n * @param {number} idx\n * @param {string} key\n * @param {boolean} [ignoreParent=false]\n */\n\n\nlistProto.getItemVisual = function (idx, key, ignoreParent) {\n  var itemVisual = this._itemVisuals[idx];\n  var val = itemVisual && itemVisual[key];\n\n  if (val == null && !ignoreParent) {\n    // Use global visual property\n    return this.getVisual(key);\n  }\n\n  return val;\n};\n/**\n * Set visual property of single data item\n *\n * @param {number} idx\n * @param {string|Object} key\n * @param {*} [value]\n *\n * @example\n *  setItemVisual(0, 'color', color);\n *  setItemVisual(0, {\n *      'color': color\n *  });\n */\n\n\nlistProto.setItemVisual = function (idx, key, value) {\n  var itemVisual = this._itemVisuals[idx] || {};\n  var hasItemVisual = this.hasItemVisual;\n  this._itemVisuals[idx] = itemVisual;\n\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        itemVisual[name] = key[name];\n        hasItemVisual[name] = true;\n      }\n    }\n\n    return;\n  }\n\n  itemVisual[key] = value;\n  hasItemVisual[key] = true;\n};\n/**\n * Clear itemVisuals and list visual.\n */\n\n\nlistProto.clearAllVisual = function () {\n  this._visual = {};\n  this._itemVisuals = [];\n  this.hasItemVisual = {};\n};\n\nvar setItemDataAndSeriesIndex = function (child) {\n  child.seriesIndex = this.seriesIndex;\n  child.dataIndex = this.dataIndex;\n  child.dataType = this.dataType;\n};\n/**\n * Set graphic element relative to data. It can be set as null\n * @param {number} idx\n * @param {module:zrender/Element} [el]\n */\n\n\nlistProto.setItemGraphicEl = function (idx, el) {\n  var hostModel = this.hostModel;\n\n  if (el) {\n    // Add data index and series index for indexing the data by element\n    // Useful in tooltip\n    el.dataIndex = idx;\n    el.dataType = this.dataType;\n    el.seriesIndex = hostModel && hostModel.seriesIndex;\n\n    if (el.type === 'group') {\n      el.traverse(setItemDataAndSeriesIndex, el);\n    }\n  }\n\n  this._graphicEls[idx] = el;\n};\n/**\n * @param {number} idx\n * @return {module:zrender/Element}\n */\n\n\nlistProto.getItemGraphicEl = function (idx) {\n  return this._graphicEls[idx];\n};\n/**\n * @param {Function} cb\n * @param {*} context\n */\n\n\nlistProto.eachItemGraphicEl = function (cb, context) {\n  zrUtil.each(this._graphicEls, function (el, idx) {\n    if (el) {\n      cb && cb.call(context, el, idx);\n    }\n  });\n};\n/**\n * Shallow clone a new list except visual and layout properties, and graph elements.\n * New list only change the indices.\n */\n\n\nlistProto.cloneShallow = function (list) {\n  if (!list) {\n    var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n    list = new List(dimensionInfoList, this.hostModel);\n  } // FIXME\n\n\n  list._storage = this._storage;\n  transferProperties(list, this); // Clone will not change the data extent and indices\n\n  if (this._indices) {\n    var Ctor = this._indices.constructor;\n    list._indices = new Ctor(this._indices);\n  } else {\n    list._indices = null;\n  }\n\n  list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  return list;\n};\n/**\n * Wrap some method to add more feature\n * @param {string} methodName\n * @param {Function} injectFunction\n */\n\n\nlistProto.wrapMethod = function (methodName, injectFunction) {\n  var originalMethod = this[methodName];\n\n  if (typeof originalMethod !== 'function') {\n    return;\n  }\n\n  this.__wrappedMethods = this.__wrappedMethods || [];\n\n  this.__wrappedMethods.push(methodName);\n\n  this[methodName] = function () {\n    var res = originalMethod.apply(this, arguments);\n    return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n  };\n}; // Methods that create a new list based on this list should be listed here.\n// Notice that those method should `RETURN` the new list.\n\n\nlistProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map']; // Methods that change indices of this list should be listed here.\n\nlistProto.CHANGABLE_METHODS = ['filterSelf', 'selectRange'];\nvar _default = List;\nmodule.exports = _default;","map":{"version":3,"names":["_config","require","__DEV__","zrUtil","Model","DataDiffer","Source","_dataProvider","defaultDimValueGetters","DefaultDataProvider","_dimensionHelper","summarizeDimensions","isObject","UNDEFINED","ID_PREFIX","dataCtors","Float64Array","Array","Int32Array","CtorUint32Array","Uint32Array","CtorUint16Array","Uint16Array","getIndicesCtor","list","_rawCount","cloneChunk","originalChunk","Ctor","constructor","slice","TRANSFERABLE_PROPERTIES","CLONE_PROPERTIES","transferProperties","target","source","each","concat","__wrappedMethods","propName","hasOwnProperty","clone","_calculationInfo","extend","List","dimensions","hostModel","dimensionInfos","dimensionNames","invertedIndicesMap","i","length","dimensionInfo","isString","name","dimensionName","type","coordDim","coordDimIndex","otherDims","push","index","createInvertedIndices","_dimensionInfos","dataType","_indices","_count","_storage","_nameList","_idList","_optionModels","_visual","_layout","_itemVisuals","hasItemVisual","_itemLayouts","_graphicEls","_chunkSize","_chunkCount","_rawData","_rawExtent","_extent","_approximateExtent","_dimensionsSummary","_invertedIndicesMap","listProto","prototype","hasItemOption","getDimension","dim","isNaN","getDimensionInfo","getDimensionsOnCoord","dataDimsOnCoord","mapDimension","idx","dimensionsSummary","encodeFirstDimNotExtra","dims","encode","initData","data","nameList","dimValueGetter","notProvider","isInstance","isArrayLike","_nameRepeatCount","defaultDimValueGetter","getSource","sourceFormat","_dimValueGetter","_initDataFromProvider","count","pure","getProvider","appendData","rawData","start","end","persistent","chunkSize","storage","dimLen","dimensionInfoMap","idList","rawExtent","nameRepeatCount","nameDimIdx","chunkCount","lastChunkIndex","getInitialExtent","dimInfo","itemName","_nameDimIdx","itemId","_idDimIdx","DataCtor","resizeChunkArray","newStore","Math","min","j","k","dataItem","getItem","chunkIndex","floor","chunkOffset","dimStorage","val","dimRawExtent","nameDim","nameDimChunk","ordinalMeta","categories","id","clean","prepareInvertedIndex","invertedIndices","NaN","get","getRawValueFromStore","dimIndex","rawIndex","chunk","getIndices","newIndices","indices","thisCount","buffer","getRawIndex","chunkStore","value","getByRawIndex","rawIdx","dimStore","_getFast","getValues","values","isArray","len","hasValue","getDataExtent","dimData","initialExtent","currEnd","useRaw","dimExtent","max","getApproximateExtent","setApproximateExtent","extent","getCalculationInfo","key","setCalculationInfo","getSum","sum","getMedian","dimDataArray","sortedDimDataArray","sort","a","b","rawIndexOf","indexOfName","getName","indexOfRawIndex","rawDataIndex","left","right","mid","indicesOfNearest","maxDistance","nearestIndices","Infinity","minDist","Number","MAX_VALUE","minDiff","diff","dist","abs","getRawIndexWithoutIndices","getRawIndexWithIndices","getRawDataItem","getId","normalizeDimensions","validateDimensions","console","error","cb","context","contextCompat","map","dimSize","call","apply","filterSelf","offset","dim0","keep","selectRange","range","originalCount","quickFinished","chunkStorage","dimStorage2","min2","max2","chunkStorage2","val2","dimk","mapArray","result","arguments","cloneListForMapAndSample","original","excludeDimensions","allDimensions","originalStorage","indexOf","cloneDimStore","originalDimStore","newDimStore","tmpRetValue","dataCount","dataIndex","retValue","rawExtentOnDim","downSample","dimension","rate","sampleValue","sampleIndex","targetStorage","frameValues","frameSize","dataIdx","originalChunkIndex","originalChunkOffset","sampleFrameIdx","sampleChunkIndex","sampleChunkOffset","getItemModel","ecModel","otherList","thisList","getVisual","visual","setVisual","setLayout","getLayout","getItemLayout","setItemLayout","layout","merge","clearItemLayouts","getItemVisual","ignoreParent","itemVisual","setItemVisual","clearAllVisual","setItemDataAndSeriesIndex","child","seriesIndex","setItemGraphicEl","el","traverse","getItemGraphicEl","eachItemGraphicEl","cloneShallow","dimensionInfoList","wrapMethod","methodName","injectFunction","originalMethod","res","TRANSFERABLE_METHODS","CHANGABLE_METHODS","_default","module","exports"],"sources":["C:/Users/W/Desktop/vue_map/node_modules/echarts/lib/data/List.js"],"sourcesContent":["var _config = require(\"../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar Model = require(\"../model/Model\");\n\nvar DataDiffer = require(\"./DataDiffer\");\n\nvar Source = require(\"./Source\");\n\nvar _dataProvider = require(\"./helper/dataProvider\");\n\nvar defaultDimValueGetters = _dataProvider.defaultDimValueGetters;\nvar DefaultDataProvider = _dataProvider.DefaultDataProvider;\n\nvar _dimensionHelper = require(\"./helper/dimensionHelper\");\n\nvar summarizeDimensions = _dimensionHelper.summarizeDimensions;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * List for data storage\n * @module echarts/data/List\n */\nvar isObject = zrUtil.isObject;\nvar UNDEFINED = 'undefined'; // Use prefix to avoid index to be the same as otherIdList[idx],\n// which will cause weird udpate animation.\n\nvar ID_PREFIX = 'e\\0\\0';\nvar dataCtors = {\n  'float': typeof Float64Array === UNDEFINED ? Array : Float64Array,\n  'int': typeof Int32Array === UNDEFINED ? Array : Int32Array,\n  // Ordinal data type can be string or int\n  'ordinal': Array,\n  'number': Array,\n  'time': Array\n}; // Caution: MUST not use `new CtorUint32Array(arr, 0, len)`, because the Ctor of array is\n// different from the Ctor of typed array.\n\nvar CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;\nvar CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;\n\nfunction getIndicesCtor(list) {\n  // The possible max value in this._indicies is always this._rawCount despite of filtering.\n  return list._rawCount > 65535 ? CtorUint32Array : CtorUint16Array;\n}\n\nfunction cloneChunk(originalChunk) {\n  var Ctor = originalChunk.constructor; // Only shallow clone is enough when Array.\n\n  return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);\n}\n\nvar TRANSFERABLE_PROPERTIES = ['hasItemOption', '_nameList', '_idList', '_invertedIndicesMap', '_rawData', '_chunkSize', '_chunkCount', '_dimValueGetter', '_count', '_rawCount', '_nameDimIdx', '_idDimIdx'];\nvar CLONE_PROPERTIES = ['_extent', '_approximateExtent', '_rawExtent'];\n\nfunction transferProperties(target, source) {\n  zrUtil.each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function (propName) {\n    if (source.hasOwnProperty(propName)) {\n      target[propName] = source[propName];\n    }\n  });\n  target.__wrappedMethods = source.__wrappedMethods;\n  zrUtil.each(CLONE_PROPERTIES, function (propName) {\n    target[propName] = zrUtil.clone(source[propName]);\n  });\n  target._calculationInfo = zrUtil.extend(source._calculationInfo);\n}\n/**\n * @constructor\n * @alias module:echarts/data/List\n *\n * @param {Array.<string|Object>} dimensions\n *      For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].\n *      Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n *      Spetial fields: {\n *          ordinalMeta: <module:echarts/data/OrdinalMeta>\n *          createInvertedIndices: <boolean>\n *      }\n * @param {module:echarts/model/Model} hostModel\n */\n\n\nvar List = function (dimensions, hostModel) {\n  dimensions = dimensions || ['x', 'y'];\n  var dimensionInfos = {};\n  var dimensionNames = [];\n  var invertedIndicesMap = {};\n\n  for (var i = 0; i < dimensions.length; i++) {\n    // Use the original dimensions[i], where other flag props may exists.\n    var dimensionInfo = dimensions[i];\n\n    if (zrUtil.isString(dimensionInfo)) {\n      dimensionInfo = {\n        name: dimensionInfo\n      };\n    }\n\n    var dimensionName = dimensionInfo.name;\n    dimensionInfo.type = dimensionInfo.type || 'float';\n\n    if (!dimensionInfo.coordDim) {\n      dimensionInfo.coordDim = dimensionName;\n      dimensionInfo.coordDimIndex = 0;\n    }\n\n    dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n    dimensionNames.push(dimensionName);\n    dimensionInfos[dimensionName] = dimensionInfo;\n    dimensionInfo.index = i;\n\n    if (dimensionInfo.createInvertedIndices) {\n      invertedIndicesMap[dimensionName] = [];\n    }\n  }\n  /**\n   * @readOnly\n   * @type {Array.<string>}\n   */\n\n\n  this.dimensions = dimensionNames;\n  /**\n   * Infomation of each data dimension, like data type.\n   * @type {Object}\n   */\n\n  this._dimensionInfos = dimensionInfos;\n  /**\n   * @type {module:echarts/model/Model}\n   */\n\n  this.hostModel = hostModel;\n  /**\n   * @type {module:echarts/model/Model}\n   */\n\n  this.dataType;\n  /**\n   * Indices stores the indices of data subset after filtered.\n   * This data subset will be used in chart.\n   * @type {Array.<number>}\n   * @readOnly\n   */\n\n  this._indices = null;\n  this._count = 0;\n  this._rawCount = 0;\n  /**\n   * Data storage\n   * @type {Object.<key, Array.<TypedArray|Array>>}\n   * @private\n   */\n\n  this._storage = {};\n  /**\n   * @type {Array.<string>}\n   */\n\n  this._nameList = [];\n  /**\n   * @type {Array.<string>}\n   */\n\n  this._idList = [];\n  /**\n   * Models of data option is stored sparse for optimizing memory cost\n   * @type {Array.<module:echarts/model/Model>}\n   * @private\n   */\n\n  this._optionModels = [];\n  /**\n   * Global visual properties after visual coding\n   * @type {Object}\n   * @private\n   */\n\n  this._visual = {};\n  /**\n   * Globel layout properties.\n   * @type {Object}\n   * @private\n   */\n\n  this._layout = {};\n  /**\n   * Item visual properties after visual coding\n   * @type {Array.<Object>}\n   * @private\n   */\n\n  this._itemVisuals = [];\n  /**\n   * Key: visual type, Value: boolean\n   * @type {Object}\n   * @readOnly\n   */\n\n  this.hasItemVisual = {};\n  /**\n   * Item layout properties after layout\n   * @type {Array.<Object>}\n   * @private\n   */\n\n  this._itemLayouts = [];\n  /**\n   * Graphic elemnents\n   * @type {Array.<module:zrender/Element>}\n   * @private\n   */\n\n  this._graphicEls = [];\n  /**\n   * Max size of each chunk.\n   * @type {number}\n   * @private\n   */\n\n  this._chunkSize = 1e5;\n  /**\n   * @type {number}\n   * @private\n   */\n\n  this._chunkCount = 0;\n  /**\n   * @type {Array.<Array|Object>}\n   * @private\n   */\n\n  this._rawData;\n  /**\n   * Raw extent will not be cloned, but only transfered.\n   * It will not be calculated util needed.\n   * key: dim,\n   * value: {end: number, extent: Array.<number>}\n   * @type {Object}\n   * @private\n   */\n\n  this._rawExtent = {};\n  /**\n   * @type {Object}\n   * @private\n   */\n\n  this._extent = {};\n  /**\n   * key: dim\n   * value: extent\n   * @type {Object}\n   * @private\n   */\n\n  this._approximateExtent = {};\n  /**\n   * Cache summary info for fast visit. See \"dimensionHelper\".\n   * @type {Object}\n   * @private\n   */\n\n  this._dimensionsSummary = summarizeDimensions(this);\n  /**\n   * @type {Object.<Array|TypedArray>}\n   * @private\n   */\n\n  this._invertedIndicesMap = invertedIndicesMap;\n  /**\n   * @type {Object}\n   * @private\n   */\n\n  this._calculationInfo = {};\n};\n\nvar listProto = List.prototype;\nlistProto.type = 'list';\n/**\n * If each data item has it's own option\n * @type {boolean}\n */\n\nlistProto.hasItemOption = true;\n/**\n * Get dimension name\n * @param {string|number} dim\n *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n * @return {string} Concrete dim name.\n */\n\nlistProto.getDimension = function (dim) {\n  if (!isNaN(dim)) {\n    dim = this.dimensions[dim] || dim;\n  }\n\n  return dim;\n};\n/**\n * Get type and calculation info of particular dimension\n * @param {string|number} dim\n *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n */\n\n\nlistProto.getDimensionInfo = function (dim) {\n  // Do not clone, because there may be categories in dimInfo.\n  return this._dimensionInfos[this.getDimension(dim)];\n};\n/**\n * @return {Array.<string>} concrete dimension name list on coord.\n */\n\n\nlistProto.getDimensionsOnCoord = function () {\n  return this._dimensionsSummary.dataDimsOnCoord.slice();\n};\n/**\n * @param {string} coordDim\n * @param {number} [idx] A coordDim may map to more than one data dim.\n *        If idx is `true`, return a array of all mapped dims.\n *        If idx is not specified, return the first dim not extra.\n * @return {string|Array.<string>} concrete data dim.\n *        If idx is number, and not found, return null/undefined.\n *        If idx is `true`, and not found, return empty array (always return array).\n */\n\n\nlistProto.mapDimension = function (coordDim, idx) {\n  var dimensionsSummary = this._dimensionsSummary;\n\n  if (idx == null) {\n    return dimensionsSummary.encodeFirstDimNotExtra[coordDim];\n  }\n\n  var dims = dimensionsSummary.encode[coordDim];\n  return idx === true // always return array if idx is `true`\n  ? (dims || []).slice() : dims && dims[idx];\n};\n/**\n * Initialize from data\n * @param {Array.<Object|number|Array>} data source or data or data provider.\n * @param {Array.<string>} [nameLIst] The name of a datum is used on data diff and\n *        defualt label/tooltip.\n *        A name can be specified in encode.itemName,\n *        or dataItem.name (only for series option data),\n *        or provided in nameList from outside.\n * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n */\n\n\nlistProto.initData = function (data, nameList, dimValueGetter) {\n  var notProvider = Source.isInstance(data) || zrUtil.isArrayLike(data);\n\n  if (notProvider) {\n    data = new DefaultDataProvider(data, this.dimensions.length);\n  }\n\n  this._rawData = data; // Clear\n\n  this._storage = {};\n  this._indices = null;\n  this._nameList = nameList || [];\n  this._idList = [];\n  this._nameRepeatCount = {};\n\n  if (!dimValueGetter) {\n    this.hasItemOption = false;\n  }\n  /**\n   * @readOnly\n   */\n\n\n  this.defaultDimValueGetter = defaultDimValueGetters[this._rawData.getSource().sourceFormat]; // Default dim value getter\n\n  this._dimValueGetter = dimValueGetter = dimValueGetter || this.defaultDimValueGetter; // Reset raw extent.\n\n  this._rawExtent = {};\n\n  this._initDataFromProvider(0, data.count()); // If data has no item option.\n\n\n  if (data.pure) {\n    this.hasItemOption = false;\n  }\n};\n\nlistProto.getProvider = function () {\n  return this._rawData;\n};\n\nlistProto.appendData = function (data) {\n  var rawData = this._rawData;\n  var start = this.count();\n  rawData.appendData(data);\n  var end = rawData.count();\n\n  if (!rawData.persistent) {\n    end += start;\n  }\n\n  this._initDataFromProvider(start, end);\n};\n\nlistProto._initDataFromProvider = function (start, end) {\n  // Optimize.\n  if (start >= end) {\n    return;\n  }\n\n  var chunkSize = this._chunkSize;\n  var rawData = this._rawData;\n  var storage = this._storage;\n  var dimensions = this.dimensions;\n  var dimLen = dimensions.length;\n  var dimensionInfoMap = this._dimensionInfos;\n  var nameList = this._nameList;\n  var idList = this._idList;\n  var rawExtent = this._rawExtent;\n  var nameRepeatCount = this._nameRepeatCount = {};\n  var nameDimIdx;\n  var chunkCount = this._chunkCount;\n  var lastChunkIndex = chunkCount - 1;\n\n  for (var i = 0; i < dimLen; i++) {\n    var dim = dimensions[i];\n\n    if (!rawExtent[dim]) {\n      rawExtent[dim] = getInitialExtent();\n    }\n\n    var dimInfo = dimensionInfoMap[dim];\n\n    if (dimInfo.otherDims.itemName === 0) {\n      nameDimIdx = this._nameDimIdx = i;\n    }\n\n    if (dimInfo.otherDims.itemId === 0) {\n      this._idDimIdx = i;\n    }\n\n    var DataCtor = dataCtors[dimInfo.type];\n\n    if (!storage[dim]) {\n      storage[dim] = [];\n    }\n\n    var resizeChunkArray = storage[dim][lastChunkIndex];\n\n    if (resizeChunkArray && resizeChunkArray.length < chunkSize) {\n      var newStore = new DataCtor(Math.min(end - lastChunkIndex * chunkSize, chunkSize)); // The cost of the copy is probably inconsiderable\n      // within the initial chunkSize.\n\n      for (var j = 0; j < resizeChunkArray.length; j++) {\n        newStore[j] = resizeChunkArray[j];\n      }\n\n      storage[dim][lastChunkIndex] = newStore;\n    } // Create new chunks.\n\n\n    for (var k = chunkCount * chunkSize; k < end; k += chunkSize) {\n      storage[dim].push(new DataCtor(Math.min(end - k, chunkSize)));\n    }\n\n    this._chunkCount = storage[dim].length;\n  }\n\n  var dataItem = new Array(dimLen);\n\n  for (var idx = start; idx < end; idx++) {\n    // NOTICE: Try not to write things into dataItem\n    dataItem = rawData.getItem(idx, dataItem); // Each data item is value\n    // [1, 2]\n    // 2\n    // Bar chart, line chart which uses category axis\n    // only gives the 'y' value. 'x' value is the indices of category\n    // Use a tempValue to normalize the value to be a (x, y) value\n\n    var chunkIndex = Math.floor(idx / chunkSize);\n    var chunkOffset = idx % chunkSize; // Store the data by dimensions\n\n    for (var k = 0; k < dimLen; k++) {\n      var dim = dimensions[k];\n      var dimStorage = storage[dim][chunkIndex]; // PENDING NULL is empty or zero\n\n      var val = this._dimValueGetter(dataItem, dim, idx, k);\n\n      dimStorage[chunkOffset] = val;\n      var dimRawExtent = rawExtent[dim];\n\n      if (val < dimRawExtent[0]) {\n        dimRawExtent[0] = val;\n      }\n\n      if (val > dimRawExtent[1]) {\n        dimRawExtent[1] = val;\n      }\n    } // ??? FIXME not check by pure but sourceFormat?\n    // TODO refactor these logic.\n\n\n    if (!rawData.pure) {\n      var name = nameList[idx];\n\n      if (dataItem && name == null) {\n        // If dataItem is {name: ...}, it has highest priority.\n        // That is appropriate for many common cases.\n        if (dataItem.name != null) {\n          // There is no other place to persistent dataItem.name,\n          // so save it to nameList.\n          nameList[idx] = name = dataItem.name;\n        } else if (nameDimIdx != null) {\n          var nameDim = dimensions[nameDimIdx];\n          var nameDimChunk = storage[nameDim][chunkIndex];\n\n          if (nameDimChunk) {\n            name = nameDimChunk[chunkOffset];\n            var ordinalMeta = dimensionInfoMap[nameDim].ordinalMeta;\n\n            if (ordinalMeta && ordinalMeta.categories.length) {\n              name = ordinalMeta.categories[name];\n            }\n          }\n        }\n      } // Try using the id in option\n      // id or name is used on dynamical data, mapping old and new items.\n\n\n      var id = dataItem == null ? null : dataItem.id;\n\n      if (id == null && name != null) {\n        // Use name as id and add counter to avoid same name\n        nameRepeatCount[name] = nameRepeatCount[name] || 0;\n        id = name;\n\n        if (nameRepeatCount[name] > 0) {\n          id += '__ec__' + nameRepeatCount[name];\n        }\n\n        nameRepeatCount[name]++;\n      }\n\n      id != null && (idList[idx] = id);\n    }\n  }\n\n  if (!rawData.persistent && rawData.clean) {\n    // Clean unused data if data source is typed array.\n    rawData.clean();\n  }\n\n  this._rawCount = this._count = end; // Reset data extent\n\n  this._extent = {};\n  prepareInvertedIndex(this);\n};\n\nfunction prepareInvertedIndex(list) {\n  var invertedIndicesMap = list._invertedIndicesMap;\n  zrUtil.each(invertedIndicesMap, function (invertedIndices, dim) {\n    var dimInfo = list._dimensionInfos[dim]; // Currently, only dimensions that has ordinalMeta can create inverted indices.\n\n    var ordinalMeta = dimInfo.ordinalMeta;\n\n    if (ordinalMeta) {\n      invertedIndices = invertedIndicesMap[dim] = new CtorUint32Array(ordinalMeta.categories.length); // The default value of TypedArray is 0. To avoid miss\n      // mapping to 0, we should set it as NaN.\n\n      for (var i = 0; i < invertedIndices.length; i++) {\n        invertedIndices[i] = NaN;\n      }\n\n      for (var i = 0; i < list._count; i++) {\n        // Only support the case that all values are distinct.\n        invertedIndices[list.get(dim, i)] = i;\n      }\n    }\n  });\n}\n\nfunction getRawValueFromStore(list, dimIndex, rawIndex) {\n  var val;\n\n  if (dimIndex != null) {\n    var chunkSize = list._chunkSize;\n    var chunkIndex = Math.floor(rawIndex / chunkSize);\n    var chunkOffset = rawIndex % chunkSize;\n    var dim = list.dimensions[dimIndex];\n    var chunk = list._storage[dim][chunkIndex];\n\n    if (chunk) {\n      val = chunk[chunkOffset];\n      var ordinalMeta = list._dimensionInfos[dim].ordinalMeta;\n\n      if (ordinalMeta && ordinalMeta.categories.length) {\n        val = ordinalMeta.categories[val];\n      }\n    }\n  }\n\n  return val;\n}\n/**\n * @return {number}\n */\n\n\nlistProto.count = function () {\n  return this._count;\n};\n\nlistProto.getIndices = function () {\n  var newIndices;\n  var indices = this._indices;\n\n  if (indices) {\n    var Ctor = indices.constructor;\n    var thisCount = this._count; // `new Array(a, b, c)` is different from `new Uint32Array(a, b, c)`.\n\n    if (Ctor === Array) {\n      newIndices = new Ctor(thisCount);\n\n      for (var i = 0; i < thisCount; i++) {\n        newIndices[i] = indices[i];\n      }\n    } else {\n      newIndices = new Ctor(indices.buffer, 0, thisCount);\n    }\n  } else {\n    var Ctor = getIndicesCtor(this);\n    var newIndices = new Ctor(this.count());\n\n    for (var i = 0; i < newIndices.length; i++) {\n      newIndices[i] = i;\n    }\n  }\n\n  return newIndices;\n};\n/**\n * Get value. Return NaN if idx is out of range.\n * @param {string} dim Dim must be concrete name.\n * @param {number} idx\n * @param {boolean} stack\n * @return {number}\n */\n\n\nlistProto.get = function (dim, idx\n/*, stack */\n) {\n  if (!(idx >= 0 && idx < this._count)) {\n    return NaN;\n  }\n\n  var storage = this._storage;\n\n  if (!storage[dim]) {\n    // TODO Warn ?\n    return NaN;\n  }\n\n  idx = this.getRawIndex(idx);\n  var chunkIndex = Math.floor(idx / this._chunkSize);\n  var chunkOffset = idx % this._chunkSize;\n  var chunkStore = storage[dim][chunkIndex];\n  var value = chunkStore[chunkOffset]; // FIXME ordinal data type is not stackable\n  // if (stack) {\n  //     var dimensionInfo = this._dimensionInfos[dim];\n  //     if (dimensionInfo && dimensionInfo.stackable) {\n  //         var stackedOn = this.stackedOn;\n  //         while (stackedOn) {\n  //             // Get no stacked data of stacked on\n  //             var stackedValue = stackedOn.get(dim, idx);\n  //             // Considering positive stack, negative stack and empty data\n  //             if ((value >= 0 && stackedValue > 0)  // Positive stack\n  //                 || (value <= 0 && stackedValue < 0) // Negative stack\n  //             ) {\n  //                 value += stackedValue;\n  //             }\n  //             stackedOn = stackedOn.stackedOn;\n  //         }\n  //     }\n  // }\n\n  return value;\n};\n/**\n * @param {string} dim concrete dim\n * @param {number} rawIndex\n * @return {number|string}\n */\n\n\nlistProto.getByRawIndex = function (dim, rawIdx) {\n  if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {\n    return NaN;\n  }\n\n  var dimStore = this._storage[dim];\n\n  if (!dimStore) {\n    // TODO Warn ?\n    return NaN;\n  }\n\n  var chunkIndex = Math.floor(rawIdx / this._chunkSize);\n  var chunkOffset = rawIdx % this._chunkSize;\n  var chunkStore = dimStore[chunkIndex];\n  return chunkStore[chunkOffset];\n};\n/**\n * FIXME Use `get` on chrome maybe slow(in filterSelf and selectRange).\n * Hack a much simpler _getFast\n * @private\n */\n\n\nlistProto._getFast = function (dim, rawIdx) {\n  var chunkIndex = Math.floor(rawIdx / this._chunkSize);\n  var chunkOffset = rawIdx % this._chunkSize;\n  var chunkStore = this._storage[dim][chunkIndex];\n  return chunkStore[chunkOffset];\n};\n/**\n * Get value for multi dimensions.\n * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getValues = function (dimensions, idx\n/*, stack */\n) {\n  var values = [];\n\n  if (!zrUtil.isArray(dimensions)) {\n    // stack = idx;\n    idx = dimensions;\n    dimensions = this.dimensions;\n  }\n\n  for (var i = 0, len = dimensions.length; i < len; i++) {\n    values.push(this.get(dimensions[i], idx\n    /*, stack */\n    ));\n  }\n\n  return values;\n};\n/**\n * If value is NaN. Inlcuding '-'\n * Only check the coord dimensions.\n * @param {string} dim\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.hasValue = function (idx) {\n  var dataDimsOnCoord = this._dimensionsSummary.dataDimsOnCoord;\n  var dimensionInfos = this._dimensionInfos;\n\n  for (var i = 0, len = dataDimsOnCoord.length; i < len; i++) {\n    if ( // Ordinal type can be string or number\n    dimensionInfos[dataDimsOnCoord[i]].type !== 'ordinal' // FIXME check ordinal when using index?\n    && isNaN(this.get(dataDimsOnCoord[i], idx))) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Get extent of data in one dimension\n * @param {string} dim\n * @param {boolean} stack\n */\n\n\nlistProto.getDataExtent = function (dim\n/*, stack */\n) {\n  // Make sure use concrete dim as cache name.\n  dim = this.getDimension(dim);\n  var dimData = this._storage[dim];\n  var initialExtent = getInitialExtent(); // stack = !!((stack || false) && this.getCalculationInfo(dim));\n\n  if (!dimData) {\n    return initialExtent;\n  } // Make more strict checkings to ensure hitting cache.\n\n\n  var currEnd = this.count(); // var cacheName = [dim, !!stack].join('_');\n  // var cacheName = dim;\n  // Consider the most cases when using data zoom, `getDataExtent`\n  // happened before filtering. We cache raw extent, which is not\n  // necessary to be cleared and recalculated when restore data.\n\n  var useRaw = !this._indices; // && !stack;\n\n  var dimExtent;\n\n  if (useRaw) {\n    return this._rawExtent[dim].slice();\n  }\n\n  dimExtent = this._extent[dim];\n\n  if (dimExtent) {\n    return dimExtent.slice();\n  }\n\n  dimExtent = initialExtent;\n  var min = dimExtent[0];\n  var max = dimExtent[1];\n\n  for (var i = 0; i < currEnd; i++) {\n    // var value = stack ? this.get(dim, i, true) : this._getFast(dim, this.getRawIndex(i));\n    var value = this._getFast(dim, this.getRawIndex(i));\n\n    value < min && (min = value);\n    value > max && (max = value);\n  }\n\n  dimExtent = [min, max];\n  this._extent[dim] = dimExtent;\n  return dimExtent;\n};\n/**\n * Optimize for the scenario that data is filtered by a given extent.\n * Consider that if data amount is more than hundreds of thousand,\n * extent calculation will cost more than 10ms and the cache will\n * be erased because of the filtering.\n */\n\n\nlistProto.getApproximateExtent = function (dim\n/*, stack */\n) {\n  dim = this.getDimension(dim);\n  return this._approximateExtent[dim] || this.getDataExtent(dim\n  /*, stack */\n  );\n};\n\nlistProto.setApproximateExtent = function (extent, dim\n/*, stack */\n) {\n  dim = this.getDimension(dim);\n  this._approximateExtent[dim] = extent.slice();\n};\n/**\n * @param {string} key\n * @return {*}\n */\n\n\nlistProto.getCalculationInfo = function (key) {\n  return this._calculationInfo[key];\n};\n/**\n * @param {string|Object} key or k-v object\n * @param {*} [value]\n */\n\n\nlistProto.setCalculationInfo = function (key, value) {\n  isObject(key) ? zrUtil.extend(this._calculationInfo, key) : this._calculationInfo[key] = value;\n};\n/**\n * Get sum of data in one dimension\n * @param {string} dim\n */\n\n\nlistProto.getSum = function (dim\n/*, stack */\n) {\n  var dimData = this._storage[dim];\n  var sum = 0;\n\n  if (dimData) {\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var value = this.get(dim, i\n      /*, stack */\n      );\n\n      if (!isNaN(value)) {\n        sum += value;\n      }\n    }\n  }\n\n  return sum;\n};\n/**\n * Get median of data in one dimension\n * @param {string} dim\n */\n\n\nlistProto.getMedian = function (dim\n/*, stack */\n) {\n  var dimDataArray = []; // map all data of one dimension\n\n  this.each(dim, function (val, idx) {\n    if (!isNaN(val)) {\n      dimDataArray.push(val);\n    }\n  }); // TODO\n  // Use quick select?\n  // immutability & sort\n\n  var sortedDimDataArray = [].concat(dimDataArray).sort(function (a, b) {\n    return a - b;\n  });\n  var len = this.count(); // calculate median\n\n  return len === 0 ? 0 : len % 2 === 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2;\n}; // /**\n//  * Retreive the index with given value\n//  * @param {string} dim Concrete dimension.\n//  * @param {number} value\n//  * @return {number}\n//  */\n// Currently incorrect: should return dataIndex but not rawIndex.\n// Do not fix it until this method is to be used somewhere.\n// FIXME Precision of float value\n// listProto.indexOf = function (dim, value) {\n//     var storage = this._storage;\n//     var dimData = storage[dim];\n//     var chunkSize = this._chunkSize;\n//     if (dimData) {\n//         for (var i = 0, len = this.count(); i < len; i++) {\n//             var chunkIndex = Math.floor(i / chunkSize);\n//             var chunkOffset = i % chunkSize;\n//             if (dimData[chunkIndex][chunkOffset] === value) {\n//                 return i;\n//             }\n//         }\n//     }\n//     return -1;\n// };\n\n/**\n * Only support the dimension which inverted index created.\n * Do not support other cases until required.\n * @param {string} concrete dim\n * @param {number|string} value\n * @return {number} rawIndex\n */\n\n\nlistProto.rawIndexOf = function (dim, value) {\n  var invertedIndices = dim && this._invertedIndicesMap[dim];\n  var rawIndex = invertedIndices[value];\n\n  if (rawIndex == null || isNaN(rawIndex)) {\n    return -1;\n  }\n\n  return rawIndex;\n};\n/**\n * Retreive the index with given name\n * @param {number} idx\n * @param {number} name\n * @return {number}\n */\n\n\nlistProto.indexOfName = function (name) {\n  for (var i = 0, len = this.count(); i < len; i++) {\n    if (this.getName(i) === name) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n/**\n * Retreive the index with given raw data index\n * @param {number} idx\n * @param {number} name\n * @return {number}\n */\n\n\nlistProto.indexOfRawIndex = function (rawIndex) {\n  if (!this._indices) {\n    return rawIndex;\n  }\n\n  if (rawIndex >= this._rawCount || rawIndex < 0) {\n    return -1;\n  } // Indices are ascending\n\n\n  var indices = this._indices; // If rawIndex === dataIndex\n\n  var rawDataIndex = indices[rawIndex];\n\n  if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {\n    return rawIndex;\n  }\n\n  var left = 0;\n  var right = this._count - 1;\n\n  while (left <= right) {\n    var mid = (left + right) / 2 | 0;\n\n    if (indices[mid] < rawIndex) {\n      left = mid + 1;\n    } else if (indices[mid] > rawIndex) {\n      right = mid - 1;\n    } else {\n      return mid;\n    }\n  }\n\n  return -1;\n};\n/**\n * Retreive the index of nearest value\n * @param {string} dim\n * @param {number} value\n * @param {number} [maxDistance=Infinity]\n * @return {Array.<number>} Considere multiple points has the same value.\n */\n\n\nlistProto.indicesOfNearest = function (dim, value, maxDistance) {\n  var storage = this._storage;\n  var dimData = storage[dim];\n  var nearestIndices = [];\n\n  if (!dimData) {\n    return nearestIndices;\n  }\n\n  if (maxDistance == null) {\n    maxDistance = Infinity;\n  }\n\n  var minDist = Number.MAX_VALUE;\n  var minDiff = -1;\n\n  for (var i = 0, len = this.count(); i < len; i++) {\n    var diff = value - this.get(dim, i\n    /*, stack */\n    );\n    var dist = Math.abs(diff);\n\n    if (diff <= maxDistance && dist <= minDist) {\n      // For the case of two data are same on xAxis, which has sequence data.\n      // Show the nearest index\n      // https://github.com/ecomfe/echarts/issues/2869\n      if (dist < minDist || diff >= 0 && minDiff < 0) {\n        minDist = dist;\n        minDiff = diff;\n        nearestIndices.length = 0;\n      }\n\n      nearestIndices.push(i);\n    }\n  }\n\n  return nearestIndices;\n};\n/**\n * Get raw data index\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getRawIndex = getRawIndexWithoutIndices;\n\nfunction getRawIndexWithoutIndices(idx) {\n  return idx;\n}\n\nfunction getRawIndexWithIndices(idx) {\n  if (idx < this._count && idx >= 0) {\n    return this._indices[idx];\n  }\n\n  return -1;\n}\n/**\n * Get raw data item\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getRawDataItem = function (idx) {\n  if (!this._rawData.persistent) {\n    var val = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      var dim = this.dimensions[i];\n      val.push(this.get(dim, idx));\n    }\n\n    return val;\n  } else {\n    return this._rawData.getItem(this.getRawIndex(idx));\n  }\n};\n/**\n * @param {number} idx\n * @param {boolean} [notDefaultIdx=false]\n * @return {string}\n */\n\n\nlistProto.getName = function (idx) {\n  var rawIndex = this.getRawIndex(idx);\n  return this._nameList[rawIndex] || getRawValueFromStore(this, this._nameDimIdx, rawIndex) || '';\n};\n/**\n * @param {number} idx\n * @param {boolean} [notDefaultIdx=false]\n * @return {string}\n */\n\n\nlistProto.getId = function (idx) {\n  return getId(this, this.getRawIndex(idx));\n};\n\nfunction getId(list, rawIndex) {\n  var id = list._idList[rawIndex];\n\n  if (id == null) {\n    id = getRawValueFromStore(list, list._idDimIdx, rawIndex);\n  }\n\n  if (id == null) {\n    // FIXME Check the usage in graph, should not use prefix.\n    id = ID_PREFIX + rawIndex;\n  }\n\n  return id;\n}\n\nfunction normalizeDimensions(dimensions) {\n  if (!zrUtil.isArray(dimensions)) {\n    dimensions = [dimensions];\n  }\n\n  return dimensions;\n}\n\nfunction validateDimensions(list, dims) {\n  for (var i = 0; i < dims.length; i++) {\n    // stroage may be empty when no data, so use\n    // dimensionInfos to check.\n    if (!list._dimensionInfos[dims[i]]) {\n      console.error('Unkown dimension ' + dims[i]);\n    }\n  }\n}\n/**\n * Data iteration\n * @param {string|Array.<string>}\n * @param {Function} cb\n * @param {*} [context=this]\n *\n * @example\n *  list.each('x', function (x, idx) {});\n *  list.each(['x', 'y'], function (x, y, idx) {});\n *  list.each(function (idx) {})\n */\n\n\nlistProto.each = function (dims, cb, context, contextCompat) {\n  'use strict';\n\n  if (!this._count) {\n    return;\n  }\n\n  if (typeof dims === 'function') {\n    contextCompat = context;\n    context = cb;\n    cb = dims;\n    dims = [];\n  } // contextCompat just for compat echarts3\n\n\n  context = context || contextCompat || this;\n  dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n  var dimSize = dims.length;\n\n  for (var i = 0; i < this.count(); i++) {\n    // Simple optimization\n    switch (dimSize) {\n      case 0:\n        cb.call(context, i);\n        break;\n\n      case 1:\n        cb.call(context, this.get(dims[0], i), i);\n        break;\n\n      case 2:\n        cb.call(context, this.get(dims[0], i), this.get(dims[1], i), i);\n        break;\n\n      default:\n        var k = 0;\n        var value = [];\n\n        for (; k < dimSize; k++) {\n          value[k] = this.get(dims[k], i);\n        } // Index\n\n\n        value[k] = i;\n        cb.apply(context, value);\n    }\n  }\n};\n/**\n * Data filter\n * @param {string|Array.<string>}\n * @param {Function} cb\n * @param {*} [context=this]\n */\n\n\nlistProto.filterSelf = function (dimensions, cb, context, contextCompat) {\n  'use strict';\n\n  if (!this._count) {\n    return;\n  }\n\n  if (typeof dimensions === 'function') {\n    contextCompat = context;\n    context = cb;\n    cb = dimensions;\n    dimensions = [];\n  } // contextCompat just for compat echarts3\n\n\n  context = context || contextCompat || this;\n  dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n  var count = this.count();\n  var Ctor = getIndicesCtor(this);\n  var newIndices = new Ctor(count);\n  var value = [];\n  var dimSize = dimensions.length;\n  var offset = 0;\n  var dim0 = dimensions[0];\n\n  for (var i = 0; i < count; i++) {\n    var keep;\n    var rawIdx = this.getRawIndex(i); // Simple optimization\n\n    if (dimSize === 0) {\n      keep = cb.call(context, i);\n    } else if (dimSize === 1) {\n      var val = this._getFast(dim0, rawIdx);\n\n      keep = cb.call(context, val, i);\n    } else {\n      for (var k = 0; k < dimSize; k++) {\n        value[k] = this._getFast(dim0, rawIdx);\n      }\n\n      value[k] = i;\n      keep = cb.apply(context, value);\n    }\n\n    if (keep) {\n      newIndices[offset++] = rawIdx;\n    }\n  } // Set indices after filtered.\n\n\n  if (offset < count) {\n    this._indices = newIndices;\n  }\n\n  this._count = offset; // Reset data extent\n\n  this._extent = {};\n  this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  return this;\n};\n/**\n * Select data in range. (For optimization of filter)\n * (Manually inline code, support 5 million data filtering in data zoom.)\n */\n\n\nlistProto.selectRange = function (range) {\n  'use strict';\n\n  if (!this._count) {\n    return;\n  }\n\n  var dimensions = [];\n\n  for (var dim in range) {\n    if (range.hasOwnProperty(dim)) {\n      dimensions.push(dim);\n    }\n  }\n\n  var dimSize = dimensions.length;\n\n  if (!dimSize) {\n    return;\n  }\n\n  var originalCount = this.count();\n  var Ctor = getIndicesCtor(this);\n  var newIndices = new Ctor(originalCount);\n  var offset = 0;\n  var dim0 = dimensions[0];\n  var min = range[dim0][0];\n  var max = range[dim0][1];\n  var quickFinished = false;\n\n  if (!this._indices) {\n    // Extreme optimization for common case. About 2x faster in chrome.\n    var idx = 0;\n\n    if (dimSize === 1) {\n      var dimStorage = this._storage[dimensions[0]];\n\n      for (var k = 0; k < this._chunkCount; k++) {\n        var chunkStorage = dimStorage[k];\n        var len = Math.min(this._count - k * this._chunkSize, this._chunkSize);\n\n        for (var i = 0; i < len; i++) {\n          var val = chunkStorage[i]; // NaN will not be filtered. Consider the case, in line chart, empty\n          // value indicates the line should be broken. But for the case like\n          // scatter plot, a data item with empty value will not be rendered,\n          // but the axis extent may be effected if some other dim of the data\n          // item has value. Fortunately it is not a significant negative effect.\n\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n      }\n\n      quickFinished = true;\n    } else if (dimSize === 2) {\n      var dimStorage = this._storage[dim0];\n      var dimStorage2 = this._storage[dimensions[1]];\n      var min2 = range[dimensions[1]][0];\n      var max2 = range[dimensions[1]][1];\n\n      for (var k = 0; k < this._chunkCount; k++) {\n        var chunkStorage = dimStorage[k];\n        var chunkStorage2 = dimStorage2[k];\n        var len = Math.min(this._count - k * this._chunkSize, this._chunkSize);\n\n        for (var i = 0; i < len; i++) {\n          var val = chunkStorage[i];\n          var val2 = chunkStorage2[i]; // Do not filter NaN, see comment above.\n\n          if ((val >= min && val <= max || isNaN(val)) && (val2 >= min2 && val2 <= max2 || isNaN(val2))) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n      }\n\n      quickFinished = true;\n    }\n  }\n\n  if (!quickFinished) {\n    if (dimSize === 1) {\n      for (var i = 0; i < originalCount; i++) {\n        var rawIndex = this.getRawIndex(i);\n\n        var val = this._getFast(dim0, rawIndex); // Do not filter NaN, see comment above.\n\n\n        if (val >= min && val <= max || isNaN(val)) {\n          newIndices[offset++] = rawIndex;\n        }\n      }\n    } else {\n      for (var i = 0; i < originalCount; i++) {\n        var keep = true;\n        var rawIndex = this.getRawIndex(i);\n\n        for (var k = 0; k < dimSize; k++) {\n          var dimk = dimensions[k];\n\n          var val = this._getFast(dim, rawIndex); // Do not filter NaN, see comment above.\n\n\n          if (val < range[dimk][0] || val > range[dimk][1]) {\n            keep = false;\n          }\n        }\n\n        if (keep) {\n          newIndices[offset++] = this.getRawIndex(i);\n        }\n      }\n    }\n  } // Set indices after filtered.\n\n\n  if (offset < originalCount) {\n    this._indices = newIndices;\n  }\n\n  this._count = offset; // Reset data extent\n\n  this._extent = {};\n  this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  return this;\n};\n/**\n * Data mapping to a plain array\n * @param {string|Array.<string>} [dimensions]\n * @param {Function} cb\n * @param {*} [context=this]\n * @return {Array}\n */\n\n\nlistProto.mapArray = function (dimensions, cb, context, contextCompat) {\n  'use strict';\n\n  if (typeof dimensions === 'function') {\n    contextCompat = context;\n    context = cb;\n    cb = dimensions;\n    dimensions = [];\n  } // contextCompat just for compat echarts3\n\n\n  context = context || contextCompat || this;\n  var result = [];\n  this.each(dimensions, function () {\n    result.push(cb && cb.apply(this, arguments));\n  }, context);\n  return result;\n}; // Data in excludeDimensions is copied, otherwise transfered.\n\n\nfunction cloneListForMapAndSample(original, excludeDimensions) {\n  var allDimensions = original.dimensions;\n  var list = new List(zrUtil.map(allDimensions, original.getDimensionInfo, original), original.hostModel); // FIXME If needs stackedOn, value may already been stacked\n\n  transferProperties(list, original);\n  var storage = list._storage = {};\n  var originalStorage = original._storage; // Init storage\n\n  for (var i = 0; i < allDimensions.length; i++) {\n    var dim = allDimensions[i];\n\n    if (originalStorage[dim]) {\n      // Notice that we do not reset invertedIndicesMap here, becuase\n      // there is no scenario of mapping or sampling ordinal dimension.\n      if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n        storage[dim] = cloneDimStore(originalStorage[dim]);\n        list._rawExtent[dim] = getInitialExtent();\n        list._extent[dim] = null;\n      } else {\n        // Direct reference for other dimensions\n        storage[dim] = originalStorage[dim];\n      }\n    }\n  }\n\n  return list;\n}\n\nfunction cloneDimStore(originalDimStore) {\n  var newDimStore = new Array(originalDimStore.length);\n\n  for (var j = 0; j < originalDimStore.length; j++) {\n    newDimStore[j] = cloneChunk(originalDimStore[j]);\n  }\n\n  return newDimStore;\n}\n\nfunction getInitialExtent() {\n  return [Infinity, -Infinity];\n}\n/**\n * Data mapping to a new List with given dimensions\n * @param {string|Array.<string>} dimensions\n * @param {Function} cb\n * @param {*} [context=this]\n * @return {Array}\n */\n\n\nlistProto.map = function (dimensions, cb, context, contextCompat) {\n  'use strict'; // contextCompat just for compat echarts3\n\n  context = context || contextCompat || this;\n  dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n  var list = cloneListForMapAndSample(this, dimensions); // Following properties are all immutable.\n  // So we can reference to the same value\n\n  list._indices = this._indices;\n  list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  var storage = list._storage;\n  var tmpRetValue = [];\n  var chunkSize = this._chunkSize;\n  var dimSize = dimensions.length;\n  var dataCount = this.count();\n  var values = [];\n  var rawExtent = list._rawExtent;\n\n  for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {\n    for (var dimIndex = 0; dimIndex < dimSize; dimIndex++) {\n      values[dimIndex] = this.get(dimensions[dimIndex], dataIndex\n      /*, stack */\n      );\n    }\n\n    values[dimSize] = dataIndex;\n    var retValue = cb && cb.apply(context, values);\n\n    if (retValue != null) {\n      // a number or string (in oridinal dimension)?\n      if (typeof retValue !== 'object') {\n        tmpRetValue[0] = retValue;\n        retValue = tmpRetValue;\n      }\n\n      var rawIndex = this.getRawIndex(dataIndex);\n      var chunkIndex = Math.floor(rawIndex / chunkSize);\n      var chunkOffset = rawIndex % chunkSize;\n\n      for (var i = 0; i < retValue.length; i++) {\n        var dim = dimensions[i];\n        var val = retValue[i];\n        var rawExtentOnDim = rawExtent[dim];\n        var dimStore = storage[dim];\n\n        if (dimStore) {\n          dimStore[chunkIndex][chunkOffset] = val;\n        }\n\n        if (val < rawExtentOnDim[0]) {\n          rawExtentOnDim[0] = val;\n        }\n\n        if (val > rawExtentOnDim[1]) {\n          rawExtentOnDim[1] = val;\n        }\n      }\n    }\n  }\n\n  return list;\n};\n/**\n * Large data down sampling on given dimension\n * @param {string} dimension\n * @param {number} rate\n * @param {Function} sampleValue\n * @param {Function} sampleIndex Sample index for name and id\n */\n\n\nlistProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n  var list = cloneListForMapAndSample(this, [dimension]);\n  var targetStorage = list._storage;\n  var frameValues = [];\n  var frameSize = Math.floor(1 / rate);\n  var dimStore = targetStorage[dimension];\n  var len = this.count();\n  var chunkSize = this._chunkSize;\n  var rawExtentOnDim = list._rawExtent[dimension];\n  var newIndices = new (getIndicesCtor(this))(len);\n  var offset = 0;\n\n  for (var i = 0; i < len; i += frameSize) {\n    // Last frame\n    if (frameSize > len - i) {\n      frameSize = len - i;\n      frameValues.length = frameSize;\n    }\n\n    for (var k = 0; k < frameSize; k++) {\n      var dataIdx = this.getRawIndex(i + k);\n      var originalChunkIndex = Math.floor(dataIdx / chunkSize);\n      var originalChunkOffset = dataIdx % chunkSize;\n      frameValues[k] = dimStore[originalChunkIndex][originalChunkOffset];\n    }\n\n    var value = sampleValue(frameValues);\n    var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1));\n    var sampleChunkIndex = Math.floor(sampleFrameIdx / chunkSize);\n    var sampleChunkOffset = sampleFrameIdx % chunkSize; // Only write value on the filtered data\n\n    dimStore[sampleChunkIndex][sampleChunkOffset] = value;\n\n    if (value < rawExtentOnDim[0]) {\n      rawExtentOnDim[0] = value;\n    }\n\n    if (value > rawExtentOnDim[1]) {\n      rawExtentOnDim[1] = value;\n    }\n\n    newIndices[offset++] = sampleFrameIdx;\n  }\n\n  list._count = offset;\n  list._indices = newIndices;\n  list.getRawIndex = getRawIndexWithIndices;\n  return list;\n};\n/**\n * Get model of one data item.\n *\n * @param {number} idx\n */\n// FIXME Model proxy ?\n\n\nlistProto.getItemModel = function (idx) {\n  var hostModel = this.hostModel;\n  return new Model(this.getRawDataItem(idx), hostModel, hostModel && hostModel.ecModel);\n};\n/**\n * Create a data differ\n * @param {module:echarts/data/List} otherList\n * @return {module:echarts/data/DataDiffer}\n */\n\n\nlistProto.diff = function (otherList) {\n  var thisList = this;\n  return new DataDiffer(otherList ? otherList.getIndices() : [], this.getIndices(), function (idx) {\n    return getId(otherList, idx);\n  }, function (idx) {\n    return getId(thisList, idx);\n  });\n};\n/**\n * Get visual property.\n * @param {string} key\n */\n\n\nlistProto.getVisual = function (key) {\n  var visual = this._visual;\n  return visual && visual[key];\n};\n/**\n * Set visual property\n * @param {string|Object} key\n * @param {*} [value]\n *\n * @example\n *  setVisual('color', color);\n *  setVisual({\n *      'color': color\n *  });\n */\n\n\nlistProto.setVisual = function (key, val) {\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        this.setVisual(name, key[name]);\n      }\n    }\n\n    return;\n  }\n\n  this._visual = this._visual || {};\n  this._visual[key] = val;\n};\n/**\n * Set layout property.\n * @param {string|Object} key\n * @param {*} [val]\n */\n\n\nlistProto.setLayout = function (key, val) {\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        this.setLayout(name, key[name]);\n      }\n    }\n\n    return;\n  }\n\n  this._layout[key] = val;\n};\n/**\n * Get layout property.\n * @param  {string} key.\n * @return {*}\n */\n\n\nlistProto.getLayout = function (key) {\n  return this._layout[key];\n};\n/**\n * Get layout of single data item\n * @param {number} idx\n */\n\n\nlistProto.getItemLayout = function (idx) {\n  return this._itemLayouts[idx];\n};\n/**\n * Set layout of single data item\n * @param {number} idx\n * @param {Object} layout\n * @param {boolean=} [merge=false]\n */\n\n\nlistProto.setItemLayout = function (idx, layout, merge) {\n  this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\n};\n/**\n * Clear all layout of single data item\n */\n\n\nlistProto.clearItemLayouts = function () {\n  this._itemLayouts.length = 0;\n};\n/**\n * Get visual property of single data item\n * @param {number} idx\n * @param {string} key\n * @param {boolean} [ignoreParent=false]\n */\n\n\nlistProto.getItemVisual = function (idx, key, ignoreParent) {\n  var itemVisual = this._itemVisuals[idx];\n  var val = itemVisual && itemVisual[key];\n\n  if (val == null && !ignoreParent) {\n    // Use global visual property\n    return this.getVisual(key);\n  }\n\n  return val;\n};\n/**\n * Set visual property of single data item\n *\n * @param {number} idx\n * @param {string|Object} key\n * @param {*} [value]\n *\n * @example\n *  setItemVisual(0, 'color', color);\n *  setItemVisual(0, {\n *      'color': color\n *  });\n */\n\n\nlistProto.setItemVisual = function (idx, key, value) {\n  var itemVisual = this._itemVisuals[idx] || {};\n  var hasItemVisual = this.hasItemVisual;\n  this._itemVisuals[idx] = itemVisual;\n\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        itemVisual[name] = key[name];\n        hasItemVisual[name] = true;\n      }\n    }\n\n    return;\n  }\n\n  itemVisual[key] = value;\n  hasItemVisual[key] = true;\n};\n/**\n * Clear itemVisuals and list visual.\n */\n\n\nlistProto.clearAllVisual = function () {\n  this._visual = {};\n  this._itemVisuals = [];\n  this.hasItemVisual = {};\n};\n\nvar setItemDataAndSeriesIndex = function (child) {\n  child.seriesIndex = this.seriesIndex;\n  child.dataIndex = this.dataIndex;\n  child.dataType = this.dataType;\n};\n/**\n * Set graphic element relative to data. It can be set as null\n * @param {number} idx\n * @param {module:zrender/Element} [el]\n */\n\n\nlistProto.setItemGraphicEl = function (idx, el) {\n  var hostModel = this.hostModel;\n\n  if (el) {\n    // Add data index and series index for indexing the data by element\n    // Useful in tooltip\n    el.dataIndex = idx;\n    el.dataType = this.dataType;\n    el.seriesIndex = hostModel && hostModel.seriesIndex;\n\n    if (el.type === 'group') {\n      el.traverse(setItemDataAndSeriesIndex, el);\n    }\n  }\n\n  this._graphicEls[idx] = el;\n};\n/**\n * @param {number} idx\n * @return {module:zrender/Element}\n */\n\n\nlistProto.getItemGraphicEl = function (idx) {\n  return this._graphicEls[idx];\n};\n/**\n * @param {Function} cb\n * @param {*} context\n */\n\n\nlistProto.eachItemGraphicEl = function (cb, context) {\n  zrUtil.each(this._graphicEls, function (el, idx) {\n    if (el) {\n      cb && cb.call(context, el, idx);\n    }\n  });\n};\n/**\n * Shallow clone a new list except visual and layout properties, and graph elements.\n * New list only change the indices.\n */\n\n\nlistProto.cloneShallow = function (list) {\n  if (!list) {\n    var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n    list = new List(dimensionInfoList, this.hostModel);\n  } // FIXME\n\n\n  list._storage = this._storage;\n  transferProperties(list, this); // Clone will not change the data extent and indices\n\n  if (this._indices) {\n    var Ctor = this._indices.constructor;\n    list._indices = new Ctor(this._indices);\n  } else {\n    list._indices = null;\n  }\n\n  list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  return list;\n};\n/**\n * Wrap some method to add more feature\n * @param {string} methodName\n * @param {Function} injectFunction\n */\n\n\nlistProto.wrapMethod = function (methodName, injectFunction) {\n  var originalMethod = this[methodName];\n\n  if (typeof originalMethod !== 'function') {\n    return;\n  }\n\n  this.__wrappedMethods = this.__wrappedMethods || [];\n\n  this.__wrappedMethods.push(methodName);\n\n  this[methodName] = function () {\n    var res = originalMethod.apply(this, arguments);\n    return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n  };\n}; // Methods that create a new list based on this list should be listed here.\n// Notice that those method should `RETURN` the new list.\n\n\nlistProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map']; // Methods that change indices of this list should be listed here.\n\nlistProto.CHANGABLE_METHODS = ['filterSelf', 'selectRange'];\nvar _default = List;\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}