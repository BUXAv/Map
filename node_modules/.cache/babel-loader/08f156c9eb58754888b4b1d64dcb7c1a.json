{"ast":null,"code":"var Animator = require(\"../animation/Animator\");\n\nvar log = require(\"../core/log\");\n\nvar _util = require(\"../core/util\");\n\nvar isString = _util.isString;\nvar isFunction = _util.isFunction;\nvar isObject = _util.isObject;\nvar isArrayLike = _util.isArrayLike;\nvar indexOf = _util.indexOf;\n/**\n * @alias modue:zrender/mixin/Animatable\n * @constructor\n */\n\nvar Animatable = function () {\n  /**\n   * @type {Array.<module:zrender/animation/Animator>}\n   * @readOnly\n   */\n  this.animators = [];\n};\n\nAnimatable.prototype = {\n  constructor: Animatable,\n\n  /**\n   * 动画\n   *\n   * @param {string} path The path to fetch value from object, like 'a.b.c'.\n   * @param {boolean} [loop] Whether to loop animation.\n   * @return {module:zrender/animation/Animator}\n   * @example:\n   *     el.animate('style', false)\n   *         .when(1000, {x: 10} )\n   *         .done(function(){ // Animation done })\n   *         .start()\n   */\n  animate: function (path, loop) {\n    var target;\n    var animatingShape = false;\n    var el = this;\n    var zr = this.__zr;\n\n    if (path) {\n      var pathSplitted = path.split('.');\n      var prop = el; // If animating shape\n\n      animatingShape = pathSplitted[0] === 'shape';\n\n      for (var i = 0, l = pathSplitted.length; i < l; i++) {\n        if (!prop) {\n          continue;\n        }\n\n        prop = prop[pathSplitted[i]];\n      }\n\n      if (prop) {\n        target = prop;\n      }\n    } else {\n      target = el;\n    }\n\n    if (!target) {\n      log('Property \"' + path + '\" is not existed in element ' + el.id);\n      return;\n    }\n\n    var animators = el.animators;\n    var animator = new Animator(target, loop);\n    animator.during(function (target) {\n      el.dirty(animatingShape);\n    }).done(function () {\n      // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n      animators.splice(indexOf(animators, animator), 1);\n    });\n    animators.push(animator); // If animate after added to the zrender\n\n    if (zr) {\n      zr.animation.addAnimator(animator);\n    }\n\n    return animator;\n  },\n\n  /**\n   * 停止动画\n   * @param {boolean} forwardToLast If move to last frame before stop\n   */\n  stopAnimation: function (forwardToLast) {\n    var animators = this.animators;\n    var len = animators.length;\n\n    for (var i = 0; i < len; i++) {\n      animators[i].stop(forwardToLast);\n    }\n\n    animators.length = 0;\n    return this;\n  },\n\n  /**\n   * Caution: this method will stop previous animation.\n   * So do not use this method to one element twice before\n   * animation starts, unless you know what you are doing.\n   * @param {Object} target\n   * @param {number} [time=500] Time in ms\n   * @param {string} [easing='linear']\n   * @param {number} [delay=0]\n   * @param {Function} [callback]\n   * @param {Function} [forceAnimate] Prevent stop animation and callback\n   *        immediently when target values are the same as current values.\n   *\n   * @example\n   *  // Animate position\n   *  el.animateTo({\n   *      position: [10, 10]\n   *  }, function () { // done })\n   *\n   *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n   *  el.animateTo({\n   *      shape: {\n   *          width: 500\n   *      },\n   *      style: {\n   *          fill: 'red'\n   *      }\n   *      position: [10, 10]\n   *  }, 100, 100, 'cubicOut', function () { // done })\n   */\n  // TODO Return animation key\n  animateTo: function (target, time, delay, easing, callback, forceAnimate) {\n    // animateTo(target, time, easing, callback);\n    if (isString(delay)) {\n      callback = easing;\n      easing = delay;\n      delay = 0;\n    } // animateTo(target, time, delay, callback);\n    else if (isFunction(easing)) {\n      callback = easing;\n      easing = 'linear';\n      delay = 0;\n    } // animateTo(target, time, callback);\n    else if (isFunction(delay)) {\n      callback = delay;\n      delay = 0;\n    } // animateTo(target, callback)\n    else if (isFunction(time)) {\n      callback = time;\n      time = 500;\n    } // animateTo(target)\n    else if (!time) {\n      time = 500;\n    } // Stop all previous animations\n\n\n    this.stopAnimation();\n\n    this._animateToShallow('', this, target, time, delay); // Animators may be removed immediately after start\n    // if there is nothing to animate\n\n\n    var animators = this.animators.slice();\n    var count = animators.length;\n\n    function done() {\n      count--;\n\n      if (!count) {\n        callback && callback();\n      }\n    } // No animators. This should be checked before animators[i].start(),\n    // because 'done' may be executed immediately if no need to animate.\n\n\n    if (!count) {\n      callback && callback();\n    } // Start after all animators created\n    // Incase any animator is done immediately when all animation properties are not changed\n\n\n    for (var i = 0; i < animators.length; i++) {\n      animators[i].done(done).start(easing, forceAnimate);\n    }\n  },\n\n  /**\n   * @private\n   * @param {string} path=''\n   * @param {Object} source=this\n   * @param {Object} target\n   * @param {number} [time=500]\n   * @param {number} [delay=0]\n   *\n   * @example\n   *  // Animate position\n   *  el._animateToShallow({\n   *      position: [10, 10]\n   *  })\n   *\n   *  // Animate shape, style and position in 100ms, delayed 100ms\n   *  el._animateToShallow({\n   *      shape: {\n   *          width: 500\n   *      },\n   *      style: {\n   *          fill: 'red'\n   *      }\n   *      position: [10, 10]\n   *  }, 100, 100)\n   */\n  _animateToShallow: function (path, source, target, time, delay) {\n    var objShallow = {};\n    var propertyCount = 0;\n\n    for (var name in target) {\n      if (!target.hasOwnProperty(name)) {\n        continue;\n      }\n\n      if (source[name] != null) {\n        if (isObject(target[name]) && !isArrayLike(target[name])) {\n          this._animateToShallow(path ? path + '.' + name : name, source[name], target[name], time, delay);\n        } else {\n          objShallow[name] = target[name];\n          propertyCount++;\n        }\n      } else if (target[name] != null) {\n        // Attr directly if not has property\n        // FIXME, if some property not needed for element ?\n        if (!path) {\n          this.attr(name, target[name]);\n        } else {\n          // Shape or style\n          var props = {};\n          props[path] = {};\n          props[path][name] = target[name];\n          this.attr(props);\n        }\n      }\n    }\n\n    if (propertyCount > 0) {\n      this.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);\n    }\n\n    return this;\n  }\n};\nvar _default = Animatable;\nmodule.exports = _default;","map":{"version":3,"names":["Animator","require","log","_util","isString","isFunction","isObject","isArrayLike","indexOf","Animatable","animators","prototype","constructor","animate","path","loop","target","animatingShape","el","zr","__zr","pathSplitted","split","prop","i","l","length","id","animator","during","dirty","done","splice","push","animation","addAnimator","stopAnimation","forwardToLast","len","stop","animateTo","time","delay","easing","callback","forceAnimate","_animateToShallow","slice","count","start","source","objShallow","propertyCount","name","hasOwnProperty","attr","props","when","_default","module","exports"],"sources":["C:/Users/W/Desktop/vue_map/node_modules/zrender/lib/mixin/Animatable.js"],"sourcesContent":["var Animator = require(\"../animation/Animator\");\n\nvar log = require(\"../core/log\");\n\nvar _util = require(\"../core/util\");\n\nvar isString = _util.isString;\nvar isFunction = _util.isFunction;\nvar isObject = _util.isObject;\nvar isArrayLike = _util.isArrayLike;\nvar indexOf = _util.indexOf;\n\n/**\n * @alias modue:zrender/mixin/Animatable\n * @constructor\n */\nvar Animatable = function () {\n  /**\n   * @type {Array.<module:zrender/animation/Animator>}\n   * @readOnly\n   */\n  this.animators = [];\n};\n\nAnimatable.prototype = {\n  constructor: Animatable,\n\n  /**\n   * 动画\n   *\n   * @param {string} path The path to fetch value from object, like 'a.b.c'.\n   * @param {boolean} [loop] Whether to loop animation.\n   * @return {module:zrender/animation/Animator}\n   * @example:\n   *     el.animate('style', false)\n   *         .when(1000, {x: 10} )\n   *         .done(function(){ // Animation done })\n   *         .start()\n   */\n  animate: function (path, loop) {\n    var target;\n    var animatingShape = false;\n    var el = this;\n    var zr = this.__zr;\n\n    if (path) {\n      var pathSplitted = path.split('.');\n      var prop = el; // If animating shape\n\n      animatingShape = pathSplitted[0] === 'shape';\n\n      for (var i = 0, l = pathSplitted.length; i < l; i++) {\n        if (!prop) {\n          continue;\n        }\n\n        prop = prop[pathSplitted[i]];\n      }\n\n      if (prop) {\n        target = prop;\n      }\n    } else {\n      target = el;\n    }\n\n    if (!target) {\n      log('Property \"' + path + '\" is not existed in element ' + el.id);\n      return;\n    }\n\n    var animators = el.animators;\n    var animator = new Animator(target, loop);\n    animator.during(function (target) {\n      el.dirty(animatingShape);\n    }).done(function () {\n      // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n      animators.splice(indexOf(animators, animator), 1);\n    });\n    animators.push(animator); // If animate after added to the zrender\n\n    if (zr) {\n      zr.animation.addAnimator(animator);\n    }\n\n    return animator;\n  },\n\n  /**\n   * 停止动画\n   * @param {boolean} forwardToLast If move to last frame before stop\n   */\n  stopAnimation: function (forwardToLast) {\n    var animators = this.animators;\n    var len = animators.length;\n\n    for (var i = 0; i < len; i++) {\n      animators[i].stop(forwardToLast);\n    }\n\n    animators.length = 0;\n    return this;\n  },\n\n  /**\n   * Caution: this method will stop previous animation.\n   * So do not use this method to one element twice before\n   * animation starts, unless you know what you are doing.\n   * @param {Object} target\n   * @param {number} [time=500] Time in ms\n   * @param {string} [easing='linear']\n   * @param {number} [delay=0]\n   * @param {Function} [callback]\n   * @param {Function} [forceAnimate] Prevent stop animation and callback\n   *        immediently when target values are the same as current values.\n   *\n   * @example\n   *  // Animate position\n   *  el.animateTo({\n   *      position: [10, 10]\n   *  }, function () { // done })\n   *\n   *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n   *  el.animateTo({\n   *      shape: {\n   *          width: 500\n   *      },\n   *      style: {\n   *          fill: 'red'\n   *      }\n   *      position: [10, 10]\n   *  }, 100, 100, 'cubicOut', function () { // done })\n   */\n  // TODO Return animation key\n  animateTo: function (target, time, delay, easing, callback, forceAnimate) {\n    // animateTo(target, time, easing, callback);\n    if (isString(delay)) {\n      callback = easing;\n      easing = delay;\n      delay = 0;\n    } // animateTo(target, time, delay, callback);\n    else if (isFunction(easing)) {\n        callback = easing;\n        easing = 'linear';\n        delay = 0;\n      } // animateTo(target, time, callback);\n      else if (isFunction(delay)) {\n          callback = delay;\n          delay = 0;\n        } // animateTo(target, callback)\n        else if (isFunction(time)) {\n            callback = time;\n            time = 500;\n          } // animateTo(target)\n          else if (!time) {\n              time = 500;\n            } // Stop all previous animations\n\n\n    this.stopAnimation();\n\n    this._animateToShallow('', this, target, time, delay); // Animators may be removed immediately after start\n    // if there is nothing to animate\n\n\n    var animators = this.animators.slice();\n    var count = animators.length;\n\n    function done() {\n      count--;\n\n      if (!count) {\n        callback && callback();\n      }\n    } // No animators. This should be checked before animators[i].start(),\n    // because 'done' may be executed immediately if no need to animate.\n\n\n    if (!count) {\n      callback && callback();\n    } // Start after all animators created\n    // Incase any animator is done immediately when all animation properties are not changed\n\n\n    for (var i = 0; i < animators.length; i++) {\n      animators[i].done(done).start(easing, forceAnimate);\n    }\n  },\n\n  /**\n   * @private\n   * @param {string} path=''\n   * @param {Object} source=this\n   * @param {Object} target\n   * @param {number} [time=500]\n   * @param {number} [delay=0]\n   *\n   * @example\n   *  // Animate position\n   *  el._animateToShallow({\n   *      position: [10, 10]\n   *  })\n   *\n   *  // Animate shape, style and position in 100ms, delayed 100ms\n   *  el._animateToShallow({\n   *      shape: {\n   *          width: 500\n   *      },\n   *      style: {\n   *          fill: 'red'\n   *      }\n   *      position: [10, 10]\n   *  }, 100, 100)\n   */\n  _animateToShallow: function (path, source, target, time, delay) {\n    var objShallow = {};\n    var propertyCount = 0;\n\n    for (var name in target) {\n      if (!target.hasOwnProperty(name)) {\n        continue;\n      }\n\n      if (source[name] != null) {\n        if (isObject(target[name]) && !isArrayLike(target[name])) {\n          this._animateToShallow(path ? path + '.' + name : name, source[name], target[name], time, delay);\n        } else {\n          objShallow[name] = target[name];\n          propertyCount++;\n        }\n      } else if (target[name] != null) {\n        // Attr directly if not has property\n        // FIXME, if some property not needed for element ?\n        if (!path) {\n          this.attr(name, target[name]);\n        } else {\n          // Shape or style\n          var props = {};\n          props[path] = {};\n          props[path][name] = target[name];\n          this.attr(props);\n        }\n      }\n    }\n\n    if (propertyCount > 0) {\n      this.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);\n    }\n\n    return this;\n  }\n};\nvar _default = Animatable;\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}