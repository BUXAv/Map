{"ast":null,"code":"require(\"core-js/modules/es.error.cause.js\");\n\nvar _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar _model = require(\"../../util/model\");\n\nvar makeInner = _model.makeInner;\nvar getDataItemValue = _model.getDataItemValue;\n\nvar _referHelper = require(\"../../model/referHelper\");\n\nvar getCoordSysDefineBySeries = _referHelper.getCoordSysDefineBySeries;\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar createHashMap = _util.createHashMap;\nvar each = _util.each;\nvar map = _util.map;\nvar isArray = _util.isArray;\nvar isString = _util.isString;\nvar isObject = _util.isObject;\nvar isTypedArray = _util.isTypedArray;\nvar isArrayLike = _util.isArrayLike;\nvar extend = _util.extend;\nvar assert = _util.assert;\n\nvar Source = require(\"../Source\");\n\nvar _sourceType = require(\"./sourceType\");\n\nvar SOURCE_FORMAT_ORIGINAL = _sourceType.SOURCE_FORMAT_ORIGINAL;\nvar SOURCE_FORMAT_ARRAY_ROWS = _sourceType.SOURCE_FORMAT_ARRAY_ROWS;\nvar SOURCE_FORMAT_OBJECT_ROWS = _sourceType.SOURCE_FORMAT_OBJECT_ROWS;\nvar SOURCE_FORMAT_KEYED_COLUMNS = _sourceType.SOURCE_FORMAT_KEYED_COLUMNS;\nvar SOURCE_FORMAT_UNKNOWN = _sourceType.SOURCE_FORMAT_UNKNOWN;\nvar SOURCE_FORMAT_TYPED_ARRAY = _sourceType.SOURCE_FORMAT_TYPED_ARRAY;\nvar SERIES_LAYOUT_BY_ROW = _sourceType.SERIES_LAYOUT_BY_ROW;\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar inner = makeInner();\n/**\n * @see {module:echarts/data/Source}\n * @param {module:echarts/component/dataset/DatasetModel} datasetModel\n * @return {string} sourceFormat\n */\n\nfunction detectSourceFormat(datasetModel) {\n  var data = datasetModel.option.source;\n  var sourceFormat = SOURCE_FORMAT_UNKNOWN;\n\n  if (isTypedArray(data)) {\n    sourceFormat = SOURCE_FORMAT_TYPED_ARRAY;\n  } else if (isArray(data)) {\n    // FIXME Whether tolerate null in top level array?\n    for (var i = 0, len = data.length; i < len; i++) {\n      var item = data[i];\n\n      if (item == null) {\n        continue;\n      } else if (isArray(item)) {\n        sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;\n        break;\n      } else if (isObject(item)) {\n        sourceFormat = SOURCE_FORMAT_OBJECT_ROWS;\n        break;\n      }\n    }\n  } else if (isObject(data)) {\n    for (var key in data) {\n      if (data.hasOwnProperty(key) && isArrayLike(data[key])) {\n        sourceFormat = SOURCE_FORMAT_KEYED_COLUMNS;\n        break;\n      }\n    }\n  } else if (data != null) {\n    throw new Error('Invalid data');\n  }\n\n  inner(datasetModel).sourceFormat = sourceFormat;\n}\n/**\n * [Scenarios]:\n * (1) Provide source data directly:\n *     series: {\n *         encode: {...},\n *         dimensions: [...]\n *         seriesLayoutBy: 'row',\n *         data: [[...]]\n *     }\n * (2) Refer to datasetModel.\n *     series: [{\n *         encode: {...}\n *         // Ignore datasetIndex means `datasetIndex: 0`\n *         // and the dimensions defination in dataset is used\n *     }, {\n *         encode: {...},\n *         seriesLayoutBy: 'column',\n *         datasetIndex: 1\n *     }]\n *\n * Get data from series itself or datset.\n * @return {module:echarts/data/Source} source\n */\n\n\nfunction getSource(seriesModel) {\n  return inner(seriesModel).source;\n}\n/**\n * MUST be called before mergeOption of all series.\n * @param {module:echarts/model/Global} ecModel\n */\n\n\nfunction resetSourceDefaulter(ecModel) {\n  // `datasetMap` is used to make default encode.\n  inner(ecModel).datasetMap = createHashMap();\n}\n/**\n * [Caution]:\n * MUST be called after series option merged and\n * before \"series.getInitailData()\" called.\n *\n * [The rule of making default encode]:\n * Category axis (if exists) alway map to the first dimension.\n * Each other axis occupies a subsequent dimension.\n *\n * [Why make default encode]:\n * Simplify the typing of encode in option, avoiding the case like that:\n * series: [{encode: {x: 0, y: 1}}, {encode: {x: 0, y: 2}}, {encode: {x: 0, y: 3}}],\n * where the \"y\" have to be manually typed as \"1, 2, 3, ...\".\n *\n * @param {module:echarts/model/Series} seriesModel\n */\n\n\nfunction prepareSource(seriesModel) {\n  var seriesOption = seriesModel.option;\n  var data = seriesOption.data;\n  var sourceFormat = isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL;\n  var fromDataset = false;\n  var seriesLayoutBy = seriesOption.seriesLayoutBy;\n  var sourceHeader = seriesOption.sourceHeader;\n  var dimensionsDefine = seriesOption.dimensions;\n  var datasetModel = getDatasetModel(seriesModel);\n\n  if (datasetModel) {\n    var datasetOption = datasetModel.option;\n    data = datasetOption.source;\n    sourceFormat = inner(datasetModel).sourceFormat;\n    fromDataset = true; // These settings from series has higher priority.\n\n    seriesLayoutBy = seriesLayoutBy || datasetOption.seriesLayoutBy;\n    sourceHeader == null && (sourceHeader = datasetOption.sourceHeader);\n    dimensionsDefine = dimensionsDefine || datasetOption.dimensions;\n  }\n\n  var completeResult = completeBySourceData(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine); // Note: dataset option does not have `encode`.\n\n  var encodeDefine = seriesOption.encode;\n\n  if (!encodeDefine && datasetModel) {\n    encodeDefine = makeDefaultEncode(seriesModel, datasetModel, data, sourceFormat, seriesLayoutBy, completeResult);\n  }\n\n  inner(seriesModel).source = new Source({\n    data: data,\n    fromDataset: fromDataset,\n    seriesLayoutBy: seriesLayoutBy,\n    sourceFormat: sourceFormat,\n    dimensionsDefine: completeResult.dimensionsDefine,\n    startIndex: completeResult.startIndex,\n    dimensionsDetectCount: completeResult.dimensionsDetectCount,\n    encodeDefine: encodeDefine\n  });\n} // return {startIndex, dimensionsDefine, dimensionsCount}\n\n\nfunction completeBySourceData(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine) {\n  if (!data) {\n    return {\n      dimensionsDefine: normalizeDimensionsDefine(dimensionsDefine)\n    };\n  }\n\n  var dimensionsDetectCount;\n  var startIndex;\n  var findPotentialName;\n\n  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {\n    // Rule: Most of the first line are string: it is header.\n    // Caution: consider a line with 5 string and 1 number,\n    // it still can not be sure it is a head, because the\n    // 5 string may be 5 values of category columns.\n    if (sourceHeader === 'auto' || sourceHeader == null) {\n      arrayRowsTravelFirst(function (val) {\n        // '-' is regarded as null/undefined.\n        if (val != null && val !== '-') {\n          if (isString(val)) {\n            startIndex == null && (startIndex = 1);\n          } else {\n            startIndex = 0;\n          }\n        } // 10 is an experience number, avoid long loop.\n\n      }, seriesLayoutBy, data, 10);\n    } else {\n      startIndex = sourceHeader ? 1 : 0;\n    }\n\n    if (!dimensionsDefine && startIndex === 1) {\n      dimensionsDefine = [];\n      arrayRowsTravelFirst(function (val, index) {\n        dimensionsDefine[index] = val != null ? val : '';\n      }, seriesLayoutBy, data);\n    }\n\n    dimensionsDetectCount = dimensionsDefine ? dimensionsDefine.length : seriesLayoutBy === SERIES_LAYOUT_BY_ROW ? data.length : data[0] ? data[0].length : null;\n  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {\n    if (!dimensionsDefine) {\n      dimensionsDefine = objectRowsCollectDimensions(data);\n      findPotentialName = true;\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {\n    if (!dimensionsDefine) {\n      dimensionsDefine = [];\n      findPotentialName = true;\n      each(data, function (colArr, key) {\n        dimensionsDefine.push(key);\n      });\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {\n    var value0 = getDataItemValue(data[0]);\n    dimensionsDetectCount = isArray(value0) && value0.length || 1;\n  } else if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {}\n\n  var potentialNameDimIndex;\n\n  if (findPotentialName) {\n    each(dimensionsDefine, function (dim, idx) {\n      if ((isObject(dim) ? dim.name : dim) === 'name') {\n        potentialNameDimIndex = idx;\n      }\n    });\n  }\n\n  return {\n    startIndex: startIndex,\n    dimensionsDefine: normalizeDimensionsDefine(dimensionsDefine),\n    dimensionsDetectCount: dimensionsDetectCount,\n    potentialNameDimIndex: potentialNameDimIndex // TODO: potentialIdDimIdx\n\n  };\n} // Consider dimensions defined like ['A', 'price', 'B', 'price', 'C', 'price'],\n// which is reasonable. But dimension name is duplicated.\n// Returns undefined or an array contains only object without null/undefiend or string.\n\n\nfunction normalizeDimensionsDefine(dimensionsDefine) {\n  if (!dimensionsDefine) {\n    // The meaning of null/undefined is different from empty array.\n    return;\n  }\n\n  var nameMap = createHashMap();\n  return map(dimensionsDefine, function (item, index) {\n    item = extend({}, isObject(item) ? item : {\n      name: item\n    }); // User can set null in dimensions.\n    // We dont auto specify name, othewise a given name may\n    // cause it be refered unexpectedly.\n\n    if (item.name == null) {\n      return item;\n    } // Also consider number form like 2012.\n\n\n    item.name += ''; // User may also specify displayName.\n    // displayName will always exists except user not\n    // specified or dim name is not specified or detected.\n    // (A auto generated dim name will not be used as\n    // displayName).\n\n    if (item.displayName == null) {\n      item.displayName = item.name;\n    }\n\n    var exist = nameMap.get(item.name);\n\n    if (!exist) {\n      nameMap.set(item.name, {\n        count: 1\n      });\n    } else {\n      item.name += '-' + exist.count++;\n    }\n\n    return item;\n  });\n}\n\nfunction arrayRowsTravelFirst(cb, seriesLayoutBy, data, maxLoop) {\n  maxLoop == null && (maxLoop = Infinity);\n\n  if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {\n    for (var i = 0; i < data.length && i < maxLoop; i++) {\n      cb(data[i] ? data[i][0] : null, i);\n    }\n  } else {\n    var value0 = data[0] || [];\n\n    for (var i = 0; i < value0.length && i < maxLoop; i++) {\n      cb(value0[i], i);\n    }\n  }\n}\n\nfunction objectRowsCollectDimensions(data) {\n  var firstIndex = 0;\n  var obj;\n\n  while (firstIndex < data.length && !(obj = data[firstIndex++])) {} // jshint ignore: line\n\n\n  if (obj) {\n    var dimensions = [];\n    each(obj, function (value, key) {\n      dimensions.push(key);\n    });\n    return dimensions;\n  }\n} // ??? TODO merge to completedimensions, where also has\n// default encode making logic. And the default rule\n// should depends on series? consider 'map'.\n\n\nfunction makeDefaultEncode(seriesModel, datasetModel, data, sourceFormat, seriesLayoutBy, completeResult) {\n  var coordSysDefine = getCoordSysDefineBySeries(seriesModel);\n  var encode = {}; // var encodeTooltip = [];\n  // var encodeLabel = [];\n\n  var encodeItemName = [];\n  var encodeSeriesName = [];\n  var seriesType = seriesModel.subType; // ??? TODO refactor: provide by series itself.\n  // Consider the case: 'map' series is based on geo coordSys,\n  // 'graph', 'heatmap' can be based on cartesian. But can not\n  // give default rule simply here.\n\n  var nSeriesMap = createHashMap(['pie', 'map', 'funnel']);\n  var cSeriesMap = createHashMap(['line', 'bar', 'pictorialBar', 'scatter', 'effectScatter', 'candlestick', 'boxplot']); // Usually in this case series will use the first data\n  // dimension as the \"value\" dimension, or other default\n  // processes respectively.\n\n  if (coordSysDefine && cSeriesMap.get(seriesType) != null) {\n    var ecModel = seriesModel.ecModel;\n    var datasetMap = inner(ecModel).datasetMap;\n    var key = datasetModel.uid + '_' + seriesLayoutBy;\n    var datasetRecord = datasetMap.get(key) || datasetMap.set(key, {\n      categoryWayDim: 1,\n      valueWayDim: 0\n    }); // TODO\n    // Auto detect first time axis and do arrangement.\n\n    each(coordSysDefine.coordSysDims, function (coordDim) {\n      // In value way.\n      if (coordSysDefine.firstCategoryDimIndex == null) {\n        var dataDim = datasetRecord.valueWayDim++;\n        encode[coordDim] = dataDim; // ??? TODO give a better default series name rule?\n        // especially when encode x y specified.\n        // consider: when mutiple series share one dimension\n        // category axis, series name should better use\n        // the other dimsion name. On the other hand, use\n        // both dimensions name.\n\n        encodeSeriesName.push(dataDim); // encodeTooltip.push(dataDim);\n        // encodeLabel.push(dataDim);\n      } // In category way, category axis.\n      else if (coordSysDefine.categoryAxisMap.get(coordDim)) {\n        encode[coordDim] = 0;\n        encodeItemName.push(0);\n      } // In category way, non-category axis.\n      else {\n        var dataDim = datasetRecord.categoryWayDim++;\n        encode[coordDim] = dataDim; // encodeTooltip.push(dataDim);\n        // encodeLabel.push(dataDim);\n\n        encodeSeriesName.push(dataDim);\n      }\n    });\n  } // Do not make a complex rule! Hard to code maintain and not necessary.\n  // ??? TODO refactor: provide by series itself.\n  // [{name: ..., value: ...}, ...] like:\n  else if (nSeriesMap.get(seriesType) != null) {\n    // Find the first not ordinal. (5 is an experience value)\n    var firstNotOrdinal;\n\n    for (var i = 0; i < 5 && firstNotOrdinal == null; i++) {\n      if (!doGuessOrdinal(data, sourceFormat, seriesLayoutBy, completeResult.dimensionsDefine, completeResult.startIndex, i)) {\n        firstNotOrdinal = i;\n      }\n    }\n\n    if (firstNotOrdinal != null) {\n      encode.value = firstNotOrdinal;\n      var nameDimIndex = completeResult.potentialNameDimIndex || Math.max(firstNotOrdinal - 1, 0); // By default, label use itemName in charts.\n      // So we dont set encodeLabel here.\n\n      encodeSeriesName.push(nameDimIndex);\n      encodeItemName.push(nameDimIndex); // encodeTooltip.push(firstNotOrdinal);\n    }\n  } // encodeTooltip.length && (encode.tooltip = encodeTooltip);\n  // encodeLabel.length && (encode.label = encodeLabel);\n\n\n  encodeItemName.length && (encode.itemName = encodeItemName);\n  encodeSeriesName.length && (encode.seriesName = encodeSeriesName);\n  return encode;\n}\n/**\n * If return null/undefined, indicate that should not use datasetModel.\n */\n\n\nfunction getDatasetModel(seriesModel) {\n  var option = seriesModel.option; // Caution: consider the scenario:\n  // A dataset is declared and a series is not expected to use the dataset,\n  // and at the beginning `setOption({series: { noData })` (just prepare other\n  // option but no data), then `setOption({series: {data: [...]}); In this case,\n  // the user should set an empty array to avoid that dataset is used by default.\n\n  var thisData = option.data;\n\n  if (!thisData) {\n    return seriesModel.ecModel.getComponent('dataset', option.datasetIndex || 0);\n  }\n}\n/**\n * The rule should not be complex, otherwise user might not\n * be able to known where the data is wrong.\n * The code is ugly, but how to make it neat?\n *\n * @param {module:echars/data/Source} source\n * @param {number} dimIndex\n * @return {boolean} Whether ordinal.\n */\n\n\nfunction guessOrdinal(source, dimIndex) {\n  return doGuessOrdinal(source.data, source.sourceFormat, source.seriesLayoutBy, source.dimensionsDefine, source.startIndex, dimIndex);\n} // dimIndex may be overflow source data.\n\n\nfunction doGuessOrdinal(data, sourceFormat, seriesLayoutBy, dimensionsDefine, startIndex, dimIndex) {\n  var result; // Experience value.\n\n  var maxLoop = 5;\n\n  if (isTypedArray(data)) {\n    return false;\n  } // When sourceType is 'objectRows' or 'keyedColumns', dimensionsDefine\n  // always exists in source.\n\n\n  var dimName;\n\n  if (dimensionsDefine) {\n    dimName = dimensionsDefine[dimIndex];\n    dimName = isObject(dimName) ? dimName.name : dimName;\n  }\n\n  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {\n    if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {\n      var sample = data[dimIndex];\n\n      for (var i = 0; i < (sample || []).length && i < maxLoop; i++) {\n        if ((result = detectValue(sample[startIndex + i])) != null) {\n          return result;\n        }\n      }\n    } else {\n      for (var i = 0; i < data.length && i < maxLoop; i++) {\n        var row = data[startIndex + i];\n\n        if (row && (result = detectValue(row[dimIndex])) != null) {\n          return result;\n        }\n      }\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {\n    if (!dimName) {\n      return;\n    }\n\n    for (var i = 0; i < data.length && i < maxLoop; i++) {\n      var item = data[i];\n\n      if (item && (result = detectValue(item[dimName])) != null) {\n        return result;\n      }\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {\n    if (!dimName) {\n      return;\n    }\n\n    var sample = data[dimName];\n\n    if (!sample || isTypedArray(sample)) {\n      return false;\n    }\n\n    for (var i = 0; i < sample.length && i < maxLoop; i++) {\n      if ((result = detectValue(sample[i])) != null) {\n        return result;\n      }\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {\n    for (var i = 0; i < data.length && i < maxLoop; i++) {\n      var item = data[i];\n      var val = getDataItemValue(item);\n\n      if (!isArray(val)) {\n        return false;\n      }\n\n      if ((result = detectValue(val[dimIndex])) != null) {\n        return result;\n      }\n    }\n  }\n\n  function detectValue(val) {\n    // Consider usage convenience, '1', '2' will be treated as \"number\".\n    // `isFinit('')` get `true`.\n    if (val != null && isFinite(val) && val !== '') {\n      return false;\n    } else if (isString(val) && val !== '-') {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexports.detectSourceFormat = detectSourceFormat;\nexports.getSource = getSource;\nexports.resetSourceDefaulter = resetSourceDefaulter;\nexports.prepareSource = prepareSource;\nexports.guessOrdinal = guessOrdinal;","map":{"version":3,"names":["_config","require","__DEV__","_model","makeInner","getDataItemValue","_referHelper","getCoordSysDefineBySeries","_util","createHashMap","each","map","isArray","isString","isObject","isTypedArray","isArrayLike","extend","assert","Source","_sourceType","SOURCE_FORMAT_ORIGINAL","SOURCE_FORMAT_ARRAY_ROWS","SOURCE_FORMAT_OBJECT_ROWS","SOURCE_FORMAT_KEYED_COLUMNS","SOURCE_FORMAT_UNKNOWN","SOURCE_FORMAT_TYPED_ARRAY","SERIES_LAYOUT_BY_ROW","inner","detectSourceFormat","datasetModel","data","option","source","sourceFormat","i","len","length","item","key","hasOwnProperty","Error","getSource","seriesModel","resetSourceDefaulter","ecModel","datasetMap","prepareSource","seriesOption","fromDataset","seriesLayoutBy","sourceHeader","dimensionsDefine","dimensions","getDatasetModel","datasetOption","completeResult","completeBySourceData","encodeDefine","encode","makeDefaultEncode","startIndex","dimensionsDetectCount","normalizeDimensionsDefine","findPotentialName","arrayRowsTravelFirst","val","index","objectRowsCollectDimensions","colArr","push","value0","potentialNameDimIndex","dim","idx","name","nameMap","displayName","exist","get","set","count","cb","maxLoop","Infinity","firstIndex","obj","value","coordSysDefine","encodeItemName","encodeSeriesName","seriesType","subType","nSeriesMap","cSeriesMap","uid","datasetRecord","categoryWayDim","valueWayDim","coordSysDims","coordDim","firstCategoryDimIndex","dataDim","categoryAxisMap","firstNotOrdinal","doGuessOrdinal","nameDimIndex","Math","max","itemName","seriesName","thisData","getComponent","datasetIndex","guessOrdinal","dimIndex","result","dimName","sample","detectValue","row","isFinite","exports"],"sources":["C:/Users/W/Desktop/vue_map/node_modules/echarts/lib/data/helper/sourceHelper.js"],"sourcesContent":["var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar _model = require(\"../../util/model\");\n\nvar makeInner = _model.makeInner;\nvar getDataItemValue = _model.getDataItemValue;\n\nvar _referHelper = require(\"../../model/referHelper\");\n\nvar getCoordSysDefineBySeries = _referHelper.getCoordSysDefineBySeries;\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar createHashMap = _util.createHashMap;\nvar each = _util.each;\nvar map = _util.map;\nvar isArray = _util.isArray;\nvar isString = _util.isString;\nvar isObject = _util.isObject;\nvar isTypedArray = _util.isTypedArray;\nvar isArrayLike = _util.isArrayLike;\nvar extend = _util.extend;\nvar assert = _util.assert;\n\nvar Source = require(\"../Source\");\n\nvar _sourceType = require(\"./sourceType\");\n\nvar SOURCE_FORMAT_ORIGINAL = _sourceType.SOURCE_FORMAT_ORIGINAL;\nvar SOURCE_FORMAT_ARRAY_ROWS = _sourceType.SOURCE_FORMAT_ARRAY_ROWS;\nvar SOURCE_FORMAT_OBJECT_ROWS = _sourceType.SOURCE_FORMAT_OBJECT_ROWS;\nvar SOURCE_FORMAT_KEYED_COLUMNS = _sourceType.SOURCE_FORMAT_KEYED_COLUMNS;\nvar SOURCE_FORMAT_UNKNOWN = _sourceType.SOURCE_FORMAT_UNKNOWN;\nvar SOURCE_FORMAT_TYPED_ARRAY = _sourceType.SOURCE_FORMAT_TYPED_ARRAY;\nvar SERIES_LAYOUT_BY_ROW = _sourceType.SERIES_LAYOUT_BY_ROW;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar inner = makeInner();\n/**\n * @see {module:echarts/data/Source}\n * @param {module:echarts/component/dataset/DatasetModel} datasetModel\n * @return {string} sourceFormat\n */\n\nfunction detectSourceFormat(datasetModel) {\n  var data = datasetModel.option.source;\n  var sourceFormat = SOURCE_FORMAT_UNKNOWN;\n\n  if (isTypedArray(data)) {\n    sourceFormat = SOURCE_FORMAT_TYPED_ARRAY;\n  } else if (isArray(data)) {\n    // FIXME Whether tolerate null in top level array?\n    for (var i = 0, len = data.length; i < len; i++) {\n      var item = data[i];\n\n      if (item == null) {\n        continue;\n      } else if (isArray(item)) {\n        sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;\n        break;\n      } else if (isObject(item)) {\n        sourceFormat = SOURCE_FORMAT_OBJECT_ROWS;\n        break;\n      }\n    }\n  } else if (isObject(data)) {\n    for (var key in data) {\n      if (data.hasOwnProperty(key) && isArrayLike(data[key])) {\n        sourceFormat = SOURCE_FORMAT_KEYED_COLUMNS;\n        break;\n      }\n    }\n  } else if (data != null) {\n    throw new Error('Invalid data');\n  }\n\n  inner(datasetModel).sourceFormat = sourceFormat;\n}\n/**\n * [Scenarios]:\n * (1) Provide source data directly:\n *     series: {\n *         encode: {...},\n *         dimensions: [...]\n *         seriesLayoutBy: 'row',\n *         data: [[...]]\n *     }\n * (2) Refer to datasetModel.\n *     series: [{\n *         encode: {...}\n *         // Ignore datasetIndex means `datasetIndex: 0`\n *         // and the dimensions defination in dataset is used\n *     }, {\n *         encode: {...},\n *         seriesLayoutBy: 'column',\n *         datasetIndex: 1\n *     }]\n *\n * Get data from series itself or datset.\n * @return {module:echarts/data/Source} source\n */\n\n\nfunction getSource(seriesModel) {\n  return inner(seriesModel).source;\n}\n/**\n * MUST be called before mergeOption of all series.\n * @param {module:echarts/model/Global} ecModel\n */\n\n\nfunction resetSourceDefaulter(ecModel) {\n  // `datasetMap` is used to make default encode.\n  inner(ecModel).datasetMap = createHashMap();\n}\n/**\n * [Caution]:\n * MUST be called after series option merged and\n * before \"series.getInitailData()\" called.\n *\n * [The rule of making default encode]:\n * Category axis (if exists) alway map to the first dimension.\n * Each other axis occupies a subsequent dimension.\n *\n * [Why make default encode]:\n * Simplify the typing of encode in option, avoiding the case like that:\n * series: [{encode: {x: 0, y: 1}}, {encode: {x: 0, y: 2}}, {encode: {x: 0, y: 3}}],\n * where the \"y\" have to be manually typed as \"1, 2, 3, ...\".\n *\n * @param {module:echarts/model/Series} seriesModel\n */\n\n\nfunction prepareSource(seriesModel) {\n  var seriesOption = seriesModel.option;\n  var data = seriesOption.data;\n  var sourceFormat = isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL;\n  var fromDataset = false;\n  var seriesLayoutBy = seriesOption.seriesLayoutBy;\n  var sourceHeader = seriesOption.sourceHeader;\n  var dimensionsDefine = seriesOption.dimensions;\n  var datasetModel = getDatasetModel(seriesModel);\n\n  if (datasetModel) {\n    var datasetOption = datasetModel.option;\n    data = datasetOption.source;\n    sourceFormat = inner(datasetModel).sourceFormat;\n    fromDataset = true; // These settings from series has higher priority.\n\n    seriesLayoutBy = seriesLayoutBy || datasetOption.seriesLayoutBy;\n    sourceHeader == null && (sourceHeader = datasetOption.sourceHeader);\n    dimensionsDefine = dimensionsDefine || datasetOption.dimensions;\n  }\n\n  var completeResult = completeBySourceData(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine); // Note: dataset option does not have `encode`.\n\n  var encodeDefine = seriesOption.encode;\n\n  if (!encodeDefine && datasetModel) {\n    encodeDefine = makeDefaultEncode(seriesModel, datasetModel, data, sourceFormat, seriesLayoutBy, completeResult);\n  }\n\n  inner(seriesModel).source = new Source({\n    data: data,\n    fromDataset: fromDataset,\n    seriesLayoutBy: seriesLayoutBy,\n    sourceFormat: sourceFormat,\n    dimensionsDefine: completeResult.dimensionsDefine,\n    startIndex: completeResult.startIndex,\n    dimensionsDetectCount: completeResult.dimensionsDetectCount,\n    encodeDefine: encodeDefine\n  });\n} // return {startIndex, dimensionsDefine, dimensionsCount}\n\n\nfunction completeBySourceData(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine) {\n  if (!data) {\n    return {\n      dimensionsDefine: normalizeDimensionsDefine(dimensionsDefine)\n    };\n  }\n\n  var dimensionsDetectCount;\n  var startIndex;\n  var findPotentialName;\n\n  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {\n    // Rule: Most of the first line are string: it is header.\n    // Caution: consider a line with 5 string and 1 number,\n    // it still can not be sure it is a head, because the\n    // 5 string may be 5 values of category columns.\n    if (sourceHeader === 'auto' || sourceHeader == null) {\n      arrayRowsTravelFirst(function (val) {\n        // '-' is regarded as null/undefined.\n        if (val != null && val !== '-') {\n          if (isString(val)) {\n            startIndex == null && (startIndex = 1);\n          } else {\n            startIndex = 0;\n          }\n        } // 10 is an experience number, avoid long loop.\n\n      }, seriesLayoutBy, data, 10);\n    } else {\n      startIndex = sourceHeader ? 1 : 0;\n    }\n\n    if (!dimensionsDefine && startIndex === 1) {\n      dimensionsDefine = [];\n      arrayRowsTravelFirst(function (val, index) {\n        dimensionsDefine[index] = val != null ? val : '';\n      }, seriesLayoutBy, data);\n    }\n\n    dimensionsDetectCount = dimensionsDefine ? dimensionsDefine.length : seriesLayoutBy === SERIES_LAYOUT_BY_ROW ? data.length : data[0] ? data[0].length : null;\n  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {\n    if (!dimensionsDefine) {\n      dimensionsDefine = objectRowsCollectDimensions(data);\n      findPotentialName = true;\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {\n    if (!dimensionsDefine) {\n      dimensionsDefine = [];\n      findPotentialName = true;\n      each(data, function (colArr, key) {\n        dimensionsDefine.push(key);\n      });\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {\n    var value0 = getDataItemValue(data[0]);\n    dimensionsDetectCount = isArray(value0) && value0.length || 1;\n  } else if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {}\n\n  var potentialNameDimIndex;\n\n  if (findPotentialName) {\n    each(dimensionsDefine, function (dim, idx) {\n      if ((isObject(dim) ? dim.name : dim) === 'name') {\n        potentialNameDimIndex = idx;\n      }\n    });\n  }\n\n  return {\n    startIndex: startIndex,\n    dimensionsDefine: normalizeDimensionsDefine(dimensionsDefine),\n    dimensionsDetectCount: dimensionsDetectCount,\n    potentialNameDimIndex: potentialNameDimIndex // TODO: potentialIdDimIdx\n\n  };\n} // Consider dimensions defined like ['A', 'price', 'B', 'price', 'C', 'price'],\n// which is reasonable. But dimension name is duplicated.\n// Returns undefined or an array contains only object without null/undefiend or string.\n\n\nfunction normalizeDimensionsDefine(dimensionsDefine) {\n  if (!dimensionsDefine) {\n    // The meaning of null/undefined is different from empty array.\n    return;\n  }\n\n  var nameMap = createHashMap();\n  return map(dimensionsDefine, function (item, index) {\n    item = extend({}, isObject(item) ? item : {\n      name: item\n    }); // User can set null in dimensions.\n    // We dont auto specify name, othewise a given name may\n    // cause it be refered unexpectedly.\n\n    if (item.name == null) {\n      return item;\n    } // Also consider number form like 2012.\n\n\n    item.name += ''; // User may also specify displayName.\n    // displayName will always exists except user not\n    // specified or dim name is not specified or detected.\n    // (A auto generated dim name will not be used as\n    // displayName).\n\n    if (item.displayName == null) {\n      item.displayName = item.name;\n    }\n\n    var exist = nameMap.get(item.name);\n\n    if (!exist) {\n      nameMap.set(item.name, {\n        count: 1\n      });\n    } else {\n      item.name += '-' + exist.count++;\n    }\n\n    return item;\n  });\n}\n\nfunction arrayRowsTravelFirst(cb, seriesLayoutBy, data, maxLoop) {\n  maxLoop == null && (maxLoop = Infinity);\n\n  if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {\n    for (var i = 0; i < data.length && i < maxLoop; i++) {\n      cb(data[i] ? data[i][0] : null, i);\n    }\n  } else {\n    var value0 = data[0] || [];\n\n    for (var i = 0; i < value0.length && i < maxLoop; i++) {\n      cb(value0[i], i);\n    }\n  }\n}\n\nfunction objectRowsCollectDimensions(data) {\n  var firstIndex = 0;\n  var obj;\n\n  while (firstIndex < data.length && !(obj = data[firstIndex++])) {} // jshint ignore: line\n\n\n  if (obj) {\n    var dimensions = [];\n    each(obj, function (value, key) {\n      dimensions.push(key);\n    });\n    return dimensions;\n  }\n} // ??? TODO merge to completedimensions, where also has\n// default encode making logic. And the default rule\n// should depends on series? consider 'map'.\n\n\nfunction makeDefaultEncode(seriesModel, datasetModel, data, sourceFormat, seriesLayoutBy, completeResult) {\n  var coordSysDefine = getCoordSysDefineBySeries(seriesModel);\n  var encode = {}; // var encodeTooltip = [];\n  // var encodeLabel = [];\n\n  var encodeItemName = [];\n  var encodeSeriesName = [];\n  var seriesType = seriesModel.subType; // ??? TODO refactor: provide by series itself.\n  // Consider the case: 'map' series is based on geo coordSys,\n  // 'graph', 'heatmap' can be based on cartesian. But can not\n  // give default rule simply here.\n\n  var nSeriesMap = createHashMap(['pie', 'map', 'funnel']);\n  var cSeriesMap = createHashMap(['line', 'bar', 'pictorialBar', 'scatter', 'effectScatter', 'candlestick', 'boxplot']); // Usually in this case series will use the first data\n  // dimension as the \"value\" dimension, or other default\n  // processes respectively.\n\n  if (coordSysDefine && cSeriesMap.get(seriesType) != null) {\n    var ecModel = seriesModel.ecModel;\n    var datasetMap = inner(ecModel).datasetMap;\n    var key = datasetModel.uid + '_' + seriesLayoutBy;\n    var datasetRecord = datasetMap.get(key) || datasetMap.set(key, {\n      categoryWayDim: 1,\n      valueWayDim: 0\n    }); // TODO\n    // Auto detect first time axis and do arrangement.\n\n    each(coordSysDefine.coordSysDims, function (coordDim) {\n      // In value way.\n      if (coordSysDefine.firstCategoryDimIndex == null) {\n        var dataDim = datasetRecord.valueWayDim++;\n        encode[coordDim] = dataDim; // ??? TODO give a better default series name rule?\n        // especially when encode x y specified.\n        // consider: when mutiple series share one dimension\n        // category axis, series name should better use\n        // the other dimsion name. On the other hand, use\n        // both dimensions name.\n\n        encodeSeriesName.push(dataDim); // encodeTooltip.push(dataDim);\n        // encodeLabel.push(dataDim);\n      } // In category way, category axis.\n      else if (coordSysDefine.categoryAxisMap.get(coordDim)) {\n          encode[coordDim] = 0;\n          encodeItemName.push(0);\n        } // In category way, non-category axis.\n        else {\n            var dataDim = datasetRecord.categoryWayDim++;\n            encode[coordDim] = dataDim; // encodeTooltip.push(dataDim);\n            // encodeLabel.push(dataDim);\n\n            encodeSeriesName.push(dataDim);\n          }\n    });\n  } // Do not make a complex rule! Hard to code maintain and not necessary.\n  // ??? TODO refactor: provide by series itself.\n  // [{name: ..., value: ...}, ...] like:\n  else if (nSeriesMap.get(seriesType) != null) {\n      // Find the first not ordinal. (5 is an experience value)\n      var firstNotOrdinal;\n\n      for (var i = 0; i < 5 && firstNotOrdinal == null; i++) {\n        if (!doGuessOrdinal(data, sourceFormat, seriesLayoutBy, completeResult.dimensionsDefine, completeResult.startIndex, i)) {\n          firstNotOrdinal = i;\n        }\n      }\n\n      if (firstNotOrdinal != null) {\n        encode.value = firstNotOrdinal;\n        var nameDimIndex = completeResult.potentialNameDimIndex || Math.max(firstNotOrdinal - 1, 0); // By default, label use itemName in charts.\n        // So we dont set encodeLabel here.\n\n        encodeSeriesName.push(nameDimIndex);\n        encodeItemName.push(nameDimIndex); // encodeTooltip.push(firstNotOrdinal);\n      }\n    } // encodeTooltip.length && (encode.tooltip = encodeTooltip);\n  // encodeLabel.length && (encode.label = encodeLabel);\n\n\n  encodeItemName.length && (encode.itemName = encodeItemName);\n  encodeSeriesName.length && (encode.seriesName = encodeSeriesName);\n  return encode;\n}\n/**\n * If return null/undefined, indicate that should not use datasetModel.\n */\n\n\nfunction getDatasetModel(seriesModel) {\n  var option = seriesModel.option; // Caution: consider the scenario:\n  // A dataset is declared and a series is not expected to use the dataset,\n  // and at the beginning `setOption({series: { noData })` (just prepare other\n  // option but no data), then `setOption({series: {data: [...]}); In this case,\n  // the user should set an empty array to avoid that dataset is used by default.\n\n  var thisData = option.data;\n\n  if (!thisData) {\n    return seriesModel.ecModel.getComponent('dataset', option.datasetIndex || 0);\n  }\n}\n/**\n * The rule should not be complex, otherwise user might not\n * be able to known where the data is wrong.\n * The code is ugly, but how to make it neat?\n *\n * @param {module:echars/data/Source} source\n * @param {number} dimIndex\n * @return {boolean} Whether ordinal.\n */\n\n\nfunction guessOrdinal(source, dimIndex) {\n  return doGuessOrdinal(source.data, source.sourceFormat, source.seriesLayoutBy, source.dimensionsDefine, source.startIndex, dimIndex);\n} // dimIndex may be overflow source data.\n\n\nfunction doGuessOrdinal(data, sourceFormat, seriesLayoutBy, dimensionsDefine, startIndex, dimIndex) {\n  var result; // Experience value.\n\n  var maxLoop = 5;\n\n  if (isTypedArray(data)) {\n    return false;\n  } // When sourceType is 'objectRows' or 'keyedColumns', dimensionsDefine\n  // always exists in source.\n\n\n  var dimName;\n\n  if (dimensionsDefine) {\n    dimName = dimensionsDefine[dimIndex];\n    dimName = isObject(dimName) ? dimName.name : dimName;\n  }\n\n  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {\n    if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {\n      var sample = data[dimIndex];\n\n      for (var i = 0; i < (sample || []).length && i < maxLoop; i++) {\n        if ((result = detectValue(sample[startIndex + i])) != null) {\n          return result;\n        }\n      }\n    } else {\n      for (var i = 0; i < data.length && i < maxLoop; i++) {\n        var row = data[startIndex + i];\n\n        if (row && (result = detectValue(row[dimIndex])) != null) {\n          return result;\n        }\n      }\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {\n    if (!dimName) {\n      return;\n    }\n\n    for (var i = 0; i < data.length && i < maxLoop; i++) {\n      var item = data[i];\n\n      if (item && (result = detectValue(item[dimName])) != null) {\n        return result;\n      }\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {\n    if (!dimName) {\n      return;\n    }\n\n    var sample = data[dimName];\n\n    if (!sample || isTypedArray(sample)) {\n      return false;\n    }\n\n    for (var i = 0; i < sample.length && i < maxLoop; i++) {\n      if ((result = detectValue(sample[i])) != null) {\n        return result;\n      }\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {\n    for (var i = 0; i < data.length && i < maxLoop; i++) {\n      var item = data[i];\n      var val = getDataItemValue(item);\n\n      if (!isArray(val)) {\n        return false;\n      }\n\n      if ((result = detectValue(val[dimIndex])) != null) {\n        return result;\n      }\n    }\n  }\n\n  function detectValue(val) {\n    // Consider usage convenience, '1', '2' will be treated as \"number\".\n    // `isFinit('')` get `true`.\n    if (val != null && isFinite(val) && val !== '') {\n      return false;\n    } else if (isString(val) && val !== '-') {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexports.detectSourceFormat = detectSourceFormat;\nexports.getSource = getSource;\nexports.resetSourceDefaulter = resetSourceDefaulter;\nexports.prepareSource = prepareSource;\nexports.guessOrdinal = guessOrdinal;"],"mappings":"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"},"metadata":{},"sourceType":"script"}