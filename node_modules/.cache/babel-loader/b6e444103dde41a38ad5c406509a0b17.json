{"ast":null,"code":"var _util = require(\"../../core/util\");\n\nvar retrieve2 = _util.retrieve2;\nvar retrieve3 = _util.retrieve3;\nvar each = _util.each;\nvar normalizeCssArray = _util.normalizeCssArray;\nvar isString = _util.isString;\nvar isObject = _util.isObject;\n\nvar textContain = require(\"../../contain/text\");\n\nvar roundRectHelper = require(\"./roundRect\");\n\nvar imageHelper = require(\"./image\");\n\nvar fixShadow = require(\"./fixShadow\"); // TODO: Have not support 'start', 'end' yet.\n\n\nvar VALID_TEXT_ALIGN = {\n  left: 1,\n  right: 1,\n  center: 1\n};\nvar VALID_TEXT_VERTICAL_ALIGN = {\n  top: 1,\n  bottom: 1,\n  middle: 1\n};\n/**\n * @param {module:zrender/graphic/Style} style\n * @return {module:zrender/graphic/Style} The input style.\n */\n\nfunction normalizeTextStyle(style) {\n  normalizeStyle(style);\n  each(style.rich, normalizeStyle);\n  return style;\n}\n\nfunction normalizeStyle(style) {\n  if (style) {\n    style.font = textContain.makeFont(style);\n    var textAlign = style.textAlign;\n    textAlign === 'middle' && (textAlign = 'center');\n    style.textAlign = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : 'left'; // Compatible with textBaseline.\n\n    var textVerticalAlign = style.textVerticalAlign || style.textBaseline;\n    textVerticalAlign === 'center' && (textVerticalAlign = 'middle');\n    style.textVerticalAlign = textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : 'top';\n    var textPadding = style.textPadding;\n\n    if (textPadding) {\n      style.textPadding = normalizeCssArray(style.textPadding);\n    }\n  }\n}\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {string} text\n * @param {module:zrender/graphic/Style} style\n * @param {Object|boolean} [rect] {x, y, width, height}\n *                  If set false, rect text is not used.\n */\n\n\nfunction renderText(hostEl, ctx, text, style, rect) {\n  style.rich ? renderRichText(hostEl, ctx, text, style, rect) : renderPlainText(hostEl, ctx, text, style, rect);\n}\n\nfunction renderPlainText(hostEl, ctx, text, style, rect) {\n  var font = setCtx(ctx, 'font', style.font || textContain.DEFAULT_FONT);\n  var textPadding = style.textPadding;\n  var contentBlock = hostEl.__textCotentBlock;\n\n  if (!contentBlock || hostEl.__dirty) {\n    contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(text, font, textPadding, style.truncate);\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var textLines = contentBlock.lines;\n  var lineHeight = contentBlock.lineHeight;\n  var boxPos = getBoxPosition(outerHeight, style, rect);\n  var baseX = boxPos.baseX;\n  var baseY = boxPos.baseY;\n  var textAlign = boxPos.textAlign;\n  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\n  applyTextRotation(ctx, style, rect, baseX, baseY);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var textX = baseX;\n  var textY = boxY;\n  var needDrawBg = needDrawBackground(style);\n\n  if (needDrawBg || textPadding) {\n    // Consider performance, do not call getTextWidth util necessary.\n    var textWidth = textContain.getWidth(text, font);\n    var outerWidth = textWidth;\n    textPadding && (outerWidth += textPadding[1] + textPadding[3]);\n    var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n    needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n    if (textPadding) {\n      textX = getTextXForPadding(baseX, textAlign, textPadding);\n      textY += textPadding[0];\n    }\n  }\n\n  setCtx(ctx, 'textAlign', textAlign || 'left'); // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\n  setCtx(ctx, 'textBaseline', 'middle'); // Always set shadowBlur and shadowOffset to avoid leak from displayable.\n\n  setCtx(ctx, 'shadowBlur', style.textShadowBlur || 0);\n  setCtx(ctx, 'shadowColor', style.textShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', style.textShadowOffsetX || 0);\n  setCtx(ctx, 'shadowOffsetY', style.textShadowOffsetY || 0); // `textBaseline` is set as 'middle'.\n\n  textY += lineHeight / 2;\n  var textStrokeWidth = style.textStrokeWidth;\n  var textStroke = getStroke(style.textStroke, textStrokeWidth);\n  var textFill = getFill(style.textFill);\n\n  if (textStroke) {\n    setCtx(ctx, 'lineWidth', textStrokeWidth);\n    setCtx(ctx, 'strokeStyle', textStroke);\n  }\n\n  if (textFill) {\n    setCtx(ctx, 'fillStyle', textFill);\n  }\n\n  for (var i = 0; i < textLines.length; i++) {\n    // Fill after stroke so the outline will not cover the main part.\n    textStroke && ctx.strokeText(textLines[i], textX, textY);\n    textFill && ctx.fillText(textLines[i], textX, textY);\n    textY += lineHeight;\n  }\n}\n\nfunction renderRichText(hostEl, ctx, text, style, rect) {\n  var contentBlock = hostEl.__textCotentBlock;\n\n  if (!contentBlock || hostEl.__dirty) {\n    contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style);\n  }\n\n  drawRichText(hostEl, ctx, contentBlock, style, rect);\n}\n\nfunction drawRichText(hostEl, ctx, contentBlock, style, rect) {\n  var contentWidth = contentBlock.width;\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var textPadding = style.textPadding;\n  var boxPos = getBoxPosition(outerHeight, style, rect);\n  var baseX = boxPos.baseX;\n  var baseY = boxPos.baseY;\n  var textAlign = boxPos.textAlign;\n  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\n  applyTextRotation(ctx, style, rect, baseX, baseY);\n  var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var xLeft = boxX;\n  var lineTop = boxY;\n\n  if (textPadding) {\n    xLeft += textPadding[3];\n    lineTop += textPadding[0];\n  }\n\n  var xRight = xLeft + contentWidth;\n  needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n  for (var i = 0; i < contentBlock.lines.length; i++) {\n    var line = contentBlock.lines[i];\n    var tokens = line.tokens;\n    var tokenCount = tokens.length;\n    var lineHeight = line.lineHeight;\n    var usedWidth = line.width;\n    var leftIndex = 0;\n    var lineXLeft = xLeft;\n    var lineXRight = xRight;\n    var rightIndex = tokenCount - 1;\n    var token;\n\n    while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')) {\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');\n      usedWidth -= token.width;\n      lineXLeft += token.width;\n      leftIndex++;\n    }\n\n    while (rightIndex >= 0 && (token = tokens[rightIndex], token.textAlign === 'right')) {\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');\n      usedWidth -= token.width;\n      lineXRight -= token.width;\n      rightIndex--;\n    } // The other tokens are placed as textAlign 'center' if there is enough space.\n\n\n    lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;\n\n    while (leftIndex <= rightIndex) {\n      token = tokens[leftIndex]; // Consider width specified by user, use 'center' rather than 'left'.\n\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');\n      lineXLeft += token.width;\n      leftIndex++;\n    }\n\n    lineTop += lineHeight;\n  }\n}\n\nfunction applyTextRotation(ctx, style, rect, x, y) {\n  // textRotation only apply in RectText.\n  if (rect && style.textRotation) {\n    var origin = style.textOrigin;\n\n    if (origin === 'center') {\n      x = rect.width / 2 + rect.x;\n      y = rect.height / 2 + rect.y;\n    } else if (origin) {\n      x = origin[0] + rect.x;\n      y = origin[1] + rect.y;\n    }\n\n    ctx.translate(x, y); // Positive: anticlockwise\n\n    ctx.rotate(-style.textRotation);\n    ctx.translate(-x, -y);\n  }\n}\n\nfunction placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {\n  var tokenStyle = style.rich[token.styleName] || {}; // 'ctx.textBaseline' is always set as 'middle', for sake of\n  // the bias of \"Microsoft YaHei\".\n\n  var textVerticalAlign = token.textVerticalAlign;\n  var y = lineTop + lineHeight / 2;\n\n  if (textVerticalAlign === 'top') {\n    y = lineTop + token.height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y = lineTop + lineHeight - token.height / 2;\n  }\n\n  !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, textAlign === 'right' ? x - token.width : textAlign === 'center' ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);\n  var textPadding = token.textPadding;\n\n  if (textPadding) {\n    x = getTextXForPadding(x, textAlign, textPadding);\n    y -= token.height / 2 - textPadding[2] - token.textHeight / 2;\n  }\n\n  setCtx(ctx, 'shadowBlur', retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));\n  setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));\n  setCtx(ctx, 'shadowOffsetY', retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));\n  setCtx(ctx, 'textAlign', textAlign); // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\n  setCtx(ctx, 'textBaseline', 'middle');\n  setCtx(ctx, 'font', token.font || textContain.DEFAULT_FONT);\n  var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);\n  var textFill = getFill(tokenStyle.textFill || style.textFill);\n  var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth); // Fill after stroke so the outline will not cover the main part.\n\n  if (textStroke) {\n    setCtx(ctx, 'lineWidth', textStrokeWidth);\n    setCtx(ctx, 'strokeStyle', textStroke);\n    ctx.strokeText(token.text, x, y);\n  }\n\n  if (textFill) {\n    setCtx(ctx, 'fillStyle', textFill);\n    ctx.fillText(token.text, x, y);\n  }\n}\n\nfunction needDrawBackground(style) {\n  return style.textBackgroundColor || style.textBorderWidth && style.textBorderColor;\n} // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius}\n// shape: {x, y, width, height}\n\n\nfunction drawBackground(hostEl, ctx, style, x, y, width, height) {\n  var textBackgroundColor = style.textBackgroundColor;\n  var textBorderWidth = style.textBorderWidth;\n  var textBorderColor = style.textBorderColor;\n  var isPlainBg = isString(textBackgroundColor);\n  setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);\n  setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);\n  setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);\n\n  if (isPlainBg || textBorderWidth && textBorderColor) {\n    ctx.beginPath();\n    var textBorderRadius = style.textBorderRadius;\n\n    if (!textBorderRadius) {\n      ctx.rect(x, y, width, height);\n    } else {\n      roundRectHelper.buildPath(ctx, {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        r: textBorderRadius\n      });\n    }\n\n    ctx.closePath();\n  }\n\n  if (isPlainBg) {\n    setCtx(ctx, 'fillStyle', textBackgroundColor);\n    ctx.fill();\n  } else if (isObject(textBackgroundColor)) {\n    var image = textBackgroundColor.image;\n    image = imageHelper.createOrUpdateImage(image, null, hostEl, onBgImageLoaded, textBackgroundColor);\n\n    if (image && imageHelper.isImageReady(image)) {\n      ctx.drawImage(image, x, y, width, height);\n    }\n  }\n\n  if (textBorderWidth && textBorderColor) {\n    setCtx(ctx, 'lineWidth', textBorderWidth);\n    setCtx(ctx, 'strokeStyle', textBorderColor);\n    ctx.stroke();\n  }\n}\n\nfunction onBgImageLoaded(image, textBackgroundColor) {\n  // Replace image, so that `contain/text.js#parseRichText`\n  // will get correct result in next tick.\n  textBackgroundColor.image = image;\n}\n\nfunction getBoxPosition(blockHeiht, style, rect) {\n  var baseX = style.x || 0;\n  var baseY = style.y || 0;\n  var textAlign = style.textAlign;\n  var textVerticalAlign = style.textVerticalAlign; // Text position represented by coord\n\n  if (rect) {\n    var textPosition = style.textPosition;\n\n    if (textPosition instanceof Array) {\n      // Percent\n      baseX = rect.x + parsePercent(textPosition[0], rect.width);\n      baseY = rect.y + parsePercent(textPosition[1], rect.height);\n    } else {\n      var res = textContain.adjustTextPositionOnRect(textPosition, rect, style.textDistance);\n      baseX = res.x;\n      baseY = res.y; // Default align and baseline when has textPosition\n\n      textAlign = textAlign || res.textAlign;\n      textVerticalAlign = textVerticalAlign || res.textVerticalAlign;\n    } // textOffset is only support in RectText, otherwise\n    // we have to adjust boundingRect for textOffset.\n\n\n    var textOffset = style.textOffset;\n\n    if (textOffset) {\n      baseX += textOffset[0];\n      baseY += textOffset[1];\n    }\n  }\n\n  return {\n    baseX: baseX,\n    baseY: baseY,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n\nfunction setCtx(ctx, prop, value) {\n  ctx[prop] = fixShadow(ctx, prop, value);\n  return ctx[prop];\n}\n/**\n * @param {string} [stroke] If specified, do not check style.textStroke.\n * @param {string} [lineWidth] If specified, do not check style.textStroke.\n * @param {number} style\n */\n\n\nfunction getStroke(stroke, lineWidth) {\n  return stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none' ? null // TODO pattern and gradient?\n  : stroke.image || stroke.colorStops ? '#000' : stroke;\n}\n\nfunction getFill(fill) {\n  return fill == null || fill === 'none' ? null // TODO pattern and gradient?\n  : fill.image || fill.colorStops ? '#000' : fill;\n}\n\nfunction parsePercent(value, maxValue) {\n  if (typeof value === 'string') {\n    if (value.lastIndexOf('%') >= 0) {\n      return parseFloat(value) / 100 * maxValue;\n    }\n\n    return parseFloat(value);\n  }\n\n  return value;\n}\n\nfunction getTextXForPadding(x, textAlign, textPadding) {\n  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];\n}\n/**\n * @param {string} text\n * @param {module:zrender/Style} style\n * @return {boolean}\n */\n\n\nfunction needDrawText(text, style) {\n  return text != null && (text || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);\n}\n\nexports.normalizeTextStyle = normalizeTextStyle;\nexports.renderText = renderText;\nexports.getStroke = getStroke;\nexports.getFill = getFill;\nexports.needDrawText = needDrawText;","map":{"version":3,"names":["_util","require","retrieve2","retrieve3","each","normalizeCssArray","isString","isObject","textContain","roundRectHelper","imageHelper","fixShadow","VALID_TEXT_ALIGN","left","right","center","VALID_TEXT_VERTICAL_ALIGN","top","bottom","middle","normalizeTextStyle","style","normalizeStyle","rich","font","makeFont","textAlign","textVerticalAlign","textBaseline","textPadding","renderText","hostEl","ctx","text","rect","renderRichText","renderPlainText","setCtx","DEFAULT_FONT","contentBlock","__textCotentBlock","__dirty","parsePlainText","truncate","outerHeight","textLines","lines","lineHeight","boxPos","getBoxPosition","baseX","baseY","applyTextRotation","boxY","adjustTextY","textX","textY","needDrawBg","needDrawBackground","textWidth","getWidth","outerWidth","boxX","adjustTextX","drawBackground","getTextXForPadding","textShadowBlur","textShadowColor","textShadowOffsetX","textShadowOffsetY","textStrokeWidth","textStroke","getStroke","textFill","getFill","i","length","strokeText","fillText","parseRichText","drawRichText","contentWidth","width","xLeft","lineTop","xRight","line","tokens","tokenCount","usedWidth","leftIndex","lineXLeft","lineXRight","rightIndex","token","placeToken","x","y","textRotation","origin","textOrigin","height","translate","rotate","tokenStyle","styleName","isLineHolder","textHeight","textBackgroundColor","textBorderWidth","textBorderColor","isPlainBg","textBoxShadowBlur","textBoxShadowColor","textBoxShadowOffsetX","textBoxShadowOffsetY","beginPath","textBorderRadius","buildPath","r","closePath","fill","image","createOrUpdateImage","onBgImageLoaded","isImageReady","drawImage","stroke","blockHeiht","textPosition","Array","parsePercent","res","adjustTextPositionOnRect","textDistance","textOffset","prop","value","lineWidth","colorStops","maxValue","lastIndexOf","parseFloat","needDrawText","exports"],"sources":["C:/Users/W/Desktop/vue_map/node_modules/zrender/lib/graphic/helper/text.js"],"sourcesContent":["var _util = require(\"../../core/util\");\n\nvar retrieve2 = _util.retrieve2;\nvar retrieve3 = _util.retrieve3;\nvar each = _util.each;\nvar normalizeCssArray = _util.normalizeCssArray;\nvar isString = _util.isString;\nvar isObject = _util.isObject;\n\nvar textContain = require(\"../../contain/text\");\n\nvar roundRectHelper = require(\"./roundRect\");\n\nvar imageHelper = require(\"./image\");\n\nvar fixShadow = require(\"./fixShadow\");\n\n// TODO: Have not support 'start', 'end' yet.\nvar VALID_TEXT_ALIGN = {\n  left: 1,\n  right: 1,\n  center: 1\n};\nvar VALID_TEXT_VERTICAL_ALIGN = {\n  top: 1,\n  bottom: 1,\n  middle: 1\n};\n/**\n * @param {module:zrender/graphic/Style} style\n * @return {module:zrender/graphic/Style} The input style.\n */\n\nfunction normalizeTextStyle(style) {\n  normalizeStyle(style);\n  each(style.rich, normalizeStyle);\n  return style;\n}\n\nfunction normalizeStyle(style) {\n  if (style) {\n    style.font = textContain.makeFont(style);\n    var textAlign = style.textAlign;\n    textAlign === 'middle' && (textAlign = 'center');\n    style.textAlign = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : 'left'; // Compatible with textBaseline.\n\n    var textVerticalAlign = style.textVerticalAlign || style.textBaseline;\n    textVerticalAlign === 'center' && (textVerticalAlign = 'middle');\n    style.textVerticalAlign = textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : 'top';\n    var textPadding = style.textPadding;\n\n    if (textPadding) {\n      style.textPadding = normalizeCssArray(style.textPadding);\n    }\n  }\n}\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {string} text\n * @param {module:zrender/graphic/Style} style\n * @param {Object|boolean} [rect] {x, y, width, height}\n *                  If set false, rect text is not used.\n */\n\n\nfunction renderText(hostEl, ctx, text, style, rect) {\n  style.rich ? renderRichText(hostEl, ctx, text, style, rect) : renderPlainText(hostEl, ctx, text, style, rect);\n}\n\nfunction renderPlainText(hostEl, ctx, text, style, rect) {\n  var font = setCtx(ctx, 'font', style.font || textContain.DEFAULT_FONT);\n  var textPadding = style.textPadding;\n  var contentBlock = hostEl.__textCotentBlock;\n\n  if (!contentBlock || hostEl.__dirty) {\n    contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(text, font, textPadding, style.truncate);\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var textLines = contentBlock.lines;\n  var lineHeight = contentBlock.lineHeight;\n  var boxPos = getBoxPosition(outerHeight, style, rect);\n  var baseX = boxPos.baseX;\n  var baseY = boxPos.baseY;\n  var textAlign = boxPos.textAlign;\n  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\n  applyTextRotation(ctx, style, rect, baseX, baseY);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var textX = baseX;\n  var textY = boxY;\n  var needDrawBg = needDrawBackground(style);\n\n  if (needDrawBg || textPadding) {\n    // Consider performance, do not call getTextWidth util necessary.\n    var textWidth = textContain.getWidth(text, font);\n    var outerWidth = textWidth;\n    textPadding && (outerWidth += textPadding[1] + textPadding[3]);\n    var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n    needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n    if (textPadding) {\n      textX = getTextXForPadding(baseX, textAlign, textPadding);\n      textY += textPadding[0];\n    }\n  }\n\n  setCtx(ctx, 'textAlign', textAlign || 'left'); // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\n  setCtx(ctx, 'textBaseline', 'middle'); // Always set shadowBlur and shadowOffset to avoid leak from displayable.\n\n  setCtx(ctx, 'shadowBlur', style.textShadowBlur || 0);\n  setCtx(ctx, 'shadowColor', style.textShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', style.textShadowOffsetX || 0);\n  setCtx(ctx, 'shadowOffsetY', style.textShadowOffsetY || 0); // `textBaseline` is set as 'middle'.\n\n  textY += lineHeight / 2;\n  var textStrokeWidth = style.textStrokeWidth;\n  var textStroke = getStroke(style.textStroke, textStrokeWidth);\n  var textFill = getFill(style.textFill);\n\n  if (textStroke) {\n    setCtx(ctx, 'lineWidth', textStrokeWidth);\n    setCtx(ctx, 'strokeStyle', textStroke);\n  }\n\n  if (textFill) {\n    setCtx(ctx, 'fillStyle', textFill);\n  }\n\n  for (var i = 0; i < textLines.length; i++) {\n    // Fill after stroke so the outline will not cover the main part.\n    textStroke && ctx.strokeText(textLines[i], textX, textY);\n    textFill && ctx.fillText(textLines[i], textX, textY);\n    textY += lineHeight;\n  }\n}\n\nfunction renderRichText(hostEl, ctx, text, style, rect) {\n  var contentBlock = hostEl.__textCotentBlock;\n\n  if (!contentBlock || hostEl.__dirty) {\n    contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style);\n  }\n\n  drawRichText(hostEl, ctx, contentBlock, style, rect);\n}\n\nfunction drawRichText(hostEl, ctx, contentBlock, style, rect) {\n  var contentWidth = contentBlock.width;\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var textPadding = style.textPadding;\n  var boxPos = getBoxPosition(outerHeight, style, rect);\n  var baseX = boxPos.baseX;\n  var baseY = boxPos.baseY;\n  var textAlign = boxPos.textAlign;\n  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\n  applyTextRotation(ctx, style, rect, baseX, baseY);\n  var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var xLeft = boxX;\n  var lineTop = boxY;\n\n  if (textPadding) {\n    xLeft += textPadding[3];\n    lineTop += textPadding[0];\n  }\n\n  var xRight = xLeft + contentWidth;\n  needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n  for (var i = 0; i < contentBlock.lines.length; i++) {\n    var line = contentBlock.lines[i];\n    var tokens = line.tokens;\n    var tokenCount = tokens.length;\n    var lineHeight = line.lineHeight;\n    var usedWidth = line.width;\n    var leftIndex = 0;\n    var lineXLeft = xLeft;\n    var lineXRight = xRight;\n    var rightIndex = tokenCount - 1;\n    var token;\n\n    while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')) {\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');\n      usedWidth -= token.width;\n      lineXLeft += token.width;\n      leftIndex++;\n    }\n\n    while (rightIndex >= 0 && (token = tokens[rightIndex], token.textAlign === 'right')) {\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');\n      usedWidth -= token.width;\n      lineXRight -= token.width;\n      rightIndex--;\n    } // The other tokens are placed as textAlign 'center' if there is enough space.\n\n\n    lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;\n\n    while (leftIndex <= rightIndex) {\n      token = tokens[leftIndex]; // Consider width specified by user, use 'center' rather than 'left'.\n\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');\n      lineXLeft += token.width;\n      leftIndex++;\n    }\n\n    lineTop += lineHeight;\n  }\n}\n\nfunction applyTextRotation(ctx, style, rect, x, y) {\n  // textRotation only apply in RectText.\n  if (rect && style.textRotation) {\n    var origin = style.textOrigin;\n\n    if (origin === 'center') {\n      x = rect.width / 2 + rect.x;\n      y = rect.height / 2 + rect.y;\n    } else if (origin) {\n      x = origin[0] + rect.x;\n      y = origin[1] + rect.y;\n    }\n\n    ctx.translate(x, y); // Positive: anticlockwise\n\n    ctx.rotate(-style.textRotation);\n    ctx.translate(-x, -y);\n  }\n}\n\nfunction placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {\n  var tokenStyle = style.rich[token.styleName] || {}; // 'ctx.textBaseline' is always set as 'middle', for sake of\n  // the bias of \"Microsoft YaHei\".\n\n  var textVerticalAlign = token.textVerticalAlign;\n  var y = lineTop + lineHeight / 2;\n\n  if (textVerticalAlign === 'top') {\n    y = lineTop + token.height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y = lineTop + lineHeight - token.height / 2;\n  }\n\n  !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, textAlign === 'right' ? x - token.width : textAlign === 'center' ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);\n  var textPadding = token.textPadding;\n\n  if (textPadding) {\n    x = getTextXForPadding(x, textAlign, textPadding);\n    y -= token.height / 2 - textPadding[2] - token.textHeight / 2;\n  }\n\n  setCtx(ctx, 'shadowBlur', retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));\n  setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));\n  setCtx(ctx, 'shadowOffsetY', retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));\n  setCtx(ctx, 'textAlign', textAlign); // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\n  setCtx(ctx, 'textBaseline', 'middle');\n  setCtx(ctx, 'font', token.font || textContain.DEFAULT_FONT);\n  var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);\n  var textFill = getFill(tokenStyle.textFill || style.textFill);\n  var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth); // Fill after stroke so the outline will not cover the main part.\n\n  if (textStroke) {\n    setCtx(ctx, 'lineWidth', textStrokeWidth);\n    setCtx(ctx, 'strokeStyle', textStroke);\n    ctx.strokeText(token.text, x, y);\n  }\n\n  if (textFill) {\n    setCtx(ctx, 'fillStyle', textFill);\n    ctx.fillText(token.text, x, y);\n  }\n}\n\nfunction needDrawBackground(style) {\n  return style.textBackgroundColor || style.textBorderWidth && style.textBorderColor;\n} // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius}\n// shape: {x, y, width, height}\n\n\nfunction drawBackground(hostEl, ctx, style, x, y, width, height) {\n  var textBackgroundColor = style.textBackgroundColor;\n  var textBorderWidth = style.textBorderWidth;\n  var textBorderColor = style.textBorderColor;\n  var isPlainBg = isString(textBackgroundColor);\n  setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);\n  setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);\n  setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);\n\n  if (isPlainBg || textBorderWidth && textBorderColor) {\n    ctx.beginPath();\n    var textBorderRadius = style.textBorderRadius;\n\n    if (!textBorderRadius) {\n      ctx.rect(x, y, width, height);\n    } else {\n      roundRectHelper.buildPath(ctx, {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        r: textBorderRadius\n      });\n    }\n\n    ctx.closePath();\n  }\n\n  if (isPlainBg) {\n    setCtx(ctx, 'fillStyle', textBackgroundColor);\n    ctx.fill();\n  } else if (isObject(textBackgroundColor)) {\n    var image = textBackgroundColor.image;\n    image = imageHelper.createOrUpdateImage(image, null, hostEl, onBgImageLoaded, textBackgroundColor);\n\n    if (image && imageHelper.isImageReady(image)) {\n      ctx.drawImage(image, x, y, width, height);\n    }\n  }\n\n  if (textBorderWidth && textBorderColor) {\n    setCtx(ctx, 'lineWidth', textBorderWidth);\n    setCtx(ctx, 'strokeStyle', textBorderColor);\n    ctx.stroke();\n  }\n}\n\nfunction onBgImageLoaded(image, textBackgroundColor) {\n  // Replace image, so that `contain/text.js#parseRichText`\n  // will get correct result in next tick.\n  textBackgroundColor.image = image;\n}\n\nfunction getBoxPosition(blockHeiht, style, rect) {\n  var baseX = style.x || 0;\n  var baseY = style.y || 0;\n  var textAlign = style.textAlign;\n  var textVerticalAlign = style.textVerticalAlign; // Text position represented by coord\n\n  if (rect) {\n    var textPosition = style.textPosition;\n\n    if (textPosition instanceof Array) {\n      // Percent\n      baseX = rect.x + parsePercent(textPosition[0], rect.width);\n      baseY = rect.y + parsePercent(textPosition[1], rect.height);\n    } else {\n      var res = textContain.adjustTextPositionOnRect(textPosition, rect, style.textDistance);\n      baseX = res.x;\n      baseY = res.y; // Default align and baseline when has textPosition\n\n      textAlign = textAlign || res.textAlign;\n      textVerticalAlign = textVerticalAlign || res.textVerticalAlign;\n    } // textOffset is only support in RectText, otherwise\n    // we have to adjust boundingRect for textOffset.\n\n\n    var textOffset = style.textOffset;\n\n    if (textOffset) {\n      baseX += textOffset[0];\n      baseY += textOffset[1];\n    }\n  }\n\n  return {\n    baseX: baseX,\n    baseY: baseY,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n\nfunction setCtx(ctx, prop, value) {\n  ctx[prop] = fixShadow(ctx, prop, value);\n  return ctx[prop];\n}\n/**\n * @param {string} [stroke] If specified, do not check style.textStroke.\n * @param {string} [lineWidth] If specified, do not check style.textStroke.\n * @param {number} style\n */\n\n\nfunction getStroke(stroke, lineWidth) {\n  return stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none' ? null // TODO pattern and gradient?\n  : stroke.image || stroke.colorStops ? '#000' : stroke;\n}\n\nfunction getFill(fill) {\n  return fill == null || fill === 'none' ? null // TODO pattern and gradient?\n  : fill.image || fill.colorStops ? '#000' : fill;\n}\n\nfunction parsePercent(value, maxValue) {\n  if (typeof value === 'string') {\n    if (value.lastIndexOf('%') >= 0) {\n      return parseFloat(value) / 100 * maxValue;\n    }\n\n    return parseFloat(value);\n  }\n\n  return value;\n}\n\nfunction getTextXForPadding(x, textAlign, textPadding) {\n  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];\n}\n/**\n * @param {string} text\n * @param {module:zrender/Style} style\n * @return {boolean}\n */\n\n\nfunction needDrawText(text, style) {\n  return text != null && (text || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);\n}\n\nexports.normalizeTextStyle = normalizeTextStyle;\nexports.renderText = renderText;\nexports.getStroke = getStroke;\nexports.getFill = getFill;\nexports.needDrawText = needDrawText;"],"mappings":"AAAA,IAAIA,KAAK,GAAGC,OAAO,CAAC,iBAAD,CAAnB;;AAEA,IAAIC,SAAS,GAAGF,KAAK,CAACE,SAAtB;AACA,IAAIC,SAAS,GAAGH,KAAK,CAACG,SAAtB;AACA,IAAIC,IAAI,GAAGJ,KAAK,CAACI,IAAjB;AACA,IAAIC,iBAAiB,GAAGL,KAAK,CAACK,iBAA9B;AACA,IAAIC,QAAQ,GAAGN,KAAK,CAACM,QAArB;AACA,IAAIC,QAAQ,GAAGP,KAAK,CAACO,QAArB;;AAEA,IAAIC,WAAW,GAAGP,OAAO,CAAC,oBAAD,CAAzB;;AAEA,IAAIQ,eAAe,GAAGR,OAAO,CAAC,aAAD,CAA7B;;AAEA,IAAIS,WAAW,GAAGT,OAAO,CAAC,SAAD,CAAzB;;AAEA,IAAIU,SAAS,GAAGV,OAAO,CAAC,aAAD,CAAvB,C,CAEA;;;AACA,IAAIW,gBAAgB,GAAG;EACrBC,IAAI,EAAE,CADe;EAErBC,KAAK,EAAE,CAFc;EAGrBC,MAAM,EAAE;AAHa,CAAvB;AAKA,IAAIC,yBAAyB,GAAG;EAC9BC,GAAG,EAAE,CADyB;EAE9BC,MAAM,EAAE,CAFsB;EAG9BC,MAAM,EAAE;AAHsB,CAAhC;AAKA;AACA;AACA;AACA;;AAEA,SAASC,kBAAT,CAA4BC,KAA5B,EAAmC;EACjCC,cAAc,CAACD,KAAD,CAAd;EACAjB,IAAI,CAACiB,KAAK,CAACE,IAAP,EAAaD,cAAb,CAAJ;EACA,OAAOD,KAAP;AACD;;AAED,SAASC,cAAT,CAAwBD,KAAxB,EAA+B;EAC7B,IAAIA,KAAJ,EAAW;IACTA,KAAK,CAACG,IAAN,GAAahB,WAAW,CAACiB,QAAZ,CAAqBJ,KAArB,CAAb;IACA,IAAIK,SAAS,GAAGL,KAAK,CAACK,SAAtB;IACAA,SAAS,KAAK,QAAd,KAA2BA,SAAS,GAAG,QAAvC;IACAL,KAAK,CAACK,SAAN,GAAkBA,SAAS,IAAI,IAAb,IAAqBd,gBAAgB,CAACc,SAAD,CAArC,GAAmDA,SAAnD,GAA+D,MAAjF,CAJS,CAIgF;;IAEzF,IAAIC,iBAAiB,GAAGN,KAAK,CAACM,iBAAN,IAA2BN,KAAK,CAACO,YAAzD;IACAD,iBAAiB,KAAK,QAAtB,KAAmCA,iBAAiB,GAAG,QAAvD;IACAN,KAAK,CAACM,iBAAN,GAA0BA,iBAAiB,IAAI,IAArB,IAA6BX,yBAAyB,CAACW,iBAAD,CAAtD,GAA4EA,iBAA5E,GAAgG,KAA1H;IACA,IAAIE,WAAW,GAAGR,KAAK,CAACQ,WAAxB;;IAEA,IAAIA,WAAJ,EAAiB;MACfR,KAAK,CAACQ,WAAN,GAAoBxB,iBAAiB,CAACgB,KAAK,CAACQ,WAAP,CAArC;IACD;EACF;AACF;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASC,UAAT,CAAoBC,MAApB,EAA4BC,GAA5B,EAAiCC,IAAjC,EAAuCZ,KAAvC,EAA8Ca,IAA9C,EAAoD;EAClDb,KAAK,CAACE,IAAN,GAAaY,cAAc,CAACJ,MAAD,EAASC,GAAT,EAAcC,IAAd,EAAoBZ,KAApB,EAA2Ba,IAA3B,CAA3B,GAA8DE,eAAe,CAACL,MAAD,EAASC,GAAT,EAAcC,IAAd,EAAoBZ,KAApB,EAA2Ba,IAA3B,CAA7E;AACD;;AAED,SAASE,eAAT,CAAyBL,MAAzB,EAAiCC,GAAjC,EAAsCC,IAAtC,EAA4CZ,KAA5C,EAAmDa,IAAnD,EAAyD;EACvD,IAAIV,IAAI,GAAGa,MAAM,CAACL,GAAD,EAAM,MAAN,EAAcX,KAAK,CAACG,IAAN,IAAchB,WAAW,CAAC8B,YAAxC,CAAjB;EACA,IAAIT,WAAW,GAAGR,KAAK,CAACQ,WAAxB;EACA,IAAIU,YAAY,GAAGR,MAAM,CAACS,iBAA1B;;EAEA,IAAI,CAACD,YAAD,IAAiBR,MAAM,CAACU,OAA5B,EAAqC;IACnCF,YAAY,GAAGR,MAAM,CAACS,iBAAP,GAA2BhC,WAAW,CAACkC,cAAZ,CAA2BT,IAA3B,EAAiCT,IAAjC,EAAuCK,WAAvC,EAAoDR,KAAK,CAACsB,QAA1D,CAA1C;EACD;;EAED,IAAIC,WAAW,GAAGL,YAAY,CAACK,WAA/B;EACA,IAAIC,SAAS,GAAGN,YAAY,CAACO,KAA7B;EACA,IAAIC,UAAU,GAAGR,YAAY,CAACQ,UAA9B;EACA,IAAIC,MAAM,GAAGC,cAAc,CAACL,WAAD,EAAcvB,KAAd,EAAqBa,IAArB,CAA3B;EACA,IAAIgB,KAAK,GAAGF,MAAM,CAACE,KAAnB;EACA,IAAIC,KAAK,GAAGH,MAAM,CAACG,KAAnB;EACA,IAAIzB,SAAS,GAAGsB,MAAM,CAACtB,SAAvB;EACA,IAAIC,iBAAiB,GAAGqB,MAAM,CAACrB,iBAA/B,CAhBuD,CAgBL;;EAElDyB,iBAAiB,CAACpB,GAAD,EAAMX,KAAN,EAAaa,IAAb,EAAmBgB,KAAnB,EAA0BC,KAA1B,CAAjB;EACA,IAAIE,IAAI,GAAG7C,WAAW,CAAC8C,WAAZ,CAAwBH,KAAxB,EAA+BP,WAA/B,EAA4CjB,iBAA5C,CAAX;EACA,IAAI4B,KAAK,GAAGL,KAAZ;EACA,IAAIM,KAAK,GAAGH,IAAZ;EACA,IAAII,UAAU,GAAGC,kBAAkB,CAACrC,KAAD,CAAnC;;EAEA,IAAIoC,UAAU,IAAI5B,WAAlB,EAA+B;IAC7B;IACA,IAAI8B,SAAS,GAAGnD,WAAW,CAACoD,QAAZ,CAAqB3B,IAArB,EAA2BT,IAA3B,CAAhB;IACA,IAAIqC,UAAU,GAAGF,SAAjB;IACA9B,WAAW,KAAKgC,UAAU,IAAIhC,WAAW,CAAC,CAAD,CAAX,GAAiBA,WAAW,CAAC,CAAD,CAA/C,CAAX;IACA,IAAIiC,IAAI,GAAGtD,WAAW,CAACuD,WAAZ,CAAwBb,KAAxB,EAA+BW,UAA/B,EAA2CnC,SAA3C,CAAX;IACA+B,UAAU,IAAIO,cAAc,CAACjC,MAAD,EAASC,GAAT,EAAcX,KAAd,EAAqByC,IAArB,EAA2BT,IAA3B,EAAiCQ,UAAjC,EAA6CjB,WAA7C,CAA5B;;IAEA,IAAIf,WAAJ,EAAiB;MACf0B,KAAK,GAAGU,kBAAkB,CAACf,KAAD,EAAQxB,SAAR,EAAmBG,WAAnB,CAA1B;MACA2B,KAAK,IAAI3B,WAAW,CAAC,CAAD,CAApB;IACD;EACF;;EAEDQ,MAAM,CAACL,GAAD,EAAM,WAAN,EAAmBN,SAAS,IAAI,MAAhC,CAAN,CAtCuD,CAsCR;EAC/C;;EAEAW,MAAM,CAACL,GAAD,EAAM,cAAN,EAAsB,QAAtB,CAAN,CAzCuD,CAyChB;;EAEvCK,MAAM,CAACL,GAAD,EAAM,YAAN,EAAoBX,KAAK,CAAC6C,cAAN,IAAwB,CAA5C,CAAN;EACA7B,MAAM,CAACL,GAAD,EAAM,aAAN,EAAqBX,KAAK,CAAC8C,eAAN,IAAyB,aAA9C,CAAN;EACA9B,MAAM,CAACL,GAAD,EAAM,eAAN,EAAuBX,KAAK,CAAC+C,iBAAN,IAA2B,CAAlD,CAAN;EACA/B,MAAM,CAACL,GAAD,EAAM,eAAN,EAAuBX,KAAK,CAACgD,iBAAN,IAA2B,CAAlD,CAAN,CA9CuD,CA8CK;;EAE5Db,KAAK,IAAIT,UAAU,GAAG,CAAtB;EACA,IAAIuB,eAAe,GAAGjD,KAAK,CAACiD,eAA5B;EACA,IAAIC,UAAU,GAAGC,SAAS,CAACnD,KAAK,CAACkD,UAAP,EAAmBD,eAAnB,CAA1B;EACA,IAAIG,QAAQ,GAAGC,OAAO,CAACrD,KAAK,CAACoD,QAAP,CAAtB;;EAEA,IAAIF,UAAJ,EAAgB;IACdlC,MAAM,CAACL,GAAD,EAAM,WAAN,EAAmBsC,eAAnB,CAAN;IACAjC,MAAM,CAACL,GAAD,EAAM,aAAN,EAAqBuC,UAArB,CAAN;EACD;;EAED,IAAIE,QAAJ,EAAc;IACZpC,MAAM,CAACL,GAAD,EAAM,WAAN,EAAmByC,QAAnB,CAAN;EACD;;EAED,KAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG9B,SAAS,CAAC+B,MAA9B,EAAsCD,CAAC,EAAvC,EAA2C;IACzC;IACAJ,UAAU,IAAIvC,GAAG,CAAC6C,UAAJ,CAAehC,SAAS,CAAC8B,CAAD,CAAxB,EAA6BpB,KAA7B,EAAoCC,KAApC,CAAd;IACAiB,QAAQ,IAAIzC,GAAG,CAAC8C,QAAJ,CAAajC,SAAS,CAAC8B,CAAD,CAAtB,EAA2BpB,KAA3B,EAAkCC,KAAlC,CAAZ;IACAA,KAAK,IAAIT,UAAT;EACD;AACF;;AAED,SAASZ,cAAT,CAAwBJ,MAAxB,EAAgCC,GAAhC,EAAqCC,IAArC,EAA2CZ,KAA3C,EAAkDa,IAAlD,EAAwD;EACtD,IAAIK,YAAY,GAAGR,MAAM,CAACS,iBAA1B;;EAEA,IAAI,CAACD,YAAD,IAAiBR,MAAM,CAACU,OAA5B,EAAqC;IACnCF,YAAY,GAAGR,MAAM,CAACS,iBAAP,GAA2BhC,WAAW,CAACuE,aAAZ,CAA0B9C,IAA1B,EAAgCZ,KAAhC,CAA1C;EACD;;EAED2D,YAAY,CAACjD,MAAD,EAASC,GAAT,EAAcO,YAAd,EAA4BlB,KAA5B,EAAmCa,IAAnC,CAAZ;AACD;;AAED,SAAS8C,YAAT,CAAsBjD,MAAtB,EAA8BC,GAA9B,EAAmCO,YAAnC,EAAiDlB,KAAjD,EAAwDa,IAAxD,EAA8D;EAC5D,IAAI+C,YAAY,GAAG1C,YAAY,CAAC2C,KAAhC;EACA,IAAIrB,UAAU,GAAGtB,YAAY,CAACsB,UAA9B;EACA,IAAIjB,WAAW,GAAGL,YAAY,CAACK,WAA/B;EACA,IAAIf,WAAW,GAAGR,KAAK,CAACQ,WAAxB;EACA,IAAImB,MAAM,GAAGC,cAAc,CAACL,WAAD,EAAcvB,KAAd,EAAqBa,IAArB,CAA3B;EACA,IAAIgB,KAAK,GAAGF,MAAM,CAACE,KAAnB;EACA,IAAIC,KAAK,GAAGH,MAAM,CAACG,KAAnB;EACA,IAAIzB,SAAS,GAAGsB,MAAM,CAACtB,SAAvB;EACA,IAAIC,iBAAiB,GAAGqB,MAAM,CAACrB,iBAA/B,CAT4D,CASV;;EAElDyB,iBAAiB,CAACpB,GAAD,EAAMX,KAAN,EAAaa,IAAb,EAAmBgB,KAAnB,EAA0BC,KAA1B,CAAjB;EACA,IAAIW,IAAI,GAAGtD,WAAW,CAACuD,WAAZ,CAAwBb,KAAxB,EAA+BW,UAA/B,EAA2CnC,SAA3C,CAAX;EACA,IAAI2B,IAAI,GAAG7C,WAAW,CAAC8C,WAAZ,CAAwBH,KAAxB,EAA+BP,WAA/B,EAA4CjB,iBAA5C,CAAX;EACA,IAAIwD,KAAK,GAAGrB,IAAZ;EACA,IAAIsB,OAAO,GAAG/B,IAAd;;EAEA,IAAIxB,WAAJ,EAAiB;IACfsD,KAAK,IAAItD,WAAW,CAAC,CAAD,CAApB;IACAuD,OAAO,IAAIvD,WAAW,CAAC,CAAD,CAAtB;EACD;;EAED,IAAIwD,MAAM,GAAGF,KAAK,GAAGF,YAArB;EACAvB,kBAAkB,CAACrC,KAAD,CAAlB,IAA6B2C,cAAc,CAACjC,MAAD,EAASC,GAAT,EAAcX,KAAd,EAAqByC,IAArB,EAA2BT,IAA3B,EAAiCQ,UAAjC,EAA6CjB,WAA7C,CAA3C;;EAEA,KAAK,IAAI+B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGpC,YAAY,CAACO,KAAb,CAAmB8B,MAAvC,EAA+CD,CAAC,EAAhD,EAAoD;IAClD,IAAIW,IAAI,GAAG/C,YAAY,CAACO,KAAb,CAAmB6B,CAAnB,CAAX;IACA,IAAIY,MAAM,GAAGD,IAAI,CAACC,MAAlB;IACA,IAAIC,UAAU,GAAGD,MAAM,CAACX,MAAxB;IACA,IAAI7B,UAAU,GAAGuC,IAAI,CAACvC,UAAtB;IACA,IAAI0C,SAAS,GAAGH,IAAI,CAACJ,KAArB;IACA,IAAIQ,SAAS,GAAG,CAAhB;IACA,IAAIC,SAAS,GAAGR,KAAhB;IACA,IAAIS,UAAU,GAAGP,MAAjB;IACA,IAAIQ,UAAU,GAAGL,UAAU,GAAG,CAA9B;IACA,IAAIM,KAAJ;;IAEA,OAAOJ,SAAS,GAAGF,UAAZ,KAA2BM,KAAK,GAAGP,MAAM,CAACG,SAAD,CAAd,EAA2B,CAACI,KAAK,CAACpE,SAAP,IAAoBoE,KAAK,CAACpE,SAAN,KAAoB,MAA9F,CAAP,EAA8G;MAC5GqE,UAAU,CAAChE,MAAD,EAASC,GAAT,EAAc8D,KAAd,EAAqBzE,KAArB,EAA4B0B,UAA5B,EAAwCqC,OAAxC,EAAiDO,SAAjD,EAA4D,MAA5D,CAAV;MACAF,SAAS,IAAIK,KAAK,CAACZ,KAAnB;MACAS,SAAS,IAAIG,KAAK,CAACZ,KAAnB;MACAQ,SAAS;IACV;;IAED,OAAOG,UAAU,IAAI,CAAd,KAAoBC,KAAK,GAAGP,MAAM,CAACM,UAAD,CAAd,EAA4BC,KAAK,CAACpE,SAAN,KAAoB,OAApE,CAAP,EAAqF;MACnFqE,UAAU,CAAChE,MAAD,EAASC,GAAT,EAAc8D,KAAd,EAAqBzE,KAArB,EAA4B0B,UAA5B,EAAwCqC,OAAxC,EAAiDQ,UAAjD,EAA6D,OAA7D,CAAV;MACAH,SAAS,IAAIK,KAAK,CAACZ,KAAnB;MACAU,UAAU,IAAIE,KAAK,CAACZ,KAApB;MACAW,UAAU;IACX,CAxBiD,CAwBhD;;;IAGFF,SAAS,IAAI,CAACV,YAAY,IAAIU,SAAS,GAAGR,KAAhB,CAAZ,IAAsCE,MAAM,GAAGO,UAA/C,IAA6DH,SAA9D,IAA2E,CAAxF;;IAEA,OAAOC,SAAS,IAAIG,UAApB,EAAgC;MAC9BC,KAAK,GAAGP,MAAM,CAACG,SAAD,CAAd,CAD8B,CACH;;MAE3BK,UAAU,CAAChE,MAAD,EAASC,GAAT,EAAc8D,KAAd,EAAqBzE,KAArB,EAA4B0B,UAA5B,EAAwCqC,OAAxC,EAAiDO,SAAS,GAAGG,KAAK,CAACZ,KAAN,GAAc,CAA3E,EAA8E,QAA9E,CAAV;MACAS,SAAS,IAAIG,KAAK,CAACZ,KAAnB;MACAQ,SAAS;IACV;;IAEDN,OAAO,IAAIrC,UAAX;EACD;AACF;;AAED,SAASK,iBAAT,CAA2BpB,GAA3B,EAAgCX,KAAhC,EAAuCa,IAAvC,EAA6C8D,CAA7C,EAAgDC,CAAhD,EAAmD;EACjD;EACA,IAAI/D,IAAI,IAAIb,KAAK,CAAC6E,YAAlB,EAAgC;IAC9B,IAAIC,MAAM,GAAG9E,KAAK,CAAC+E,UAAnB;;IAEA,IAAID,MAAM,KAAK,QAAf,EAAyB;MACvBH,CAAC,GAAG9D,IAAI,CAACgD,KAAL,GAAa,CAAb,GAAiBhD,IAAI,CAAC8D,CAA1B;MACAC,CAAC,GAAG/D,IAAI,CAACmE,MAAL,GAAc,CAAd,GAAkBnE,IAAI,CAAC+D,CAA3B;IACD,CAHD,MAGO,IAAIE,MAAJ,EAAY;MACjBH,CAAC,GAAGG,MAAM,CAAC,CAAD,CAAN,GAAYjE,IAAI,CAAC8D,CAArB;MACAC,CAAC,GAAGE,MAAM,CAAC,CAAD,CAAN,GAAYjE,IAAI,CAAC+D,CAArB;IACD;;IAEDjE,GAAG,CAACsE,SAAJ,CAAcN,CAAd,EAAiBC,CAAjB,EAX8B,CAWT;;IAErBjE,GAAG,CAACuE,MAAJ,CAAW,CAAClF,KAAK,CAAC6E,YAAlB;IACAlE,GAAG,CAACsE,SAAJ,CAAc,CAACN,CAAf,EAAkB,CAACC,CAAnB;EACD;AACF;;AAED,SAASF,UAAT,CAAoBhE,MAApB,EAA4BC,GAA5B,EAAiC8D,KAAjC,EAAwCzE,KAAxC,EAA+C0B,UAA/C,EAA2DqC,OAA3D,EAAoEY,CAApE,EAAuEtE,SAAvE,EAAkF;EAChF,IAAI8E,UAAU,GAAGnF,KAAK,CAACE,IAAN,CAAWuE,KAAK,CAACW,SAAjB,KAA+B,EAAhD,CADgF,CAC5B;EACpD;;EAEA,IAAI9E,iBAAiB,GAAGmE,KAAK,CAACnE,iBAA9B;EACA,IAAIsE,CAAC,GAAGb,OAAO,GAAGrC,UAAU,GAAG,CAA/B;;EAEA,IAAIpB,iBAAiB,KAAK,KAA1B,EAAiC;IAC/BsE,CAAC,GAAGb,OAAO,GAAGU,KAAK,CAACO,MAAN,GAAe,CAA7B;EACD,CAFD,MAEO,IAAI1E,iBAAiB,KAAK,QAA1B,EAAoC;IACzCsE,CAAC,GAAGb,OAAO,GAAGrC,UAAV,GAAuB+C,KAAK,CAACO,MAAN,GAAe,CAA1C;EACD;;EAED,CAACP,KAAK,CAACY,YAAP,IAAuBhD,kBAAkB,CAAC8C,UAAD,CAAzC,IAAyDxC,cAAc,CAACjC,MAAD,EAASC,GAAT,EAAcwE,UAAd,EAA0B9E,SAAS,KAAK,OAAd,GAAwBsE,CAAC,GAAGF,KAAK,CAACZ,KAAlC,GAA0CxD,SAAS,KAAK,QAAd,GAAyBsE,CAAC,GAAGF,KAAK,CAACZ,KAAN,GAAc,CAA3C,GAA+Cc,CAAnH,EAAsHC,CAAC,GAAGH,KAAK,CAACO,MAAN,GAAe,CAAzI,EAA4IP,KAAK,CAACZ,KAAlJ,EAAyJY,KAAK,CAACO,MAA/J,CAAvE;EACA,IAAIxE,WAAW,GAAGiE,KAAK,CAACjE,WAAxB;;EAEA,IAAIA,WAAJ,EAAiB;IACfmE,CAAC,GAAG/B,kBAAkB,CAAC+B,CAAD,EAAItE,SAAJ,EAAeG,WAAf,CAAtB;IACAoE,CAAC,IAAIH,KAAK,CAACO,MAAN,GAAe,CAAf,GAAmBxE,WAAW,CAAC,CAAD,CAA9B,GAAoCiE,KAAK,CAACa,UAAN,GAAmB,CAA5D;EACD;;EAEDtE,MAAM,CAACL,GAAD,EAAM,YAAN,EAAoB7B,SAAS,CAACqG,UAAU,CAACtC,cAAZ,EAA4B7C,KAAK,CAAC6C,cAAlC,EAAkD,CAAlD,CAA7B,CAAN;EACA7B,MAAM,CAACL,GAAD,EAAM,aAAN,EAAqBwE,UAAU,CAACrC,eAAX,IAA8B9C,KAAK,CAAC8C,eAApC,IAAuD,aAA5E,CAAN;EACA9B,MAAM,CAACL,GAAD,EAAM,eAAN,EAAuB7B,SAAS,CAACqG,UAAU,CAACpC,iBAAZ,EAA+B/C,KAAK,CAAC+C,iBAArC,EAAwD,CAAxD,CAAhC,CAAN;EACA/B,MAAM,CAACL,GAAD,EAAM,eAAN,EAAuB7B,SAAS,CAACqG,UAAU,CAACnC,iBAAZ,EAA+BhD,KAAK,CAACgD,iBAArC,EAAwD,CAAxD,CAAhC,CAAN;EACAhC,MAAM,CAACL,GAAD,EAAM,WAAN,EAAmBN,SAAnB,CAAN,CAzBgF,CAyB3C;EACrC;;EAEAW,MAAM,CAACL,GAAD,EAAM,cAAN,EAAsB,QAAtB,CAAN;EACAK,MAAM,CAACL,GAAD,EAAM,MAAN,EAAc8D,KAAK,CAACtE,IAAN,IAAchB,WAAW,CAAC8B,YAAxC,CAAN;EACA,IAAIiC,UAAU,GAAGC,SAAS,CAACgC,UAAU,CAACjC,UAAX,IAAyBlD,KAAK,CAACkD,UAAhC,EAA4CD,eAA5C,CAA1B;EACA,IAAIG,QAAQ,GAAGC,OAAO,CAAC8B,UAAU,CAAC/B,QAAX,IAAuBpD,KAAK,CAACoD,QAA9B,CAAtB;EACA,IAAIH,eAAe,GAAGpE,SAAS,CAACsG,UAAU,CAAClC,eAAZ,EAA6BjD,KAAK,CAACiD,eAAnC,CAA/B,CAhCgF,CAgCI;;EAEpF,IAAIC,UAAJ,EAAgB;IACdlC,MAAM,CAACL,GAAD,EAAM,WAAN,EAAmBsC,eAAnB,CAAN;IACAjC,MAAM,CAACL,GAAD,EAAM,aAAN,EAAqBuC,UAArB,CAAN;IACAvC,GAAG,CAAC6C,UAAJ,CAAeiB,KAAK,CAAC7D,IAArB,EAA2B+D,CAA3B,EAA8BC,CAA9B;EACD;;EAED,IAAIxB,QAAJ,EAAc;IACZpC,MAAM,CAACL,GAAD,EAAM,WAAN,EAAmByC,QAAnB,CAAN;IACAzC,GAAG,CAAC8C,QAAJ,CAAagB,KAAK,CAAC7D,IAAnB,EAAyB+D,CAAzB,EAA4BC,CAA5B;EACD;AACF;;AAED,SAASvC,kBAAT,CAA4BrC,KAA5B,EAAmC;EACjC,OAAOA,KAAK,CAACuF,mBAAN,IAA6BvF,KAAK,CAACwF,eAAN,IAAyBxF,KAAK,CAACyF,eAAnE;AACD,C,CAAC;AACF;;;AAGA,SAAS9C,cAAT,CAAwBjC,MAAxB,EAAgCC,GAAhC,EAAqCX,KAArC,EAA4C2E,CAA5C,EAA+CC,CAA/C,EAAkDf,KAAlD,EAAyDmB,MAAzD,EAAiE;EAC/D,IAAIO,mBAAmB,GAAGvF,KAAK,CAACuF,mBAAhC;EACA,IAAIC,eAAe,GAAGxF,KAAK,CAACwF,eAA5B;EACA,IAAIC,eAAe,GAAGzF,KAAK,CAACyF,eAA5B;EACA,IAAIC,SAAS,GAAGzG,QAAQ,CAACsG,mBAAD,CAAxB;EACAvE,MAAM,CAACL,GAAD,EAAM,YAAN,EAAoBX,KAAK,CAAC2F,iBAAN,IAA2B,CAA/C,CAAN;EACA3E,MAAM,CAACL,GAAD,EAAM,aAAN,EAAqBX,KAAK,CAAC4F,kBAAN,IAA4B,aAAjD,CAAN;EACA5E,MAAM,CAACL,GAAD,EAAM,eAAN,EAAuBX,KAAK,CAAC6F,oBAAN,IAA8B,CAArD,CAAN;EACA7E,MAAM,CAACL,GAAD,EAAM,eAAN,EAAuBX,KAAK,CAAC8F,oBAAN,IAA8B,CAArD,CAAN;;EAEA,IAAIJ,SAAS,IAAIF,eAAe,IAAIC,eAApC,EAAqD;IACnD9E,GAAG,CAACoF,SAAJ;IACA,IAAIC,gBAAgB,GAAGhG,KAAK,CAACgG,gBAA7B;;IAEA,IAAI,CAACA,gBAAL,EAAuB;MACrBrF,GAAG,CAACE,IAAJ,CAAS8D,CAAT,EAAYC,CAAZ,EAAef,KAAf,EAAsBmB,MAAtB;IACD,CAFD,MAEO;MACL5F,eAAe,CAAC6G,SAAhB,CAA0BtF,GAA1B,EAA+B;QAC7BgE,CAAC,EAAEA,CAD0B;QAE7BC,CAAC,EAAEA,CAF0B;QAG7Bf,KAAK,EAAEA,KAHsB;QAI7BmB,MAAM,EAAEA,MAJqB;QAK7BkB,CAAC,EAAEF;MAL0B,CAA/B;IAOD;;IAEDrF,GAAG,CAACwF,SAAJ;EACD;;EAED,IAAIT,SAAJ,EAAe;IACb1E,MAAM,CAACL,GAAD,EAAM,WAAN,EAAmB4E,mBAAnB,CAAN;IACA5E,GAAG,CAACyF,IAAJ;EACD,CAHD,MAGO,IAAIlH,QAAQ,CAACqG,mBAAD,CAAZ,EAAmC;IACxC,IAAIc,KAAK,GAAGd,mBAAmB,CAACc,KAAhC;IACAA,KAAK,GAAGhH,WAAW,CAACiH,mBAAZ,CAAgCD,KAAhC,EAAuC,IAAvC,EAA6C3F,MAA7C,EAAqD6F,eAArD,EAAsEhB,mBAAtE,CAAR;;IAEA,IAAIc,KAAK,IAAIhH,WAAW,CAACmH,YAAZ,CAAyBH,KAAzB,CAAb,EAA8C;MAC5C1F,GAAG,CAAC8F,SAAJ,CAAcJ,KAAd,EAAqB1B,CAArB,EAAwBC,CAAxB,EAA2Bf,KAA3B,EAAkCmB,MAAlC;IACD;EACF;;EAED,IAAIQ,eAAe,IAAIC,eAAvB,EAAwC;IACtCzE,MAAM,CAACL,GAAD,EAAM,WAAN,EAAmB6E,eAAnB,CAAN;IACAxE,MAAM,CAACL,GAAD,EAAM,aAAN,EAAqB8E,eAArB,CAAN;IACA9E,GAAG,CAAC+F,MAAJ;EACD;AACF;;AAED,SAASH,eAAT,CAAyBF,KAAzB,EAAgCd,mBAAhC,EAAqD;EACnD;EACA;EACAA,mBAAmB,CAACc,KAApB,GAA4BA,KAA5B;AACD;;AAED,SAASzE,cAAT,CAAwB+E,UAAxB,EAAoC3G,KAApC,EAA2Ca,IAA3C,EAAiD;EAC/C,IAAIgB,KAAK,GAAG7B,KAAK,CAAC2E,CAAN,IAAW,CAAvB;EACA,IAAI7C,KAAK,GAAG9B,KAAK,CAAC4E,CAAN,IAAW,CAAvB;EACA,IAAIvE,SAAS,GAAGL,KAAK,CAACK,SAAtB;EACA,IAAIC,iBAAiB,GAAGN,KAAK,CAACM,iBAA9B,CAJ+C,CAIE;;EAEjD,IAAIO,IAAJ,EAAU;IACR,IAAI+F,YAAY,GAAG5G,KAAK,CAAC4G,YAAzB;;IAEA,IAAIA,YAAY,YAAYC,KAA5B,EAAmC;MACjC;MACAhF,KAAK,GAAGhB,IAAI,CAAC8D,CAAL,GAASmC,YAAY,CAACF,YAAY,CAAC,CAAD,CAAb,EAAkB/F,IAAI,CAACgD,KAAvB,CAA7B;MACA/B,KAAK,GAAGjB,IAAI,CAAC+D,CAAL,GAASkC,YAAY,CAACF,YAAY,CAAC,CAAD,CAAb,EAAkB/F,IAAI,CAACmE,MAAvB,CAA7B;IACD,CAJD,MAIO;MACL,IAAI+B,GAAG,GAAG5H,WAAW,CAAC6H,wBAAZ,CAAqCJ,YAArC,EAAmD/F,IAAnD,EAAyDb,KAAK,CAACiH,YAA/D,CAAV;MACApF,KAAK,GAAGkF,GAAG,CAACpC,CAAZ;MACA7C,KAAK,GAAGiF,GAAG,CAACnC,CAAZ,CAHK,CAGU;;MAEfvE,SAAS,GAAGA,SAAS,IAAI0G,GAAG,CAAC1G,SAA7B;MACAC,iBAAiB,GAAGA,iBAAiB,IAAIyG,GAAG,CAACzG,iBAA7C;IACD,CAdO,CAcN;IACF;;;IAGA,IAAI4G,UAAU,GAAGlH,KAAK,CAACkH,UAAvB;;IAEA,IAAIA,UAAJ,EAAgB;MACdrF,KAAK,IAAIqF,UAAU,CAAC,CAAD,CAAnB;MACApF,KAAK,IAAIoF,UAAU,CAAC,CAAD,CAAnB;IACD;EACF;;EAED,OAAO;IACLrF,KAAK,EAAEA,KADF;IAELC,KAAK,EAAEA,KAFF;IAGLzB,SAAS,EAAEA,SAHN;IAILC,iBAAiB,EAAEA;EAJd,CAAP;AAMD;;AAED,SAASU,MAAT,CAAgBL,GAAhB,EAAqBwG,IAArB,EAA2BC,KAA3B,EAAkC;EAChCzG,GAAG,CAACwG,IAAD,CAAH,GAAY7H,SAAS,CAACqB,GAAD,EAAMwG,IAAN,EAAYC,KAAZ,CAArB;EACA,OAAOzG,GAAG,CAACwG,IAAD,CAAV;AACD;AACD;AACA;AACA;AACA;AACA;;;AAGA,SAAShE,SAAT,CAAmBuD,MAAnB,EAA2BW,SAA3B,EAAsC;EACpC,OAAOX,MAAM,IAAI,IAAV,IAAkBW,SAAS,IAAI,CAA/B,IAAoCX,MAAM,KAAK,aAA/C,IAAgEA,MAAM,KAAK,MAA3E,GAAoF,IAApF,CAAyF;EAAzF,EACLA,MAAM,CAACL,KAAP,IAAgBK,MAAM,CAACY,UAAvB,GAAoC,MAApC,GAA6CZ,MAD/C;AAED;;AAED,SAASrD,OAAT,CAAiB+C,IAAjB,EAAuB;EACrB,OAAOA,IAAI,IAAI,IAAR,IAAgBA,IAAI,KAAK,MAAzB,GAAkC,IAAlC,CAAuC;EAAvC,EACLA,IAAI,CAACC,KAAL,IAAcD,IAAI,CAACkB,UAAnB,GAAgC,MAAhC,GAAyClB,IAD3C;AAED;;AAED,SAASU,YAAT,CAAsBM,KAAtB,EAA6BG,QAA7B,EAAuC;EACrC,IAAI,OAAOH,KAAP,KAAiB,QAArB,EAA+B;IAC7B,IAAIA,KAAK,CAACI,WAAN,CAAkB,GAAlB,KAA0B,CAA9B,EAAiC;MAC/B,OAAOC,UAAU,CAACL,KAAD,CAAV,GAAoB,GAApB,GAA0BG,QAAjC;IACD;;IAED,OAAOE,UAAU,CAACL,KAAD,CAAjB;EACD;;EAED,OAAOA,KAAP;AACD;;AAED,SAASxE,kBAAT,CAA4B+B,CAA5B,EAA+BtE,SAA/B,EAA0CG,WAA1C,EAAuD;EACrD,OAAOH,SAAS,KAAK,OAAd,GAAwBsE,CAAC,GAAGnE,WAAW,CAAC,CAAD,CAAvC,GAA6CH,SAAS,KAAK,QAAd,GAAyBsE,CAAC,GAAGnE,WAAW,CAAC,CAAD,CAAX,GAAiB,CAArB,GAAyBA,WAAW,CAAC,CAAD,CAAX,GAAiB,CAAnE,GAAuEmE,CAAC,GAAGnE,WAAW,CAAC,CAAD,CAA1I;AACD;AACD;AACA;AACA;AACA;AACA;;;AAGA,SAASkH,YAAT,CAAsB9G,IAAtB,EAA4BZ,KAA5B,EAAmC;EACjC,OAAOY,IAAI,IAAI,IAAR,KAAiBA,IAAI,IAAIZ,KAAK,CAACuF,mBAAd,IAAqCvF,KAAK,CAACwF,eAAN,IAAyBxF,KAAK,CAACyF,eAApE,IAAuFzF,KAAK,CAACQ,WAA9G,CAAP;AACD;;AAEDmH,OAAO,CAAC5H,kBAAR,GAA6BA,kBAA7B;AACA4H,OAAO,CAAClH,UAAR,GAAqBA,UAArB;AACAkH,OAAO,CAACxE,SAAR,GAAoBA,SAApB;AACAwE,OAAO,CAACtE,OAAR,GAAkBA,OAAlB;AACAsE,OAAO,CAACD,YAAR,GAAuBA,YAAvB"},"metadata":{},"sourceType":"script"}