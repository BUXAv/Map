{"ast":null,"code":"var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar isObject = _util.isObject;\nvar each = _util.each;\nvar map = _util.map;\nvar indexOf = _util.indexOf;\nvar retrieve = _util.retrieve;\n\nvar _layout = require(\"../../util/layout\");\n\nvar getLayoutRect = _layout.getLayoutRect;\n\nvar _axisHelper = require(\"../../coord/axisHelper\");\n\nvar createScaleByModel = _axisHelper.createScaleByModel;\nvar ifAxisCrossZero = _axisHelper.ifAxisCrossZero;\nvar niceScaleExtent = _axisHelper.niceScaleExtent;\nvar estimateLabelUnionRect = _axisHelper.estimateLabelUnionRect;\n\nvar Cartesian2D = require(\"./Cartesian2D\");\n\nvar Axis2D = require(\"./Axis2D\");\n\nvar CoordinateSystem = require(\"../../CoordinateSystem\");\n\nvar _dataStackHelper = require(\"../../data/helper/dataStackHelper\");\n\nvar getStackedDimension = _dataStackHelper.getStackedDimension;\n\nrequire(\"./GridModel\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Grid is a region which contains at most 4 cartesian systems\n *\n * TODO Default cartesian\n */\n// Depends on GridModel, AxisModel, which performs preprocess.\n\n/**\n * Check if the axis is used in the specified grid\n * @inner\n */\n\n\nfunction isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n  return axisModel.getCoordSysModel() === gridModel;\n}\n\nfunction Grid(gridModel, ecModel, api) {\n  /**\n   * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n   * @private\n   */\n  this._coordsMap = {};\n  /**\n   * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n   * @private\n   */\n\n  this._coordsList = [];\n  /**\n   * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n   * @private\n   */\n\n  this._axesMap = {};\n  /**\n   * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n   * @private\n   */\n\n  this._axesList = [];\n\n  this._initCartesian(gridModel, ecModel, api);\n\n  this.model = gridModel;\n}\n\nvar gridProto = Grid.prototype;\ngridProto.type = 'grid';\ngridProto.axisPointerEnabled = true;\n\ngridProto.getRect = function () {\n  return this._rect;\n};\n\ngridProto.update = function (ecModel, api) {\n  var axesMap = this._axesMap;\n\n  this._updateScale(ecModel, this.model);\n\n  each(axesMap.x, function (xAxis) {\n    niceScaleExtent(xAxis.scale, xAxis.model);\n  });\n  each(axesMap.y, function (yAxis) {\n    niceScaleExtent(yAxis.scale, yAxis.model);\n  });\n  each(axesMap.x, function (xAxis) {\n    fixAxisOnZero(axesMap, 'y', xAxis);\n  });\n  each(axesMap.y, function (yAxis) {\n    fixAxisOnZero(axesMap, 'x', yAxis);\n  }); // Resize again if containLabel is enabled\n  // FIXME It may cause getting wrong grid size in data processing stage\n\n  this.resize(this.model, api);\n};\n\nfunction fixAxisOnZero(axesMap, otherAxisDim, axis) {\n  axis.getAxesOnZeroOf = function () {\n    // TODO: onZero of multiple axes.\n    return otherAxis ? [otherAxis] : [];\n  }; // onZero can not be enabled in these two situations:\n  // 1. When any other axis is a category axis.\n  // 2. When no axis is cross 0 point.\n\n\n  var otherAxes = axesMap[otherAxisDim];\n  var otherAxis;\n  var axisModel = axis.model;\n  var onZero = axisModel.get('axisLine.onZero');\n  var onZeroAxisIndex = axisModel.get('axisLine.onZeroAxisIndex');\n\n  if (!onZero) {\n    return;\n  } // If target axis is specified.\n\n\n  if (onZeroAxisIndex != null) {\n    if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {\n      otherAxis = otherAxes[onZeroAxisIndex];\n    }\n\n    return;\n  } // Find the first available other axis.\n\n\n  for (var idx in otherAxes) {\n    if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx])) {\n      otherAxis = otherAxes[idx];\n      break;\n    }\n  }\n}\n\nfunction canOnZeroToAxis(axis) {\n  return axis && axis.type !== 'category' && axis.type !== 'time' && ifAxisCrossZero(axis);\n}\n/**\n * Resize the grid\n * @param {module:echarts/coord/cartesian/GridModel} gridModel\n * @param {module:echarts/ExtensionAPI} api\n */\n\n\ngridProto.resize = function (gridModel, api, ignoreContainLabel) {\n  var gridRect = getLayoutRect(gridModel.getBoxLayoutParams(), {\n    width: api.getWidth(),\n    height: api.getHeight()\n  });\n  this._rect = gridRect;\n  var axesList = this._axesList;\n  adjustAxes(); // Minus label size\n\n  if (!ignoreContainLabel && gridModel.get('containLabel')) {\n    each(axesList, function (axis) {\n      if (!axis.model.get('axisLabel.inside')) {\n        var labelUnionRect = estimateLabelUnionRect(axis);\n\n        if (labelUnionRect) {\n          var dim = axis.isHorizontal() ? 'height' : 'width';\n          var margin = axis.model.get('axisLabel.margin');\n          gridRect[dim] -= labelUnionRect[dim] + margin;\n\n          if (axis.position === 'top') {\n            gridRect.y += labelUnionRect.height + margin;\n          } else if (axis.position === 'left') {\n            gridRect.x += labelUnionRect.width + margin;\n          }\n        }\n      }\n    });\n    adjustAxes();\n  }\n\n  function adjustAxes() {\n    each(axesList, function (axis) {\n      var isHorizontal = axis.isHorizontal();\n      var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n      var idx = axis.inverse ? 1 : 0;\n      axis.setExtent(extent[idx], extent[1 - idx]);\n      updateAxisTransform(axis, isHorizontal ? gridRect.x : gridRect.y);\n    });\n  }\n};\n/**\n * @param {string} axisType\n * @param {number} [axisIndex]\n */\n\n\ngridProto.getAxis = function (axisType, axisIndex) {\n  var axesMapOnDim = this._axesMap[axisType];\n\n  if (axesMapOnDim != null) {\n    if (axisIndex == null) {\n      // Find first axis\n      for (var name in axesMapOnDim) {\n        if (axesMapOnDim.hasOwnProperty(name)) {\n          return axesMapOnDim[name];\n        }\n      }\n    }\n\n    return axesMapOnDim[axisIndex];\n  }\n};\n/**\n * @return {Array.<module:echarts/coord/Axis>}\n */\n\n\ngridProto.getAxes = function () {\n  return this._axesList.slice();\n};\n/**\n * Usage:\n *      grid.getCartesian(xAxisIndex, yAxisIndex);\n *      grid.getCartesian(xAxisIndex);\n *      grid.getCartesian(null, yAxisIndex);\n *      grid.getCartesian({xAxisIndex: ..., yAxisIndex: ...});\n *\n * @param {number|Object} [xAxisIndex]\n * @param {number} [yAxisIndex]\n */\n\n\ngridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n  if (xAxisIndex != null && yAxisIndex != null) {\n    var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n    return this._coordsMap[key];\n  }\n\n  if (isObject(xAxisIndex)) {\n    yAxisIndex = xAxisIndex.yAxisIndex;\n    xAxisIndex = xAxisIndex.xAxisIndex;\n  } // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n\n\n  for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n    if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {\n      return coordList[i];\n    }\n  }\n};\n\ngridProto.getCartesians = function () {\n  return this._coordsList.slice();\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.convertToPixel = function (ecModel, finder, value) {\n  var target = this._findConvertTarget(ecModel, finder);\n\n  return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.convertFromPixel = function (ecModel, finder, value) {\n  var target = this._findConvertTarget(ecModel, finder);\n\n  return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;\n};\n/**\n * @inner\n */\n\n\ngridProto._findConvertTarget = function (ecModel, finder) {\n  var seriesModel = finder.seriesModel;\n  var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents('xAxis')[0];\n  var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents('yAxis')[0];\n  var gridModel = finder.gridModel;\n  var coordsList = this._coordsList;\n  var cartesian;\n  var axis;\n\n  if (seriesModel) {\n    cartesian = seriesModel.coordinateSystem;\n    indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n  } else if (xAxisModel && yAxisModel) {\n    cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n  } else if (xAxisModel) {\n    axis = this.getAxis('x', xAxisModel.componentIndex);\n  } else if (yAxisModel) {\n    axis = this.getAxis('y', yAxisModel.componentIndex);\n  } // Lowest priority.\n  else if (gridModel) {\n    var grid = gridModel.coordinateSystem;\n\n    if (grid === this) {\n      cartesian = this._coordsList[0];\n    }\n  }\n\n  return {\n    cartesian: cartesian,\n    axis: axis\n  };\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.containPoint = function (point) {\n  var coord = this._coordsList[0];\n\n  if (coord) {\n    return coord.containPoint(point);\n  }\n};\n/**\n * Initialize cartesian coordinate systems\n * @private\n */\n\n\ngridProto._initCartesian = function (gridModel, ecModel, api) {\n  var axisPositionUsed = {\n    left: false,\n    right: false,\n    top: false,\n    bottom: false\n  };\n  var axesMap = {\n    x: {},\n    y: {}\n  };\n  var axesCount = {\n    x: 0,\n    y: 0\n  }; /// Create axis\n\n  ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n  ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\n  if (!axesCount.x || !axesCount.y) {\n    // Roll back when there no either x or y axis\n    this._axesMap = {};\n    this._axesList = [];\n    return;\n  }\n\n  this._axesMap = axesMap; /// Create cartesian2d\n\n  each(axesMap.x, function (xAxis, xAxisIndex) {\n    each(axesMap.y, function (yAxis, yAxisIndex) {\n      var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n      var cartesian = new Cartesian2D(key);\n      cartesian.grid = this;\n      cartesian.model = gridModel;\n      this._coordsMap[key] = cartesian;\n\n      this._coordsList.push(cartesian);\n\n      cartesian.addAxis(xAxis);\n      cartesian.addAxis(yAxis);\n    }, this);\n  }, this);\n\n  function createAxisCreator(axisType) {\n    return function (axisModel, idx) {\n      if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n        return;\n      }\n\n      var axisPosition = axisModel.get('position');\n\n      if (axisType === 'x') {\n        // Fix position\n        if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n          // Default bottom of X\n          axisPosition = 'bottom';\n\n          if (axisPositionUsed[axisPosition]) {\n            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n          }\n        }\n      } else {\n        // Fix position\n        if (axisPosition !== 'left' && axisPosition !== 'right') {\n          // Default left of Y\n          axisPosition = 'left';\n\n          if (axisPositionUsed[axisPosition]) {\n            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n          }\n        }\n      }\n\n      axisPositionUsed[axisPosition] = true;\n      var axis = new Axis2D(axisType, createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisPosition);\n      var isCategory = axis.type === 'category';\n      axis.onBand = isCategory && axisModel.get('boundaryGap');\n      axis.inverse = axisModel.get('inverse'); // Inject axis into axisModel\n\n      axisModel.axis = axis; // Inject axisModel into axis\n\n      axis.model = axisModel; // Inject grid info axis\n\n      axis.grid = this; // Index of axis, can be used as key\n\n      axis.index = idx;\n\n      this._axesList.push(axis);\n\n      axesMap[axisType][idx] = axis;\n      axesCount[axisType]++;\n    };\n  }\n};\n/**\n * Update cartesian properties from series\n * @param  {module:echarts/model/Option} option\n * @private\n */\n\n\ngridProto._updateScale = function (ecModel, gridModel) {\n  // Reset scale\n  each(this._axesList, function (axis) {\n    axis.scale.setExtent(Infinity, -Infinity);\n  });\n  ecModel.eachSeries(function (seriesModel) {\n    if (isCartesian2D(seriesModel)) {\n      var axesModels = findAxesModels(seriesModel, ecModel);\n      var xAxisModel = axesModels[0];\n      var yAxisModel = axesModels[1];\n\n      if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)) {\n        return;\n      }\n\n      var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n      var data = seriesModel.getData();\n      var xAxis = cartesian.getAxis('x');\n      var yAxis = cartesian.getAxis('y');\n\n      if (data.type === 'list') {\n        unionExtent(data, xAxis, seriesModel);\n        unionExtent(data, yAxis, seriesModel);\n      }\n    }\n  }, this);\n\n  function unionExtent(data, axis, seriesModel) {\n    each(data.mapDimension(axis.dim, true), function (dim) {\n      axis.scale.unionExtentFromData( // For example, the extent of the orginal dimension\n      // is [0.1, 0.5], the extent of the `stackResultDimension`\n      // is [7, 9], the final extent should not include [0.1, 0.5].\n      data, getStackedDimension(data, dim));\n    });\n  }\n};\n/**\n * @param {string} [dim] 'x' or 'y' or 'auto' or null/undefined\n * @return {Object} {baseAxes: [], otherAxes: []}\n */\n\n\ngridProto.getTooltipAxes = function (dim) {\n  var baseAxes = [];\n  var otherAxes = [];\n  each(this.getCartesians(), function (cartesian) {\n    var baseAxis = dim != null && dim !== 'auto' ? cartesian.getAxis(dim) : cartesian.getBaseAxis();\n    var otherAxis = cartesian.getOtherAxis(baseAxis);\n    indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);\n    indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);\n  });\n  return {\n    baseAxes: baseAxes,\n    otherAxes: otherAxes\n  };\n};\n/**\n * @inner\n */\n\n\nfunction updateAxisTransform(axis, coordBase) {\n  var axisExtent = axis.getExtent();\n  var axisExtentSum = axisExtent[0] + axisExtent[1]; // Fast transform\n\n  axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {\n    return coord + coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n  axis.toLocalCoord = axis.dim === 'x' ? function (coord) {\n    return coord - coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n}\n\nvar axesTypes = ['xAxis', 'yAxis'];\n/**\n * @inner\n */\n\nfunction findAxesModels(seriesModel, ecModel) {\n  return map(axesTypes, function (axisType) {\n    var axisModel = seriesModel.getReferringComponents(axisType)[0];\n    return axisModel;\n  });\n}\n/**\n * @inner\n */\n\n\nfunction isCartesian2D(seriesModel) {\n  return seriesModel.get('coordinateSystem') === 'cartesian2d';\n}\n\nGrid.create = function (ecModel, api) {\n  var grids = [];\n  ecModel.eachComponent('grid', function (gridModel, idx) {\n    var grid = new Grid(gridModel, ecModel, api);\n    grid.name = 'grid_' + idx; // dataSampling requires axis extent, so resize\n    // should be performed in create stage.\n\n    grid.resize(gridModel, api, true);\n    gridModel.coordinateSystem = grid;\n    grids.push(grid);\n  }); // Inject the coordinateSystems into seriesModel\n\n  ecModel.eachSeries(function (seriesModel) {\n    if (!isCartesian2D(seriesModel)) {\n      return;\n    }\n\n    var axesModels = findAxesModels(seriesModel, ecModel);\n    var xAxisModel = axesModels[0];\n    var yAxisModel = axesModels[1];\n    var gridModel = xAxisModel.getCoordSysModel();\n    var grid = gridModel.coordinateSystem;\n    seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n  });\n  return grids;\n}; // For deciding which dimensions to use when creating list data\n\n\nGrid.dimensions = Grid.prototype.dimensions = Cartesian2D.prototype.dimensions;\nCoordinateSystem.register('cartesian2d', Grid);\nvar _default = Grid;\nmodule.exports = _default;","map":{"version":3,"names":["_config","require","__DEV__","_util","isObject","each","map","indexOf","retrieve","_layout","getLayoutRect","_axisHelper","createScaleByModel","ifAxisCrossZero","niceScaleExtent","estimateLabelUnionRect","Cartesian2D","Axis2D","CoordinateSystem","_dataStackHelper","getStackedDimension","isAxisUsedInTheGrid","axisModel","gridModel","ecModel","getCoordSysModel","Grid","api","_coordsMap","_coordsList","_axesMap","_axesList","_initCartesian","model","gridProto","prototype","type","axisPointerEnabled","getRect","_rect","update","axesMap","_updateScale","x","xAxis","scale","y","yAxis","fixAxisOnZero","resize","otherAxisDim","axis","getAxesOnZeroOf","otherAxis","otherAxes","onZero","get","onZeroAxisIndex","canOnZeroToAxis","idx","hasOwnProperty","ignoreContainLabel","gridRect","getBoxLayoutParams","width","getWidth","height","getHeight","axesList","adjustAxes","labelUnionRect","dim","isHorizontal","margin","position","extent","inverse","setExtent","updateAxisTransform","getAxis","axisType","axisIndex","axesMapOnDim","name","getAxes","slice","getCartesian","xAxisIndex","yAxisIndex","key","i","coordList","length","index","getCartesians","convertToPixel","finder","value","target","_findConvertTarget","cartesian","dataToPoint","toGlobalCoord","dataToCoord","convertFromPixel","pointToData","coordToData","toLocalCoord","seriesModel","xAxisModel","getReferringComponents","yAxisModel","coordsList","coordinateSystem","componentIndex","grid","containPoint","point","coord","axisPositionUsed","left","right","top","bottom","axesCount","eachComponent","createAxisCreator","push","addAxis","axisPosition","isCategory","onBand","Infinity","eachSeries","isCartesian2D","axesModels","findAxesModels","data","getData","unionExtent","mapDimension","unionExtentFromData","getTooltipAxes","baseAxes","baseAxis","getBaseAxis","getOtherAxis","coordBase","axisExtent","getExtent","axisExtentSum","axesTypes","create","grids","dimensions","register","_default","module","exports"],"sources":["C:/Users/W/Desktop/vue_map/node_modules/echarts/lib/coord/cartesian/Grid.js"],"sourcesContent":["var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar isObject = _util.isObject;\nvar each = _util.each;\nvar map = _util.map;\nvar indexOf = _util.indexOf;\nvar retrieve = _util.retrieve;\n\nvar _layout = require(\"../../util/layout\");\n\nvar getLayoutRect = _layout.getLayoutRect;\n\nvar _axisHelper = require(\"../../coord/axisHelper\");\n\nvar createScaleByModel = _axisHelper.createScaleByModel;\nvar ifAxisCrossZero = _axisHelper.ifAxisCrossZero;\nvar niceScaleExtent = _axisHelper.niceScaleExtent;\nvar estimateLabelUnionRect = _axisHelper.estimateLabelUnionRect;\n\nvar Cartesian2D = require(\"./Cartesian2D\");\n\nvar Axis2D = require(\"./Axis2D\");\n\nvar CoordinateSystem = require(\"../../CoordinateSystem\");\n\nvar _dataStackHelper = require(\"../../data/helper/dataStackHelper\");\n\nvar getStackedDimension = _dataStackHelper.getStackedDimension;\n\nrequire(\"./GridModel\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Grid is a region which contains at most 4 cartesian systems\n *\n * TODO Default cartesian\n */\n// Depends on GridModel, AxisModel, which performs preprocess.\n\n/**\n * Check if the axis is used in the specified grid\n * @inner\n */\nfunction isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n  return axisModel.getCoordSysModel() === gridModel;\n}\n\nfunction Grid(gridModel, ecModel, api) {\n  /**\n   * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n   * @private\n   */\n  this._coordsMap = {};\n  /**\n   * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n   * @private\n   */\n\n  this._coordsList = [];\n  /**\n   * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n   * @private\n   */\n\n  this._axesMap = {};\n  /**\n   * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n   * @private\n   */\n\n  this._axesList = [];\n\n  this._initCartesian(gridModel, ecModel, api);\n\n  this.model = gridModel;\n}\n\nvar gridProto = Grid.prototype;\ngridProto.type = 'grid';\ngridProto.axisPointerEnabled = true;\n\ngridProto.getRect = function () {\n  return this._rect;\n};\n\ngridProto.update = function (ecModel, api) {\n  var axesMap = this._axesMap;\n\n  this._updateScale(ecModel, this.model);\n\n  each(axesMap.x, function (xAxis) {\n    niceScaleExtent(xAxis.scale, xAxis.model);\n  });\n  each(axesMap.y, function (yAxis) {\n    niceScaleExtent(yAxis.scale, yAxis.model);\n  });\n  each(axesMap.x, function (xAxis) {\n    fixAxisOnZero(axesMap, 'y', xAxis);\n  });\n  each(axesMap.y, function (yAxis) {\n    fixAxisOnZero(axesMap, 'x', yAxis);\n  }); // Resize again if containLabel is enabled\n  // FIXME It may cause getting wrong grid size in data processing stage\n\n  this.resize(this.model, api);\n};\n\nfunction fixAxisOnZero(axesMap, otherAxisDim, axis) {\n  axis.getAxesOnZeroOf = function () {\n    // TODO: onZero of multiple axes.\n    return otherAxis ? [otherAxis] : [];\n  }; // onZero can not be enabled in these two situations:\n  // 1. When any other axis is a category axis.\n  // 2. When no axis is cross 0 point.\n\n\n  var otherAxes = axesMap[otherAxisDim];\n  var otherAxis;\n  var axisModel = axis.model;\n  var onZero = axisModel.get('axisLine.onZero');\n  var onZeroAxisIndex = axisModel.get('axisLine.onZeroAxisIndex');\n\n  if (!onZero) {\n    return;\n  } // If target axis is specified.\n\n\n  if (onZeroAxisIndex != null) {\n    if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {\n      otherAxis = otherAxes[onZeroAxisIndex];\n    }\n\n    return;\n  } // Find the first available other axis.\n\n\n  for (var idx in otherAxes) {\n    if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx])) {\n      otherAxis = otherAxes[idx];\n      break;\n    }\n  }\n}\n\nfunction canOnZeroToAxis(axis) {\n  return axis && axis.type !== 'category' && axis.type !== 'time' && ifAxisCrossZero(axis);\n}\n/**\n * Resize the grid\n * @param {module:echarts/coord/cartesian/GridModel} gridModel\n * @param {module:echarts/ExtensionAPI} api\n */\n\n\ngridProto.resize = function (gridModel, api, ignoreContainLabel) {\n  var gridRect = getLayoutRect(gridModel.getBoxLayoutParams(), {\n    width: api.getWidth(),\n    height: api.getHeight()\n  });\n  this._rect = gridRect;\n  var axesList = this._axesList;\n  adjustAxes(); // Minus label size\n\n  if (!ignoreContainLabel && gridModel.get('containLabel')) {\n    each(axesList, function (axis) {\n      if (!axis.model.get('axisLabel.inside')) {\n        var labelUnionRect = estimateLabelUnionRect(axis);\n\n        if (labelUnionRect) {\n          var dim = axis.isHorizontal() ? 'height' : 'width';\n          var margin = axis.model.get('axisLabel.margin');\n          gridRect[dim] -= labelUnionRect[dim] + margin;\n\n          if (axis.position === 'top') {\n            gridRect.y += labelUnionRect.height + margin;\n          } else if (axis.position === 'left') {\n            gridRect.x += labelUnionRect.width + margin;\n          }\n        }\n      }\n    });\n    adjustAxes();\n  }\n\n  function adjustAxes() {\n    each(axesList, function (axis) {\n      var isHorizontal = axis.isHorizontal();\n      var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n      var idx = axis.inverse ? 1 : 0;\n      axis.setExtent(extent[idx], extent[1 - idx]);\n      updateAxisTransform(axis, isHorizontal ? gridRect.x : gridRect.y);\n    });\n  }\n};\n/**\n * @param {string} axisType\n * @param {number} [axisIndex]\n */\n\n\ngridProto.getAxis = function (axisType, axisIndex) {\n  var axesMapOnDim = this._axesMap[axisType];\n\n  if (axesMapOnDim != null) {\n    if (axisIndex == null) {\n      // Find first axis\n      for (var name in axesMapOnDim) {\n        if (axesMapOnDim.hasOwnProperty(name)) {\n          return axesMapOnDim[name];\n        }\n      }\n    }\n\n    return axesMapOnDim[axisIndex];\n  }\n};\n/**\n * @return {Array.<module:echarts/coord/Axis>}\n */\n\n\ngridProto.getAxes = function () {\n  return this._axesList.slice();\n};\n/**\n * Usage:\n *      grid.getCartesian(xAxisIndex, yAxisIndex);\n *      grid.getCartesian(xAxisIndex);\n *      grid.getCartesian(null, yAxisIndex);\n *      grid.getCartesian({xAxisIndex: ..., yAxisIndex: ...});\n *\n * @param {number|Object} [xAxisIndex]\n * @param {number} [yAxisIndex]\n */\n\n\ngridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n  if (xAxisIndex != null && yAxisIndex != null) {\n    var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n    return this._coordsMap[key];\n  }\n\n  if (isObject(xAxisIndex)) {\n    yAxisIndex = xAxisIndex.yAxisIndex;\n    xAxisIndex = xAxisIndex.xAxisIndex;\n  } // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n\n\n  for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n    if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {\n      return coordList[i];\n    }\n  }\n};\n\ngridProto.getCartesians = function () {\n  return this._coordsList.slice();\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.convertToPixel = function (ecModel, finder, value) {\n  var target = this._findConvertTarget(ecModel, finder);\n\n  return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.convertFromPixel = function (ecModel, finder, value) {\n  var target = this._findConvertTarget(ecModel, finder);\n\n  return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;\n};\n/**\n * @inner\n */\n\n\ngridProto._findConvertTarget = function (ecModel, finder) {\n  var seriesModel = finder.seriesModel;\n  var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents('xAxis')[0];\n  var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents('yAxis')[0];\n  var gridModel = finder.gridModel;\n  var coordsList = this._coordsList;\n  var cartesian;\n  var axis;\n\n  if (seriesModel) {\n    cartesian = seriesModel.coordinateSystem;\n    indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n  } else if (xAxisModel && yAxisModel) {\n    cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n  } else if (xAxisModel) {\n    axis = this.getAxis('x', xAxisModel.componentIndex);\n  } else if (yAxisModel) {\n    axis = this.getAxis('y', yAxisModel.componentIndex);\n  } // Lowest priority.\n  else if (gridModel) {\n      var grid = gridModel.coordinateSystem;\n\n      if (grid === this) {\n        cartesian = this._coordsList[0];\n      }\n    }\n\n  return {\n    cartesian: cartesian,\n    axis: axis\n  };\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.containPoint = function (point) {\n  var coord = this._coordsList[0];\n\n  if (coord) {\n    return coord.containPoint(point);\n  }\n};\n/**\n * Initialize cartesian coordinate systems\n * @private\n */\n\n\ngridProto._initCartesian = function (gridModel, ecModel, api) {\n  var axisPositionUsed = {\n    left: false,\n    right: false,\n    top: false,\n    bottom: false\n  };\n  var axesMap = {\n    x: {},\n    y: {}\n  };\n  var axesCount = {\n    x: 0,\n    y: 0\n  }; /// Create axis\n\n  ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n  ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\n  if (!axesCount.x || !axesCount.y) {\n    // Roll back when there no either x or y axis\n    this._axesMap = {};\n    this._axesList = [];\n    return;\n  }\n\n  this._axesMap = axesMap; /// Create cartesian2d\n\n  each(axesMap.x, function (xAxis, xAxisIndex) {\n    each(axesMap.y, function (yAxis, yAxisIndex) {\n      var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n      var cartesian = new Cartesian2D(key);\n      cartesian.grid = this;\n      cartesian.model = gridModel;\n      this._coordsMap[key] = cartesian;\n\n      this._coordsList.push(cartesian);\n\n      cartesian.addAxis(xAxis);\n      cartesian.addAxis(yAxis);\n    }, this);\n  }, this);\n\n  function createAxisCreator(axisType) {\n    return function (axisModel, idx) {\n      if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n        return;\n      }\n\n      var axisPosition = axisModel.get('position');\n\n      if (axisType === 'x') {\n        // Fix position\n        if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n          // Default bottom of X\n          axisPosition = 'bottom';\n\n          if (axisPositionUsed[axisPosition]) {\n            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n          }\n        }\n      } else {\n        // Fix position\n        if (axisPosition !== 'left' && axisPosition !== 'right') {\n          // Default left of Y\n          axisPosition = 'left';\n\n          if (axisPositionUsed[axisPosition]) {\n            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n          }\n        }\n      }\n\n      axisPositionUsed[axisPosition] = true;\n      var axis = new Axis2D(axisType, createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisPosition);\n      var isCategory = axis.type === 'category';\n      axis.onBand = isCategory && axisModel.get('boundaryGap');\n      axis.inverse = axisModel.get('inverse'); // Inject axis into axisModel\n\n      axisModel.axis = axis; // Inject axisModel into axis\n\n      axis.model = axisModel; // Inject grid info axis\n\n      axis.grid = this; // Index of axis, can be used as key\n\n      axis.index = idx;\n\n      this._axesList.push(axis);\n\n      axesMap[axisType][idx] = axis;\n      axesCount[axisType]++;\n    };\n  }\n};\n/**\n * Update cartesian properties from series\n * @param  {module:echarts/model/Option} option\n * @private\n */\n\n\ngridProto._updateScale = function (ecModel, gridModel) {\n  // Reset scale\n  each(this._axesList, function (axis) {\n    axis.scale.setExtent(Infinity, -Infinity);\n  });\n  ecModel.eachSeries(function (seriesModel) {\n    if (isCartesian2D(seriesModel)) {\n      var axesModels = findAxesModels(seriesModel, ecModel);\n      var xAxisModel = axesModels[0];\n      var yAxisModel = axesModels[1];\n\n      if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)) {\n        return;\n      }\n\n      var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n      var data = seriesModel.getData();\n      var xAxis = cartesian.getAxis('x');\n      var yAxis = cartesian.getAxis('y');\n\n      if (data.type === 'list') {\n        unionExtent(data, xAxis, seriesModel);\n        unionExtent(data, yAxis, seriesModel);\n      }\n    }\n  }, this);\n\n  function unionExtent(data, axis, seriesModel) {\n    each(data.mapDimension(axis.dim, true), function (dim) {\n      axis.scale.unionExtentFromData( // For example, the extent of the orginal dimension\n      // is [0.1, 0.5], the extent of the `stackResultDimension`\n      // is [7, 9], the final extent should not include [0.1, 0.5].\n      data, getStackedDimension(data, dim));\n    });\n  }\n};\n/**\n * @param {string} [dim] 'x' or 'y' or 'auto' or null/undefined\n * @return {Object} {baseAxes: [], otherAxes: []}\n */\n\n\ngridProto.getTooltipAxes = function (dim) {\n  var baseAxes = [];\n  var otherAxes = [];\n  each(this.getCartesians(), function (cartesian) {\n    var baseAxis = dim != null && dim !== 'auto' ? cartesian.getAxis(dim) : cartesian.getBaseAxis();\n    var otherAxis = cartesian.getOtherAxis(baseAxis);\n    indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);\n    indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);\n  });\n  return {\n    baseAxes: baseAxes,\n    otherAxes: otherAxes\n  };\n};\n/**\n * @inner\n */\n\n\nfunction updateAxisTransform(axis, coordBase) {\n  var axisExtent = axis.getExtent();\n  var axisExtentSum = axisExtent[0] + axisExtent[1]; // Fast transform\n\n  axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {\n    return coord + coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n  axis.toLocalCoord = axis.dim === 'x' ? function (coord) {\n    return coord - coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n}\n\nvar axesTypes = ['xAxis', 'yAxis'];\n/**\n * @inner\n */\n\nfunction findAxesModels(seriesModel, ecModel) {\n  return map(axesTypes, function (axisType) {\n    var axisModel = seriesModel.getReferringComponents(axisType)[0];\n    return axisModel;\n  });\n}\n/**\n * @inner\n */\n\n\nfunction isCartesian2D(seriesModel) {\n  return seriesModel.get('coordinateSystem') === 'cartesian2d';\n}\n\nGrid.create = function (ecModel, api) {\n  var grids = [];\n  ecModel.eachComponent('grid', function (gridModel, idx) {\n    var grid = new Grid(gridModel, ecModel, api);\n    grid.name = 'grid_' + idx; // dataSampling requires axis extent, so resize\n    // should be performed in create stage.\n\n    grid.resize(gridModel, api, true);\n    gridModel.coordinateSystem = grid;\n    grids.push(grid);\n  }); // Inject the coordinateSystems into seriesModel\n\n  ecModel.eachSeries(function (seriesModel) {\n    if (!isCartesian2D(seriesModel)) {\n      return;\n    }\n\n    var axesModels = findAxesModels(seriesModel, ecModel);\n    var xAxisModel = axesModels[0];\n    var yAxisModel = axesModels[1];\n    var gridModel = xAxisModel.getCoordSysModel();\n    var grid = gridModel.coordinateSystem;\n    seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n  });\n  return grids;\n}; // For deciding which dimensions to use when creating list data\n\n\nGrid.dimensions = Grid.prototype.dimensions = Cartesian2D.prototype.dimensions;\nCoordinateSystem.register('cartesian2d', Grid);\nvar _default = Grid;\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}