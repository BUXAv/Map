{"ast":null,"code":"var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar Eventful = require(\"zrender/lib/mixin/Eventful\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar interactionMutex = require(\"./interactionMutex\");\n\nvar DataDiffer = require(\"../../data/DataDiffer\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\nvar curry = zrUtil.curry;\nvar each = zrUtil.each;\nvar map = zrUtil.map;\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathPow = Math.pow;\nvar COVER_Z = 10000;\nvar UNSELECT_THRESHOLD = 6;\nvar MIN_RESIZE_LINE_WIDTH = 6;\nvar MUTEX_RESOURCE_KEY = 'globalPan';\nvar DIRECTION_MAP = {\n  w: [0, 0],\n  e: [0, 1],\n  n: [1, 0],\n  s: [1, 1]\n};\nvar CURSOR_MAP = {\n  w: 'ew',\n  e: 'ew',\n  n: 'ns',\n  s: 'ns',\n  ne: 'nesw',\n  sw: 'nesw',\n  nw: 'nwse',\n  se: 'nwse'\n};\nvar DEFAULT_BRUSH_OPT = {\n  brushStyle: {\n    lineWidth: 2,\n    stroke: 'rgba(0,0,0,0.3)',\n    fill: 'rgba(0,0,0,0.1)'\n  },\n  transformable: true,\n  brushMode: 'single',\n  removeOnClick: false\n};\nvar baseUID = 0;\n/**\n * @alias module:echarts/component/helper/BrushController\n * @constructor\n * @mixin {module:zrender/mixin/Eventful}\n * @event module:echarts/component/helper/BrushController#brush\n *        params:\n *            areas: Array.<Array>, coord relates to container group,\n *                                    If no container specified, to global.\n *            opt {\n *                isEnd: boolean,\n *                removeOnClick: boolean\n *            }\n *\n * @param {module:zrender/zrender~ZRender} zr\n */\n\nfunction BrushController(zr) {\n  Eventful.call(this);\n  /**\n   * @type {module:zrender/zrender~ZRender}\n   * @private\n   */\n\n  this._zr = zr;\n  /**\n   * @type {module:zrender/container/Group}\n   * @readOnly\n   */\n\n  this.group = new graphic.Group();\n  /**\n   * Only for drawing (after enabledBrush).\n   *     'line', 'rect', 'polygon' or false\n   *     If passing false/null/undefined, disable brush.\n   *     If passing 'auto', determined by panel.defaultBrushType\n   * @private\n   * @type {string}\n   */\n\n  this._brushType;\n  /**\n   * Only for drawing (after enabledBrush).\n   *\n   * @private\n   * @type {Object}\n   */\n\n  this._brushOption;\n  /**\n   * @private\n   * @type {Object}\n   */\n\n  this._panels;\n  /**\n   * @private\n   * @type {Array.<nubmer>}\n   */\n\n  this._track = [];\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this._dragging;\n  /**\n   * @private\n   * @type {Array}\n   */\n\n  this._covers = [];\n  /**\n   * @private\n   * @type {moudule:zrender/container/Group}\n   */\n\n  this._creatingCover;\n  /**\n   * `true` means global panel\n   * @private\n   * @type {module:zrender/container/Group|boolean}\n   */\n\n  this._creatingPanel;\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this._enableGlobalPan;\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  /**\n   * @private\n   * @type {string}\n   */\n\n  this._uid = 'brushController_' + baseUID++;\n  /**\n   * @private\n   * @type {Object}\n   */\n\n  this._handlers = {};\n  each(mouseHandlers, function (handler, eventName) {\n    this._handlers[eventName] = zrUtil.bind(handler, this);\n  }, this);\n}\n\nBrushController.prototype = {\n  constructor: BrushController,\n\n  /**\n   * If set to null/undefined/false, select disabled.\n   * @param {Object} brushOption\n   * @param {string|boolean} brushOption.brushType 'line', 'rect', 'polygon' or false\n   *                          If passing false/null/undefined, disable brush.\n   *                          If passing 'auto', determined by panel.defaultBrushType.\n   *                              ('auto' can not be used in global panel)\n   * @param {number} [brushOption.brushMode='single'] 'single' or 'multiple'\n   * @param {boolean} [brushOption.transformable=true]\n   * @param {boolean} [brushOption.removeOnClick=false]\n   * @param {Object} [brushOption.brushStyle]\n   * @param {number} [brushOption.brushStyle.width]\n   * @param {number} [brushOption.brushStyle.lineWidth]\n   * @param {string} [brushOption.brushStyle.stroke]\n   * @param {string} [brushOption.brushStyle.fill]\n   * @param {number} [brushOption.z]\n   */\n  enableBrush: function (brushOption) {\n    this._brushType && doDisableBrush(this);\n    brushOption.brushType && doEnableBrush(this, brushOption);\n    return this;\n  },\n\n  /**\n   * @param {Array.<Object>} panelOpts If not pass, it is global brush.\n   *        Each items: {\n   *            panelId, // mandatory.\n   *            clipPath, // mandatory. function.\n   *            isTargetByCursor, // mandatory. function.\n   *            defaultBrushType, // optional, only used when brushType is 'auto'.\n   *            getLinearBrushOtherExtent, // optional. function.\n   *        }\n   */\n  setPanels: function (panelOpts) {\n    if (panelOpts && panelOpts.length) {\n      var panels = this._panels = {};\n      zrUtil.each(panelOpts, function (panelOpts) {\n        panels[panelOpts.panelId] = zrUtil.clone(panelOpts);\n      });\n    } else {\n      this._panels = null;\n    }\n\n    return this;\n  },\n\n  /**\n   * @param {Object} [opt]\n   * @return {boolean} [opt.enableGlobalPan=false]\n   */\n  mount: function (opt) {\n    opt = opt || {};\n    this._enableGlobalPan = opt.enableGlobalPan;\n    var thisGroup = this.group;\n\n    this._zr.add(thisGroup);\n\n    thisGroup.attr({\n      position: opt.position || [0, 0],\n      rotation: opt.rotation || 0,\n      scale: opt.scale || [1, 1]\n    });\n    this._transform = thisGroup.getLocalTransform();\n    return this;\n  },\n  eachCover: function (cb, context) {\n    each(this._covers, cb, context);\n  },\n\n  /**\n   * Update covers.\n   * @param {Array.<Object>} brushOptionList Like:\n   *        [\n   *            {id: 'xx', brushType: 'line', range: [23, 44], brushStyle, transformable},\n   *            {id: 'yy', brushType: 'rect', range: [[23, 44], [23, 54]]},\n   *            ...\n   *        ]\n   *        `brushType` is required in each cover info. (can not be 'auto')\n   *        `id` is not mandatory.\n   *        `brushStyle`, `transformable` is not mandatory, use DEFAULT_BRUSH_OPT by default.\n   *        If brushOptionList is null/undefined, all covers removed.\n   */\n  updateCovers: function (brushOptionList) {\n    brushOptionList = zrUtil.map(brushOptionList, function (brushOption) {\n      return zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);\n    });\n    var tmpIdPrefix = '\\0-brush-index-';\n    var oldCovers = this._covers;\n    var newCovers = this._covers = [];\n    var controller = this;\n    var creatingCover = this._creatingCover;\n    new DataDiffer(oldCovers, brushOptionList, oldGetKey, getKey).add(addOrUpdate).update(addOrUpdate).remove(remove).execute();\n    return this;\n\n    function getKey(brushOption, index) {\n      return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index) + '-' + brushOption.brushType;\n    }\n\n    function oldGetKey(cover, index) {\n      return getKey(cover.__brushOption, index);\n    }\n\n    function addOrUpdate(newIndex, oldIndex) {\n      var newBrushOption = brushOptionList[newIndex]; // Consider setOption in event listener of brushSelect,\n      // where updating cover when creating should be forbiden.\n\n      if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {\n        newCovers[newIndex] = oldCovers[oldIndex];\n      } else {\n        var cover = newCovers[newIndex] = oldIndex != null ? (oldCovers[oldIndex].__brushOption = newBrushOption, oldCovers[oldIndex]) : endCreating(controller, createCover(controller, newBrushOption));\n        updateCoverAfterCreation(controller, cover);\n      }\n    }\n\n    function remove(oldIndex) {\n      if (oldCovers[oldIndex] !== creatingCover) {\n        controller.group.remove(oldCovers[oldIndex]);\n      }\n    }\n  },\n  unmount: function () {\n    this.enableBrush(false); // container may 'removeAll' outside.\n\n    clearCovers(this);\n\n    this._zr.remove(this.group);\n\n    return this;\n  },\n  dispose: function () {\n    this.unmount();\n    this.off();\n  }\n};\nzrUtil.mixin(BrushController, Eventful);\n\nfunction doEnableBrush(controller, brushOption) {\n  var zr = controller._zr; // Consider roam, which takes globalPan too.\n\n  if (!controller._enableGlobalPan) {\n    interactionMutex.take(zr, MUTEX_RESOURCE_KEY, controller._uid);\n  }\n\n  each(controller._handlers, function (handler, eventName) {\n    zr.on(eventName, handler);\n  });\n  controller._brushType = brushOption.brushType;\n  controller._brushOption = zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);\n}\n\nfunction doDisableBrush(controller) {\n  var zr = controller._zr;\n  interactionMutex.release(zr, MUTEX_RESOURCE_KEY, controller._uid);\n  each(controller._handlers, function (handler, eventName) {\n    zr.off(eventName, handler);\n  });\n  controller._brushType = controller._brushOption = null;\n}\n\nfunction createCover(controller, brushOption) {\n  var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);\n  cover.__brushOption = brushOption;\n  updateZ(cover, brushOption);\n  controller.group.add(cover);\n  return cover;\n}\n\nfunction endCreating(controller, creatingCover) {\n  var coverRenderer = getCoverRenderer(creatingCover);\n\n  if (coverRenderer.endCreating) {\n    coverRenderer.endCreating(controller, creatingCover);\n    updateZ(creatingCover, creatingCover.__brushOption);\n  }\n\n  return creatingCover;\n}\n\nfunction updateCoverShape(controller, cover) {\n  var brushOption = cover.__brushOption;\n  getCoverRenderer(cover).updateCoverShape(controller, cover, brushOption.range, brushOption);\n}\n\nfunction updateZ(cover, brushOption) {\n  var z = brushOption.z;\n  z == null && (z = COVER_Z);\n  cover.traverse(function (el) {\n    el.z = z;\n    el.z2 = z; // Consider in given container.\n  });\n}\n\nfunction updateCoverAfterCreation(controller, cover) {\n  getCoverRenderer(cover).updateCommon(controller, cover);\n  updateCoverShape(controller, cover);\n}\n\nfunction getCoverRenderer(cover) {\n  return coverRenderers[cover.__brushOption.brushType];\n} // return target panel or `true` (means global panel)\n\n\nfunction getPanelByPoint(controller, e, localCursorPoint) {\n  var panels = controller._panels;\n\n  if (!panels) {\n    return true; // Global panel\n  }\n\n  var panel;\n  var transform = controller._transform;\n  each(panels, function (pn) {\n    pn.isTargetByCursor(e, localCursorPoint, transform) && (panel = pn);\n  });\n  return panel;\n} // Return a panel or true\n\n\nfunction getPanelByCover(controller, cover) {\n  var panels = controller._panels;\n\n  if (!panels) {\n    return true; // Global panel\n  }\n\n  var panelId = cover.__brushOption.panelId; // User may give cover without coord sys info,\n  // which is then treated as global panel.\n\n  return panelId != null ? panels[panelId] : true;\n}\n\nfunction clearCovers(controller) {\n  var covers = controller._covers;\n  var originalLength = covers.length;\n  each(covers, function (cover) {\n    controller.group.remove(cover);\n  }, controller);\n  covers.length = 0;\n  return !!originalLength;\n}\n\nfunction trigger(controller, opt) {\n  var areas = map(controller._covers, function (cover) {\n    var brushOption = cover.__brushOption;\n    var range = zrUtil.clone(brushOption.range);\n    return {\n      brushType: brushOption.brushType,\n      panelId: brushOption.panelId,\n      range: range\n    };\n  });\n  controller.trigger('brush', areas, {\n    isEnd: !!opt.isEnd,\n    removeOnClick: !!opt.removeOnClick\n  });\n}\n\nfunction shouldShowCover(controller) {\n  var track = controller._track;\n\n  if (!track.length) {\n    return false;\n  }\n\n  var p2 = track[track.length - 1];\n  var p1 = track[0];\n  var dx = p2[0] - p1[0];\n  var dy = p2[1] - p1[1];\n  var dist = mathPow(dx * dx + dy * dy, 0.5);\n  return dist > UNSELECT_THRESHOLD;\n}\n\nfunction getTrackEnds(track) {\n  var tail = track.length - 1;\n  tail < 0 && (tail = 0);\n  return [track[0], track[tail]];\n}\n\nfunction createBaseRectCover(doDrift, controller, brushOption, edgeNames) {\n  var cover = new graphic.Group();\n  cover.add(new graphic.Rect({\n    name: 'main',\n    style: makeStyle(brushOption),\n    silent: true,\n    draggable: true,\n    cursor: 'move',\n    drift: curry(doDrift, controller, cover, 'nswe'),\n    ondragend: curry(trigger, controller, {\n      isEnd: true\n    })\n  }));\n  each(edgeNames, function (name) {\n    cover.add(new graphic.Rect({\n      name: name,\n      style: {\n        opacity: 0\n      },\n      draggable: true,\n      silent: true,\n      invisible: true,\n      drift: curry(doDrift, controller, cover, name),\n      ondragend: curry(trigger, controller, {\n        isEnd: true\n      })\n    }));\n  });\n  return cover;\n}\n\nfunction updateBaseRect(controller, cover, localRange, brushOption) {\n  var lineWidth = brushOption.brushStyle.lineWidth || 0;\n  var handleSize = mathMax(lineWidth, MIN_RESIZE_LINE_WIDTH);\n  var x = localRange[0][0];\n  var y = localRange[1][0];\n  var xa = x - lineWidth / 2;\n  var ya = y - lineWidth / 2;\n  var x2 = localRange[0][1];\n  var y2 = localRange[1][1];\n  var x2a = x2 - handleSize + lineWidth / 2;\n  var y2a = y2 - handleSize + lineWidth / 2;\n  var width = x2 - x;\n  var height = y2 - y;\n  var widtha = width + lineWidth;\n  var heighta = height + lineWidth;\n  updateRectShape(controller, cover, 'main', x, y, width, height);\n\n  if (brushOption.transformable) {\n    updateRectShape(controller, cover, 'w', xa, ya, handleSize, heighta);\n    updateRectShape(controller, cover, 'e', x2a, ya, handleSize, heighta);\n    updateRectShape(controller, cover, 'n', xa, ya, widtha, handleSize);\n    updateRectShape(controller, cover, 's', xa, y2a, widtha, handleSize);\n    updateRectShape(controller, cover, 'nw', xa, ya, handleSize, handleSize);\n    updateRectShape(controller, cover, 'ne', x2a, ya, handleSize, handleSize);\n    updateRectShape(controller, cover, 'sw', xa, y2a, handleSize, handleSize);\n    updateRectShape(controller, cover, 'se', x2a, y2a, handleSize, handleSize);\n  }\n}\n\nfunction updateCommon(controller, cover) {\n  var brushOption = cover.__brushOption;\n  var transformable = brushOption.transformable;\n  var mainEl = cover.childAt(0);\n  mainEl.useStyle(makeStyle(brushOption));\n  mainEl.attr({\n    silent: !transformable,\n    cursor: transformable ? 'move' : 'default'\n  });\n  each(['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw'], function (name) {\n    var el = cover.childOfName(name);\n    var globalDir = getGlobalDirection(controller, name);\n    el && el.attr({\n      silent: !transformable,\n      invisible: !transformable,\n      cursor: transformable ? CURSOR_MAP[globalDir] + '-resize' : null\n    });\n  });\n}\n\nfunction updateRectShape(controller, cover, name, x, y, w, h) {\n  var el = cover.childOfName(name);\n  el && el.setShape(pointsToRect(clipByPanel(controller, cover, [[x, y], [x + w, y + h]])));\n}\n\nfunction makeStyle(brushOption) {\n  return zrUtil.defaults({\n    strokeNoScale: true\n  }, brushOption.brushStyle);\n}\n\nfunction formatRectRange(x, y, x2, y2) {\n  var min = [mathMin(x, x2), mathMin(y, y2)];\n  var max = [mathMax(x, x2), mathMax(y, y2)];\n  return [[min[0], max[0]], // x range\n  [min[1], max[1]] // y range\n  ];\n}\n\nfunction getTransform(controller) {\n  return graphic.getTransform(controller.group);\n}\n\nfunction getGlobalDirection(controller, localDirection) {\n  if (localDirection.length > 1) {\n    localDirection = localDirection.split('');\n    var globalDir = [getGlobalDirection(controller, localDirection[0]), getGlobalDirection(controller, localDirection[1])];\n    (globalDir[0] === 'e' || globalDir[0] === 'w') && globalDir.reverse();\n    return globalDir.join('');\n  } else {\n    var map = {\n      w: 'left',\n      e: 'right',\n      n: 'top',\n      s: 'bottom'\n    };\n    var inverseMap = {\n      left: 'w',\n      right: 'e',\n      top: 'n',\n      bottom: 's'\n    };\n    var globalDir = graphic.transformDirection(map[localDirection], getTransform(controller));\n    return inverseMap[globalDir];\n  }\n}\n\nfunction driftRect(toRectRange, fromRectRange, controller, cover, name, dx, dy, e) {\n  var brushOption = cover.__brushOption;\n  var rectRange = toRectRange(brushOption.range);\n  var localDelta = toLocalDelta(controller, dx, dy);\n  each(name.split(''), function (namePart) {\n    var ind = DIRECTION_MAP[namePart];\n    rectRange[ind[0]][ind[1]] += localDelta[ind[0]];\n  });\n  brushOption.range = fromRectRange(formatRectRange(rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]));\n  updateCoverAfterCreation(controller, cover);\n  trigger(controller, {\n    isEnd: false\n  });\n}\n\nfunction driftPolygon(controller, cover, dx, dy, e) {\n  var range = cover.__brushOption.range;\n  var localDelta = toLocalDelta(controller, dx, dy);\n  each(range, function (point) {\n    point[0] += localDelta[0];\n    point[1] += localDelta[1];\n  });\n  updateCoverAfterCreation(controller, cover);\n  trigger(controller, {\n    isEnd: false\n  });\n}\n\nfunction toLocalDelta(controller, dx, dy) {\n  var thisGroup = controller.group;\n  var localD = thisGroup.transformCoordToLocal(dx, dy);\n  var localZero = thisGroup.transformCoordToLocal(0, 0);\n  return [localD[0] - localZero[0], localD[1] - localZero[1]];\n}\n\nfunction clipByPanel(controller, cover, data) {\n  var panel = getPanelByCover(controller, cover);\n  return panel && panel !== true ? panel.clipPath(data, controller._transform) : zrUtil.clone(data);\n}\n\nfunction pointsToRect(points) {\n  var xmin = mathMin(points[0][0], points[1][0]);\n  var ymin = mathMin(points[0][1], points[1][1]);\n  var xmax = mathMax(points[0][0], points[1][0]);\n  var ymax = mathMax(points[0][1], points[1][1]);\n  return {\n    x: xmin,\n    y: ymin,\n    width: xmax - xmin,\n    height: ymax - ymin\n  };\n}\n\nfunction resetCursor(controller, e, localCursorPoint) {\n  // Check active\n  if (!controller._brushType) {\n    return;\n  }\n\n  var zr = controller._zr;\n  var covers = controller._covers;\n  var currPanel = getPanelByPoint(controller, e, localCursorPoint); // Check whether in covers.\n\n  if (!controller._dragging) {\n    for (var i = 0; i < covers.length; i++) {\n      var brushOption = covers[i].__brushOption;\n\n      if (currPanel && (currPanel === true || brushOption.panelId === currPanel.panelId) && coverRenderers[brushOption.brushType].contain(covers[i], localCursorPoint[0], localCursorPoint[1])) {\n        // Use cursor style set on cover.\n        return;\n      }\n    }\n  }\n\n  currPanel && zr.setCursorStyle('crosshair');\n}\n\nfunction preventDefault(e) {\n  var rawE = e.event;\n  rawE.preventDefault && rawE.preventDefault();\n}\n\nfunction mainShapeContain(cover, x, y) {\n  return cover.childOfName('main').contain(x, y);\n}\n\nfunction updateCoverByMouse(controller, e, localCursorPoint, isEnd) {\n  var creatingCover = controller._creatingCover;\n  var panel = controller._creatingPanel;\n  var thisBrushOption = controller._brushOption;\n  var eventParams;\n\n  controller._track.push(localCursorPoint.slice());\n\n  if (shouldShowCover(controller) || creatingCover) {\n    if (panel && !creatingCover) {\n      thisBrushOption.brushMode === 'single' && clearCovers(controller);\n      var brushOption = zrUtil.clone(thisBrushOption);\n      brushOption.brushType = determineBrushType(brushOption.brushType, panel);\n      brushOption.panelId = panel === true ? null : panel.panelId;\n      creatingCover = controller._creatingCover = createCover(controller, brushOption);\n\n      controller._covers.push(creatingCover);\n    }\n\n    if (creatingCover) {\n      var coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)];\n      var coverBrushOption = creatingCover.__brushOption;\n      coverBrushOption.range = coverRenderer.getCreatingRange(clipByPanel(controller, creatingCover, controller._track));\n\n      if (isEnd) {\n        endCreating(controller, creatingCover);\n        coverRenderer.updateCommon(controller, creatingCover);\n      }\n\n      updateCoverShape(controller, creatingCover);\n      eventParams = {\n        isEnd: isEnd\n      };\n    }\n  } else if (isEnd && thisBrushOption.brushMode === 'single' && thisBrushOption.removeOnClick) {\n    // Help user to remove covers easily, only by a tiny drag, in 'single' mode.\n    // But a single click do not clear covers, because user may have casual\n    // clicks (for example, click on other component and do not expect covers\n    // disappear).\n    // Only some cover removed, trigger action, but not every click trigger action.\n    if (getPanelByPoint(controller, e, localCursorPoint) && clearCovers(controller)) {\n      eventParams = {\n        isEnd: isEnd,\n        removeOnClick: true\n      };\n    }\n  }\n\n  return eventParams;\n}\n\nfunction determineBrushType(brushType, panel) {\n  if (brushType === 'auto') {\n    return panel.defaultBrushType;\n  }\n\n  return brushType;\n}\n\nvar mouseHandlers = {\n  mousedown: function (e) {\n    if (this._dragging) {\n      // In case some browser do not support globalOut,\n      // and release mose out side the browser.\n      handleDragEnd.call(this, e);\n    } else if (!e.target || !e.target.draggable) {\n      preventDefault(e);\n      var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n      this._creatingCover = null;\n      var panel = this._creatingPanel = getPanelByPoint(this, e, localCursorPoint);\n\n      if (panel) {\n        this._dragging = true;\n        this._track = [localCursorPoint.slice()];\n      }\n    }\n  },\n  mousemove: function (e) {\n    var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n    resetCursor(this, e, localCursorPoint);\n\n    if (this._dragging) {\n      preventDefault(e);\n      var eventParams = updateCoverByMouse(this, e, localCursorPoint, false);\n      eventParams && trigger(this, eventParams);\n    }\n  },\n  mouseup: handleDragEnd //,\n  // FIXME\n  // in tooltip, globalout should not be triggered.\n  // globalout: handleDragEnd\n\n};\n\nfunction handleDragEnd(e) {\n  if (this._dragging) {\n    preventDefault(e);\n    var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n    var eventParams = updateCoverByMouse(this, e, localCursorPoint, true);\n    this._dragging = false;\n    this._track = [];\n    this._creatingCover = null; // trigger event shoule be at final, after procedure will be nested.\n\n    eventParams && trigger(this, eventParams);\n  }\n}\n/**\n * key: brushType\n * @type {Object}\n */\n\n\nvar coverRenderers = {\n  lineX: getLineRenderer(0),\n  lineY: getLineRenderer(1),\n  rect: {\n    createCover: function (controller, brushOption) {\n      return createBaseRectCover(curry(driftRect, function (range) {\n        return range;\n      }, function (range) {\n        return range;\n      }), controller, brushOption, ['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw']);\n    },\n    getCreatingRange: function (localTrack) {\n      var ends = getTrackEnds(localTrack);\n      return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      updateBaseRect(controller, cover, localRange, brushOption);\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  },\n  polygon: {\n    createCover: function (controller, brushOption) {\n      var cover = new graphic.Group(); // Do not use graphic.Polygon because graphic.Polyline do not close the\n      // border of the shape when drawing, which is a better experience for user.\n\n      cover.add(new graphic.Polyline({\n        name: 'main',\n        style: makeStyle(brushOption),\n        silent: true\n      }));\n      return cover;\n    },\n    getCreatingRange: function (localTrack) {\n      return localTrack;\n    },\n    endCreating: function (controller, cover) {\n      cover.remove(cover.childAt(0)); // Use graphic.Polygon close the shape.\n\n      cover.add(new graphic.Polygon({\n        name: 'main',\n        draggable: true,\n        drift: curry(driftPolygon, controller, cover),\n        ondragend: curry(trigger, controller, {\n          isEnd: true\n        })\n      }));\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      cover.childAt(0).setShape({\n        points: clipByPanel(controller, cover, localRange)\n      });\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  }\n};\n\nfunction getLineRenderer(xyIndex) {\n  return {\n    createCover: function (controller, brushOption) {\n      return createBaseRectCover(curry(driftRect, function (range) {\n        var rectRange = [range, [0, 100]];\n        xyIndex && rectRange.reverse();\n        return rectRange;\n      }, function (rectRange) {\n        return rectRange[xyIndex];\n      }), controller, brushOption, [['w', 'e'], ['n', 's']][xyIndex]);\n    },\n    getCreatingRange: function (localTrack) {\n      var ends = getTrackEnds(localTrack);\n      var min = mathMin(ends[0][xyIndex], ends[1][xyIndex]);\n      var max = mathMax(ends[0][xyIndex], ends[1][xyIndex]);\n      return [min, max];\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      var otherExtent; // If brushWidth not specified, fit the panel.\n\n      var panel = getPanelByCover(controller, cover);\n\n      if (panel !== true && panel.getLinearBrushOtherExtent) {\n        otherExtent = panel.getLinearBrushOtherExtent(xyIndex, controller._transform);\n      } else {\n        var zr = controller._zr;\n        otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]];\n      }\n\n      var rectRange = [localRange, otherExtent];\n      xyIndex && rectRange.reverse();\n      updateBaseRect(controller, cover, rectRange, brushOption);\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  };\n}\n\nvar _default = BrushController;\nmodule.exports = _default;","map":{"version":3,"names":["_config","require","__DEV__","zrUtil","Eventful","graphic","interactionMutex","DataDiffer","curry","each","map","mathMin","Math","min","mathMax","max","mathPow","pow","COVER_Z","UNSELECT_THRESHOLD","MIN_RESIZE_LINE_WIDTH","MUTEX_RESOURCE_KEY","DIRECTION_MAP","w","e","n","s","CURSOR_MAP","ne","sw","nw","se","DEFAULT_BRUSH_OPT","brushStyle","lineWidth","stroke","fill","transformable","brushMode","removeOnClick","baseUID","BrushController","zr","call","_zr","group","Group","_brushType","_brushOption","_panels","_track","_dragging","_covers","_creatingCover","_creatingPanel","_enableGlobalPan","_uid","_handlers","mouseHandlers","handler","eventName","bind","prototype","constructor","enableBrush","brushOption","doDisableBrush","brushType","doEnableBrush","setPanels","panelOpts","length","panels","panelId","clone","mount","opt","enableGlobalPan","thisGroup","add","attr","position","rotation","scale","_transform","getLocalTransform","eachCover","cb","context","updateCovers","brushOptionList","merge","tmpIdPrefix","oldCovers","newCovers","controller","creatingCover","oldGetKey","getKey","addOrUpdate","update","remove","execute","index","id","cover","__brushOption","newIndex","oldIndex","newBrushOption","endCreating","createCover","updateCoverAfterCreation","unmount","clearCovers","dispose","off","mixin","take","on","release","coverRenderers","updateZ","coverRenderer","getCoverRenderer","updateCoverShape","range","z","traverse","el","z2","updateCommon","getPanelByPoint","localCursorPoint","panel","transform","pn","isTargetByCursor","getPanelByCover","covers","originalLength","trigger","areas","isEnd","shouldShowCover","track","p2","p1","dx","dy","dist","getTrackEnds","tail","createBaseRectCover","doDrift","edgeNames","Rect","name","style","makeStyle","silent","draggable","cursor","drift","ondragend","opacity","invisible","updateBaseRect","localRange","handleSize","x","y","xa","ya","x2","y2","x2a","y2a","width","height","widtha","heighta","updateRectShape","mainEl","childAt","useStyle","childOfName","globalDir","getGlobalDirection","h","setShape","pointsToRect","clipByPanel","defaults","strokeNoScale","formatRectRange","getTransform","localDirection","split","reverse","join","inverseMap","left","right","top","bottom","transformDirection","driftRect","toRectRange","fromRectRange","rectRange","localDelta","toLocalDelta","namePart","ind","driftPolygon","point","localD","transformCoordToLocal","localZero","data","clipPath","points","xmin","ymin","xmax","ymax","resetCursor","currPanel","i","contain","setCursorStyle","preventDefault","rawE","event","mainShapeContain","updateCoverByMouse","thisBrushOption","eventParams","push","slice","determineBrushType","coverBrushOption","getCreatingRange","defaultBrushType","mousedown","handleDragEnd","target","offsetX","offsetY","mousemove","mouseup","lineX","getLineRenderer","lineY","rect","localTrack","ends","polygon","Polyline","Polygon","xyIndex","otherExtent","getLinearBrushOtherExtent","getWidth","getHeight","_default","module","exports"],"sources":["C:/Users/W/Desktop/vue_map/node_modules/echarts/lib/component/helper/BrushController.js"],"sourcesContent":["var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar Eventful = require(\"zrender/lib/mixin/Eventful\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar interactionMutex = require(\"./interactionMutex\");\n\nvar DataDiffer = require(\"../../data/DataDiffer\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar curry = zrUtil.curry;\nvar each = zrUtil.each;\nvar map = zrUtil.map;\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathPow = Math.pow;\nvar COVER_Z = 10000;\nvar UNSELECT_THRESHOLD = 6;\nvar MIN_RESIZE_LINE_WIDTH = 6;\nvar MUTEX_RESOURCE_KEY = 'globalPan';\nvar DIRECTION_MAP = {\n  w: [0, 0],\n  e: [0, 1],\n  n: [1, 0],\n  s: [1, 1]\n};\nvar CURSOR_MAP = {\n  w: 'ew',\n  e: 'ew',\n  n: 'ns',\n  s: 'ns',\n  ne: 'nesw',\n  sw: 'nesw',\n  nw: 'nwse',\n  se: 'nwse'\n};\nvar DEFAULT_BRUSH_OPT = {\n  brushStyle: {\n    lineWidth: 2,\n    stroke: 'rgba(0,0,0,0.3)',\n    fill: 'rgba(0,0,0,0.1)'\n  },\n  transformable: true,\n  brushMode: 'single',\n  removeOnClick: false\n};\nvar baseUID = 0;\n/**\n * @alias module:echarts/component/helper/BrushController\n * @constructor\n * @mixin {module:zrender/mixin/Eventful}\n * @event module:echarts/component/helper/BrushController#brush\n *        params:\n *            areas: Array.<Array>, coord relates to container group,\n *                                    If no container specified, to global.\n *            opt {\n *                isEnd: boolean,\n *                removeOnClick: boolean\n *            }\n *\n * @param {module:zrender/zrender~ZRender} zr\n */\n\nfunction BrushController(zr) {\n  Eventful.call(this);\n  /**\n   * @type {module:zrender/zrender~ZRender}\n   * @private\n   */\n\n  this._zr = zr;\n  /**\n   * @type {module:zrender/container/Group}\n   * @readOnly\n   */\n\n  this.group = new graphic.Group();\n  /**\n   * Only for drawing (after enabledBrush).\n   *     'line', 'rect', 'polygon' or false\n   *     If passing false/null/undefined, disable brush.\n   *     If passing 'auto', determined by panel.defaultBrushType\n   * @private\n   * @type {string}\n   */\n\n  this._brushType;\n  /**\n   * Only for drawing (after enabledBrush).\n   *\n   * @private\n   * @type {Object}\n   */\n\n  this._brushOption;\n  /**\n   * @private\n   * @type {Object}\n   */\n\n  this._panels;\n  /**\n   * @private\n   * @type {Array.<nubmer>}\n   */\n\n  this._track = [];\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this._dragging;\n  /**\n   * @private\n   * @type {Array}\n   */\n\n  this._covers = [];\n  /**\n   * @private\n   * @type {moudule:zrender/container/Group}\n   */\n\n  this._creatingCover;\n  /**\n   * `true` means global panel\n   * @private\n   * @type {module:zrender/container/Group|boolean}\n   */\n\n  this._creatingPanel;\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this._enableGlobalPan;\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  /**\n   * @private\n   * @type {string}\n   */\n  this._uid = 'brushController_' + baseUID++;\n  /**\n   * @private\n   * @type {Object}\n   */\n\n  this._handlers = {};\n  each(mouseHandlers, function (handler, eventName) {\n    this._handlers[eventName] = zrUtil.bind(handler, this);\n  }, this);\n}\n\nBrushController.prototype = {\n  constructor: BrushController,\n\n  /**\n   * If set to null/undefined/false, select disabled.\n   * @param {Object} brushOption\n   * @param {string|boolean} brushOption.brushType 'line', 'rect', 'polygon' or false\n   *                          If passing false/null/undefined, disable brush.\n   *                          If passing 'auto', determined by panel.defaultBrushType.\n   *                              ('auto' can not be used in global panel)\n   * @param {number} [brushOption.brushMode='single'] 'single' or 'multiple'\n   * @param {boolean} [brushOption.transformable=true]\n   * @param {boolean} [brushOption.removeOnClick=false]\n   * @param {Object} [brushOption.brushStyle]\n   * @param {number} [brushOption.brushStyle.width]\n   * @param {number} [brushOption.brushStyle.lineWidth]\n   * @param {string} [brushOption.brushStyle.stroke]\n   * @param {string} [brushOption.brushStyle.fill]\n   * @param {number} [brushOption.z]\n   */\n  enableBrush: function (brushOption) {\n    this._brushType && doDisableBrush(this);\n    brushOption.brushType && doEnableBrush(this, brushOption);\n    return this;\n  },\n\n  /**\n   * @param {Array.<Object>} panelOpts If not pass, it is global brush.\n   *        Each items: {\n   *            panelId, // mandatory.\n   *            clipPath, // mandatory. function.\n   *            isTargetByCursor, // mandatory. function.\n   *            defaultBrushType, // optional, only used when brushType is 'auto'.\n   *            getLinearBrushOtherExtent, // optional. function.\n   *        }\n   */\n  setPanels: function (panelOpts) {\n    if (panelOpts && panelOpts.length) {\n      var panels = this._panels = {};\n      zrUtil.each(panelOpts, function (panelOpts) {\n        panels[panelOpts.panelId] = zrUtil.clone(panelOpts);\n      });\n    } else {\n      this._panels = null;\n    }\n\n    return this;\n  },\n\n  /**\n   * @param {Object} [opt]\n   * @return {boolean} [opt.enableGlobalPan=false]\n   */\n  mount: function (opt) {\n    opt = opt || {};\n    this._enableGlobalPan = opt.enableGlobalPan;\n    var thisGroup = this.group;\n\n    this._zr.add(thisGroup);\n\n    thisGroup.attr({\n      position: opt.position || [0, 0],\n      rotation: opt.rotation || 0,\n      scale: opt.scale || [1, 1]\n    });\n    this._transform = thisGroup.getLocalTransform();\n    return this;\n  },\n  eachCover: function (cb, context) {\n    each(this._covers, cb, context);\n  },\n\n  /**\n   * Update covers.\n   * @param {Array.<Object>} brushOptionList Like:\n   *        [\n   *            {id: 'xx', brushType: 'line', range: [23, 44], brushStyle, transformable},\n   *            {id: 'yy', brushType: 'rect', range: [[23, 44], [23, 54]]},\n   *            ...\n   *        ]\n   *        `brushType` is required in each cover info. (can not be 'auto')\n   *        `id` is not mandatory.\n   *        `brushStyle`, `transformable` is not mandatory, use DEFAULT_BRUSH_OPT by default.\n   *        If brushOptionList is null/undefined, all covers removed.\n   */\n  updateCovers: function (brushOptionList) {\n    brushOptionList = zrUtil.map(brushOptionList, function (brushOption) {\n      return zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);\n    });\n    var tmpIdPrefix = '\\0-brush-index-';\n    var oldCovers = this._covers;\n    var newCovers = this._covers = [];\n    var controller = this;\n    var creatingCover = this._creatingCover;\n    new DataDiffer(oldCovers, brushOptionList, oldGetKey, getKey).add(addOrUpdate).update(addOrUpdate).remove(remove).execute();\n    return this;\n\n    function getKey(brushOption, index) {\n      return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index) + '-' + brushOption.brushType;\n    }\n\n    function oldGetKey(cover, index) {\n      return getKey(cover.__brushOption, index);\n    }\n\n    function addOrUpdate(newIndex, oldIndex) {\n      var newBrushOption = brushOptionList[newIndex]; // Consider setOption in event listener of brushSelect,\n      // where updating cover when creating should be forbiden.\n\n      if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {\n        newCovers[newIndex] = oldCovers[oldIndex];\n      } else {\n        var cover = newCovers[newIndex] = oldIndex != null ? (oldCovers[oldIndex].__brushOption = newBrushOption, oldCovers[oldIndex]) : endCreating(controller, createCover(controller, newBrushOption));\n        updateCoverAfterCreation(controller, cover);\n      }\n    }\n\n    function remove(oldIndex) {\n      if (oldCovers[oldIndex] !== creatingCover) {\n        controller.group.remove(oldCovers[oldIndex]);\n      }\n    }\n  },\n  unmount: function () {\n    this.enableBrush(false); // container may 'removeAll' outside.\n\n    clearCovers(this);\n\n    this._zr.remove(this.group);\n\n    return this;\n  },\n  dispose: function () {\n    this.unmount();\n    this.off();\n  }\n};\nzrUtil.mixin(BrushController, Eventful);\n\nfunction doEnableBrush(controller, brushOption) {\n  var zr = controller._zr; // Consider roam, which takes globalPan too.\n\n  if (!controller._enableGlobalPan) {\n    interactionMutex.take(zr, MUTEX_RESOURCE_KEY, controller._uid);\n  }\n\n  each(controller._handlers, function (handler, eventName) {\n    zr.on(eventName, handler);\n  });\n  controller._brushType = brushOption.brushType;\n  controller._brushOption = zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);\n}\n\nfunction doDisableBrush(controller) {\n  var zr = controller._zr;\n  interactionMutex.release(zr, MUTEX_RESOURCE_KEY, controller._uid);\n  each(controller._handlers, function (handler, eventName) {\n    zr.off(eventName, handler);\n  });\n  controller._brushType = controller._brushOption = null;\n}\n\nfunction createCover(controller, brushOption) {\n  var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);\n  cover.__brushOption = brushOption;\n  updateZ(cover, brushOption);\n  controller.group.add(cover);\n  return cover;\n}\n\nfunction endCreating(controller, creatingCover) {\n  var coverRenderer = getCoverRenderer(creatingCover);\n\n  if (coverRenderer.endCreating) {\n    coverRenderer.endCreating(controller, creatingCover);\n    updateZ(creatingCover, creatingCover.__brushOption);\n  }\n\n  return creatingCover;\n}\n\nfunction updateCoverShape(controller, cover) {\n  var brushOption = cover.__brushOption;\n  getCoverRenderer(cover).updateCoverShape(controller, cover, brushOption.range, brushOption);\n}\n\nfunction updateZ(cover, brushOption) {\n  var z = brushOption.z;\n  z == null && (z = COVER_Z);\n  cover.traverse(function (el) {\n    el.z = z;\n    el.z2 = z; // Consider in given container.\n  });\n}\n\nfunction updateCoverAfterCreation(controller, cover) {\n  getCoverRenderer(cover).updateCommon(controller, cover);\n  updateCoverShape(controller, cover);\n}\n\nfunction getCoverRenderer(cover) {\n  return coverRenderers[cover.__brushOption.brushType];\n} // return target panel or `true` (means global panel)\n\n\nfunction getPanelByPoint(controller, e, localCursorPoint) {\n  var panels = controller._panels;\n\n  if (!panels) {\n    return true; // Global panel\n  }\n\n  var panel;\n  var transform = controller._transform;\n  each(panels, function (pn) {\n    pn.isTargetByCursor(e, localCursorPoint, transform) && (panel = pn);\n  });\n  return panel;\n} // Return a panel or true\n\n\nfunction getPanelByCover(controller, cover) {\n  var panels = controller._panels;\n\n  if (!panels) {\n    return true; // Global panel\n  }\n\n  var panelId = cover.__brushOption.panelId; // User may give cover without coord sys info,\n  // which is then treated as global panel.\n\n  return panelId != null ? panels[panelId] : true;\n}\n\nfunction clearCovers(controller) {\n  var covers = controller._covers;\n  var originalLength = covers.length;\n  each(covers, function (cover) {\n    controller.group.remove(cover);\n  }, controller);\n  covers.length = 0;\n  return !!originalLength;\n}\n\nfunction trigger(controller, opt) {\n  var areas = map(controller._covers, function (cover) {\n    var brushOption = cover.__brushOption;\n    var range = zrUtil.clone(brushOption.range);\n    return {\n      brushType: brushOption.brushType,\n      panelId: brushOption.panelId,\n      range: range\n    };\n  });\n  controller.trigger('brush', areas, {\n    isEnd: !!opt.isEnd,\n    removeOnClick: !!opt.removeOnClick\n  });\n}\n\nfunction shouldShowCover(controller) {\n  var track = controller._track;\n\n  if (!track.length) {\n    return false;\n  }\n\n  var p2 = track[track.length - 1];\n  var p1 = track[0];\n  var dx = p2[0] - p1[0];\n  var dy = p2[1] - p1[1];\n  var dist = mathPow(dx * dx + dy * dy, 0.5);\n  return dist > UNSELECT_THRESHOLD;\n}\n\nfunction getTrackEnds(track) {\n  var tail = track.length - 1;\n  tail < 0 && (tail = 0);\n  return [track[0], track[tail]];\n}\n\nfunction createBaseRectCover(doDrift, controller, brushOption, edgeNames) {\n  var cover = new graphic.Group();\n  cover.add(new graphic.Rect({\n    name: 'main',\n    style: makeStyle(brushOption),\n    silent: true,\n    draggable: true,\n    cursor: 'move',\n    drift: curry(doDrift, controller, cover, 'nswe'),\n    ondragend: curry(trigger, controller, {\n      isEnd: true\n    })\n  }));\n  each(edgeNames, function (name) {\n    cover.add(new graphic.Rect({\n      name: name,\n      style: {\n        opacity: 0\n      },\n      draggable: true,\n      silent: true,\n      invisible: true,\n      drift: curry(doDrift, controller, cover, name),\n      ondragend: curry(trigger, controller, {\n        isEnd: true\n      })\n    }));\n  });\n  return cover;\n}\n\nfunction updateBaseRect(controller, cover, localRange, brushOption) {\n  var lineWidth = brushOption.brushStyle.lineWidth || 0;\n  var handleSize = mathMax(lineWidth, MIN_RESIZE_LINE_WIDTH);\n  var x = localRange[0][0];\n  var y = localRange[1][0];\n  var xa = x - lineWidth / 2;\n  var ya = y - lineWidth / 2;\n  var x2 = localRange[0][1];\n  var y2 = localRange[1][1];\n  var x2a = x2 - handleSize + lineWidth / 2;\n  var y2a = y2 - handleSize + lineWidth / 2;\n  var width = x2 - x;\n  var height = y2 - y;\n  var widtha = width + lineWidth;\n  var heighta = height + lineWidth;\n  updateRectShape(controller, cover, 'main', x, y, width, height);\n\n  if (brushOption.transformable) {\n    updateRectShape(controller, cover, 'w', xa, ya, handleSize, heighta);\n    updateRectShape(controller, cover, 'e', x2a, ya, handleSize, heighta);\n    updateRectShape(controller, cover, 'n', xa, ya, widtha, handleSize);\n    updateRectShape(controller, cover, 's', xa, y2a, widtha, handleSize);\n    updateRectShape(controller, cover, 'nw', xa, ya, handleSize, handleSize);\n    updateRectShape(controller, cover, 'ne', x2a, ya, handleSize, handleSize);\n    updateRectShape(controller, cover, 'sw', xa, y2a, handleSize, handleSize);\n    updateRectShape(controller, cover, 'se', x2a, y2a, handleSize, handleSize);\n  }\n}\n\nfunction updateCommon(controller, cover) {\n  var brushOption = cover.__brushOption;\n  var transformable = brushOption.transformable;\n  var mainEl = cover.childAt(0);\n  mainEl.useStyle(makeStyle(brushOption));\n  mainEl.attr({\n    silent: !transformable,\n    cursor: transformable ? 'move' : 'default'\n  });\n  each(['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw'], function (name) {\n    var el = cover.childOfName(name);\n    var globalDir = getGlobalDirection(controller, name);\n    el && el.attr({\n      silent: !transformable,\n      invisible: !transformable,\n      cursor: transformable ? CURSOR_MAP[globalDir] + '-resize' : null\n    });\n  });\n}\n\nfunction updateRectShape(controller, cover, name, x, y, w, h) {\n  var el = cover.childOfName(name);\n  el && el.setShape(pointsToRect(clipByPanel(controller, cover, [[x, y], [x + w, y + h]])));\n}\n\nfunction makeStyle(brushOption) {\n  return zrUtil.defaults({\n    strokeNoScale: true\n  }, brushOption.brushStyle);\n}\n\nfunction formatRectRange(x, y, x2, y2) {\n  var min = [mathMin(x, x2), mathMin(y, y2)];\n  var max = [mathMax(x, x2), mathMax(y, y2)];\n  return [[min[0], max[0]], // x range\n  [min[1], max[1]] // y range\n  ];\n}\n\nfunction getTransform(controller) {\n  return graphic.getTransform(controller.group);\n}\n\nfunction getGlobalDirection(controller, localDirection) {\n  if (localDirection.length > 1) {\n    localDirection = localDirection.split('');\n    var globalDir = [getGlobalDirection(controller, localDirection[0]), getGlobalDirection(controller, localDirection[1])];\n    (globalDir[0] === 'e' || globalDir[0] === 'w') && globalDir.reverse();\n    return globalDir.join('');\n  } else {\n    var map = {\n      w: 'left',\n      e: 'right',\n      n: 'top',\n      s: 'bottom'\n    };\n    var inverseMap = {\n      left: 'w',\n      right: 'e',\n      top: 'n',\n      bottom: 's'\n    };\n    var globalDir = graphic.transformDirection(map[localDirection], getTransform(controller));\n    return inverseMap[globalDir];\n  }\n}\n\nfunction driftRect(toRectRange, fromRectRange, controller, cover, name, dx, dy, e) {\n  var brushOption = cover.__brushOption;\n  var rectRange = toRectRange(brushOption.range);\n  var localDelta = toLocalDelta(controller, dx, dy);\n  each(name.split(''), function (namePart) {\n    var ind = DIRECTION_MAP[namePart];\n    rectRange[ind[0]][ind[1]] += localDelta[ind[0]];\n  });\n  brushOption.range = fromRectRange(formatRectRange(rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]));\n  updateCoverAfterCreation(controller, cover);\n  trigger(controller, {\n    isEnd: false\n  });\n}\n\nfunction driftPolygon(controller, cover, dx, dy, e) {\n  var range = cover.__brushOption.range;\n  var localDelta = toLocalDelta(controller, dx, dy);\n  each(range, function (point) {\n    point[0] += localDelta[0];\n    point[1] += localDelta[1];\n  });\n  updateCoverAfterCreation(controller, cover);\n  trigger(controller, {\n    isEnd: false\n  });\n}\n\nfunction toLocalDelta(controller, dx, dy) {\n  var thisGroup = controller.group;\n  var localD = thisGroup.transformCoordToLocal(dx, dy);\n  var localZero = thisGroup.transformCoordToLocal(0, 0);\n  return [localD[0] - localZero[0], localD[1] - localZero[1]];\n}\n\nfunction clipByPanel(controller, cover, data) {\n  var panel = getPanelByCover(controller, cover);\n  return panel && panel !== true ? panel.clipPath(data, controller._transform) : zrUtil.clone(data);\n}\n\nfunction pointsToRect(points) {\n  var xmin = mathMin(points[0][0], points[1][0]);\n  var ymin = mathMin(points[0][1], points[1][1]);\n  var xmax = mathMax(points[0][0], points[1][0]);\n  var ymax = mathMax(points[0][1], points[1][1]);\n  return {\n    x: xmin,\n    y: ymin,\n    width: xmax - xmin,\n    height: ymax - ymin\n  };\n}\n\nfunction resetCursor(controller, e, localCursorPoint) {\n  // Check active\n  if (!controller._brushType) {\n    return;\n  }\n\n  var zr = controller._zr;\n  var covers = controller._covers;\n  var currPanel = getPanelByPoint(controller, e, localCursorPoint); // Check whether in covers.\n\n  if (!controller._dragging) {\n    for (var i = 0; i < covers.length; i++) {\n      var brushOption = covers[i].__brushOption;\n\n      if (currPanel && (currPanel === true || brushOption.panelId === currPanel.panelId) && coverRenderers[brushOption.brushType].contain(covers[i], localCursorPoint[0], localCursorPoint[1])) {\n        // Use cursor style set on cover.\n        return;\n      }\n    }\n  }\n\n  currPanel && zr.setCursorStyle('crosshair');\n}\n\nfunction preventDefault(e) {\n  var rawE = e.event;\n  rawE.preventDefault && rawE.preventDefault();\n}\n\nfunction mainShapeContain(cover, x, y) {\n  return cover.childOfName('main').contain(x, y);\n}\n\nfunction updateCoverByMouse(controller, e, localCursorPoint, isEnd) {\n  var creatingCover = controller._creatingCover;\n  var panel = controller._creatingPanel;\n  var thisBrushOption = controller._brushOption;\n  var eventParams;\n\n  controller._track.push(localCursorPoint.slice());\n\n  if (shouldShowCover(controller) || creatingCover) {\n    if (panel && !creatingCover) {\n      thisBrushOption.brushMode === 'single' && clearCovers(controller);\n      var brushOption = zrUtil.clone(thisBrushOption);\n      brushOption.brushType = determineBrushType(brushOption.brushType, panel);\n      brushOption.panelId = panel === true ? null : panel.panelId;\n      creatingCover = controller._creatingCover = createCover(controller, brushOption);\n\n      controller._covers.push(creatingCover);\n    }\n\n    if (creatingCover) {\n      var coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)];\n      var coverBrushOption = creatingCover.__brushOption;\n      coverBrushOption.range = coverRenderer.getCreatingRange(clipByPanel(controller, creatingCover, controller._track));\n\n      if (isEnd) {\n        endCreating(controller, creatingCover);\n        coverRenderer.updateCommon(controller, creatingCover);\n      }\n\n      updateCoverShape(controller, creatingCover);\n      eventParams = {\n        isEnd: isEnd\n      };\n    }\n  } else if (isEnd && thisBrushOption.brushMode === 'single' && thisBrushOption.removeOnClick) {\n    // Help user to remove covers easily, only by a tiny drag, in 'single' mode.\n    // But a single click do not clear covers, because user may have casual\n    // clicks (for example, click on other component and do not expect covers\n    // disappear).\n    // Only some cover removed, trigger action, but not every click trigger action.\n    if (getPanelByPoint(controller, e, localCursorPoint) && clearCovers(controller)) {\n      eventParams = {\n        isEnd: isEnd,\n        removeOnClick: true\n      };\n    }\n  }\n\n  return eventParams;\n}\n\nfunction determineBrushType(brushType, panel) {\n  if (brushType === 'auto') {\n    return panel.defaultBrushType;\n  }\n\n  return brushType;\n}\n\nvar mouseHandlers = {\n  mousedown: function (e) {\n    if (this._dragging) {\n      // In case some browser do not support globalOut,\n      // and release mose out side the browser.\n      handleDragEnd.call(this, e);\n    } else if (!e.target || !e.target.draggable) {\n      preventDefault(e);\n      var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n      this._creatingCover = null;\n      var panel = this._creatingPanel = getPanelByPoint(this, e, localCursorPoint);\n\n      if (panel) {\n        this._dragging = true;\n        this._track = [localCursorPoint.slice()];\n      }\n    }\n  },\n  mousemove: function (e) {\n    var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n    resetCursor(this, e, localCursorPoint);\n\n    if (this._dragging) {\n      preventDefault(e);\n      var eventParams = updateCoverByMouse(this, e, localCursorPoint, false);\n      eventParams && trigger(this, eventParams);\n    }\n  },\n  mouseup: handleDragEnd //,\n  // FIXME\n  // in tooltip, globalout should not be triggered.\n  // globalout: handleDragEnd\n\n};\n\nfunction handleDragEnd(e) {\n  if (this._dragging) {\n    preventDefault(e);\n    var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n    var eventParams = updateCoverByMouse(this, e, localCursorPoint, true);\n    this._dragging = false;\n    this._track = [];\n    this._creatingCover = null; // trigger event shoule be at final, after procedure will be nested.\n\n    eventParams && trigger(this, eventParams);\n  }\n}\n/**\n * key: brushType\n * @type {Object}\n */\n\n\nvar coverRenderers = {\n  lineX: getLineRenderer(0),\n  lineY: getLineRenderer(1),\n  rect: {\n    createCover: function (controller, brushOption) {\n      return createBaseRectCover(curry(driftRect, function (range) {\n        return range;\n      }, function (range) {\n        return range;\n      }), controller, brushOption, ['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw']);\n    },\n    getCreatingRange: function (localTrack) {\n      var ends = getTrackEnds(localTrack);\n      return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      updateBaseRect(controller, cover, localRange, brushOption);\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  },\n  polygon: {\n    createCover: function (controller, brushOption) {\n      var cover = new graphic.Group(); // Do not use graphic.Polygon because graphic.Polyline do not close the\n      // border of the shape when drawing, which is a better experience for user.\n\n      cover.add(new graphic.Polyline({\n        name: 'main',\n        style: makeStyle(brushOption),\n        silent: true\n      }));\n      return cover;\n    },\n    getCreatingRange: function (localTrack) {\n      return localTrack;\n    },\n    endCreating: function (controller, cover) {\n      cover.remove(cover.childAt(0)); // Use graphic.Polygon close the shape.\n\n      cover.add(new graphic.Polygon({\n        name: 'main',\n        draggable: true,\n        drift: curry(driftPolygon, controller, cover),\n        ondragend: curry(trigger, controller, {\n          isEnd: true\n        })\n      }));\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      cover.childAt(0).setShape({\n        points: clipByPanel(controller, cover, localRange)\n      });\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  }\n};\n\nfunction getLineRenderer(xyIndex) {\n  return {\n    createCover: function (controller, brushOption) {\n      return createBaseRectCover(curry(driftRect, function (range) {\n        var rectRange = [range, [0, 100]];\n        xyIndex && rectRange.reverse();\n        return rectRange;\n      }, function (rectRange) {\n        return rectRange[xyIndex];\n      }), controller, brushOption, [['w', 'e'], ['n', 's']][xyIndex]);\n    },\n    getCreatingRange: function (localTrack) {\n      var ends = getTrackEnds(localTrack);\n      var min = mathMin(ends[0][xyIndex], ends[1][xyIndex]);\n      var max = mathMax(ends[0][xyIndex], ends[1][xyIndex]);\n      return [min, max];\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      var otherExtent; // If brushWidth not specified, fit the panel.\n\n      var panel = getPanelByCover(controller, cover);\n\n      if (panel !== true && panel.getLinearBrushOtherExtent) {\n        otherExtent = panel.getLinearBrushOtherExtent(xyIndex, controller._transform);\n      } else {\n        var zr = controller._zr;\n        otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]];\n      }\n\n      var rectRange = [localRange, otherExtent];\n      xyIndex && rectRange.reverse();\n      updateBaseRect(controller, cover, rectRange, brushOption);\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  };\n}\n\nvar _default = BrushController;\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}