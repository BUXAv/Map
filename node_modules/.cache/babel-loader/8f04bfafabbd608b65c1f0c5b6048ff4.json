{"ast":null,"code":"var Displayable = require(\"./Displayable\");\n\nvar zrUtil = require(\"../core/util\");\n\nvar PathProxy = require(\"../core/PathProxy\");\n\nvar pathContain = require(\"../contain/path\");\n\nvar Pattern = require(\"./Pattern\");\n\nvar getCanvasPattern = Pattern.prototype.getCanvasPattern;\nvar abs = Math.abs;\nvar pathProxyForDraw = new PathProxy(true);\n/**\n * @alias module:zrender/graphic/Path\n * @extends module:zrender/graphic/Displayable\n * @constructor\n * @param {Object} opts\n */\n\nfunction Path(opts) {\n  Displayable.call(this, opts);\n  /**\n   * @type {module:zrender/core/PathProxy}\n   * @readOnly\n   */\n\n  this.path = null;\n}\n\nPath.prototype = {\n  constructor: Path,\n  type: 'path',\n  __dirtyPath: true,\n  strokeContainThreshold: 5,\n  brush: function (ctx, prevEl) {\n    var style = this.style;\n    var path = this.path || pathProxyForDraw;\n    var hasStroke = style.hasStroke();\n    var hasFill = style.hasFill();\n    var fill = style.fill;\n    var stroke = style.stroke;\n    var hasFillGradient = hasFill && !!fill.colorStops;\n    var hasStrokeGradient = hasStroke && !!stroke.colorStops;\n    var hasFillPattern = hasFill && !!fill.image;\n    var hasStrokePattern = hasStroke && !!stroke.image;\n    style.bind(ctx, this, prevEl);\n    this.setTransform(ctx);\n\n    if (this.__dirty) {\n      var rect; // Update gradient because bounding rect may changed\n\n      if (hasFillGradient) {\n        rect = rect || this.getBoundingRect();\n        this._fillGradient = style.getGradient(ctx, fill, rect);\n      }\n\n      if (hasStrokeGradient) {\n        rect = rect || this.getBoundingRect();\n        this._strokeGradient = style.getGradient(ctx, stroke, rect);\n      }\n    } // Use the gradient or pattern\n\n\n    if (hasFillGradient) {\n      // PENDING If may have affect the state\n      ctx.fillStyle = this._fillGradient;\n    } else if (hasFillPattern) {\n      ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n    }\n\n    if (hasStrokeGradient) {\n      ctx.strokeStyle = this._strokeGradient;\n    } else if (hasStrokePattern) {\n      ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n    }\n\n    var lineDash = style.lineDash;\n    var lineDashOffset = style.lineDashOffset;\n    var ctxLineDash = !!ctx.setLineDash; // Update path sx, sy\n\n    var scale = this.getGlobalScale();\n    path.setScale(scale[0], scale[1]); // Proxy context\n    // Rebuild path in following 2 cases\n    // 1. Path is dirty\n    // 2. Path needs javascript implemented lineDash stroking.\n    //    In this case, lineDash information will not be saved in PathProxy\n\n    if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {\n      path.beginPath(ctx); // Setting line dash before build path\n\n      if (lineDash && !ctxLineDash) {\n        path.setLineDash(lineDash);\n        path.setLineDashOffset(lineDashOffset);\n      }\n\n      this.buildPath(path, this.shape, false); // Clear path dirty flag\n\n      if (this.path) {\n        this.__dirtyPath = false;\n      }\n    } else {\n      // Replay path building\n      ctx.beginPath();\n      this.path.rebuildPath(ctx);\n    }\n\n    hasFill && path.fill(ctx);\n\n    if (lineDash && ctxLineDash) {\n      ctx.setLineDash(lineDash);\n      ctx.lineDashOffset = lineDashOffset;\n    }\n\n    hasStroke && path.stroke(ctx);\n\n    if (lineDash && ctxLineDash) {\n      // PENDING\n      // Remove lineDash\n      ctx.setLineDash([]);\n    } // Draw rect text\n\n\n    if (style.text != null) {\n      // Only restore transform when needs draw text.\n      this.restoreTransform(ctx);\n      this.drawRectText(ctx, this.getBoundingRect());\n    }\n  },\n  // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n  // Like in circle\n  buildPath: function (ctx, shapeCfg, inBundle) {},\n  createPathProxy: function () {\n    this.path = new PathProxy();\n  },\n  getBoundingRect: function () {\n    var rect = this._rect;\n    var style = this.style;\n    var needsUpdateRect = !rect;\n\n    if (needsUpdateRect) {\n      var path = this.path;\n\n      if (!path) {\n        // Create path on demand.\n        path = this.path = new PathProxy();\n      }\n\n      if (this.__dirtyPath) {\n        path.beginPath();\n        this.buildPath(path, this.shape, false);\n      }\n\n      rect = path.getBoundingRect();\n    }\n\n    this._rect = rect;\n\n    if (style.hasStroke()) {\n      // Needs update rect with stroke lineWidth when\n      // 1. Element changes scale or lineWidth\n      // 2. Shape is changed\n      var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n\n      if (this.__dirty || needsUpdateRect) {\n        rectWithStroke.copy(rect); // FIXME Must after updateTransform\n\n        var w = style.lineWidth; // PENDING, Min line width is needed when line is horizontal or vertical\n\n        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Only add extra hover lineWidth when there are no fill\n\n        if (!style.hasFill()) {\n          w = Math.max(w, this.strokeContainThreshold || 4);\n        } // Consider line width\n        // Line scale can't be 0;\n\n\n        if (lineScale > 1e-10) {\n          rectWithStroke.width += w / lineScale;\n          rectWithStroke.height += w / lineScale;\n          rectWithStroke.x -= w / lineScale / 2;\n          rectWithStroke.y -= w / lineScale / 2;\n        }\n      } // Return rect with stroke\n\n\n      return rectWithStroke;\n    }\n\n    return rect;\n  },\n  contain: function (x, y) {\n    var localPos = this.transformCoordToLocal(x, y);\n    var rect = this.getBoundingRect();\n    var style = this.style;\n    x = localPos[0];\n    y = localPos[1];\n\n    if (rect.contain(x, y)) {\n      var pathData = this.path.data;\n\n      if (style.hasStroke()) {\n        var lineWidth = style.lineWidth;\n        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Line scale can't be 0;\n\n        if (lineScale > 1e-10) {\n          // Only add extra hover lineWidth when there are no fill\n          if (!style.hasFill()) {\n            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n          }\n\n          if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {\n            return true;\n          }\n        }\n      }\n\n      if (style.hasFill()) {\n        return pathContain.contain(pathData, x, y);\n      }\n    }\n\n    return false;\n  },\n\n  /**\n   * @param  {boolean} dirtyPath\n   */\n  dirty: function (dirtyPath) {\n    if (dirtyPath == null) {\n      dirtyPath = true;\n    } // Only mark dirty, not mark clean\n\n\n    if (dirtyPath) {\n      this.__dirtyPath = dirtyPath;\n      this._rect = null;\n    }\n\n    this.__dirty = true;\n    this.__zr && this.__zr.refresh(); // Used as a clipping path\n\n    if (this.__clipTarget) {\n      this.__clipTarget.dirty();\n    }\n  },\n\n  /**\n   * Alias for animate('shape')\n   * @param {boolean} loop\n   */\n  animateShape: function (loop) {\n    return this.animate('shape', loop);\n  },\n  // Overwrite attrKV\n  attrKV: function (key, value) {\n    // FIXME\n    if (key === 'shape') {\n      this.setShape(value);\n      this.__dirtyPath = true;\n      this._rect = null;\n    } else {\n      Displayable.prototype.attrKV.call(this, key, value);\n    }\n  },\n\n  /**\n   * @param {Object|string} key\n   * @param {*} value\n   */\n  setShape: function (key, value) {\n    var shape = this.shape; // Path from string may not have shape\n\n    if (shape) {\n      if (zrUtil.isObject(key)) {\n        for (var name in key) {\n          if (key.hasOwnProperty(name)) {\n            shape[name] = key[name];\n          }\n        }\n      } else {\n        shape[key] = value;\n      }\n\n      this.dirty(true);\n    }\n\n    return this;\n  },\n  getLineScale: function () {\n    var m = this.transform; // Get the line scale.\n    // Determinant of `m` means how much the area is enlarged by the\n    // transformation. So its square root can be used as a scale factor\n    // for width.\n\n    return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;\n  }\n};\n/**\n * 扩展一个 Path element, 比如星形，圆等。\n * Extend a path element\n * @param {Object} props\n * @param {string} props.type Path type\n * @param {Function} props.init Initialize\n * @param {Function} props.buildPath Overwrite buildPath method\n * @param {Object} [props.style] Extended default style config\n * @param {Object} [props.shape] Extended default shape config\n */\n\nPath.extend = function (defaults) {\n  var Sub = function (opts) {\n    Path.call(this, opts);\n\n    if (defaults.style) {\n      // Extend default style\n      this.style.extendFrom(defaults.style, false);\n    } // Extend default shape\n\n\n    var defaultShape = defaults.shape;\n\n    if (defaultShape) {\n      this.shape = this.shape || {};\n      var thisShape = this.shape;\n\n      for (var name in defaultShape) {\n        if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {\n          thisShape[name] = defaultShape[name];\n        }\n      }\n    }\n\n    defaults.init && defaults.init.call(this, opts);\n  };\n\n  zrUtil.inherits(Sub, Path); // FIXME 不能 extend position, rotation 等引用对象\n\n  for (var name in defaults) {\n    // Extending prototype values and methods\n    if (name !== 'style' && name !== 'shape') {\n      Sub.prototype[name] = defaults[name];\n    }\n  }\n\n  return Sub;\n};\n\nzrUtil.inherits(Path, Displayable);\nvar _default = Path;\nmodule.exports = _default;","map":{"version":3,"names":["Displayable","require","zrUtil","PathProxy","pathContain","Pattern","getCanvasPattern","prototype","abs","Math","pathProxyForDraw","Path","opts","call","path","constructor","type","__dirtyPath","strokeContainThreshold","brush","ctx","prevEl","style","hasStroke","hasFill","fill","stroke","hasFillGradient","colorStops","hasStrokeGradient","hasFillPattern","image","hasStrokePattern","bind","setTransform","__dirty","rect","getBoundingRect","_fillGradient","getGradient","_strokeGradient","fillStyle","strokeStyle","lineDash","lineDashOffset","ctxLineDash","setLineDash","scale","getGlobalScale","setScale","beginPath","setLineDashOffset","buildPath","shape","rebuildPath","text","restoreTransform","drawRectText","shapeCfg","inBundle","createPathProxy","_rect","needsUpdateRect","rectWithStroke","_rectWithStroke","clone","copy","w","lineWidth","lineScale","strokeNoScale","getLineScale","max","width","height","x","y","contain","localPos","transformCoordToLocal","pathData","data","containStroke","dirty","dirtyPath","__zr","refresh","__clipTarget","animateShape","loop","animate","attrKV","key","value","setShape","isObject","name","hasOwnProperty","m","transform","sqrt","extend","defaults","Sub","extendFrom","defaultShape","thisShape","init","inherits","_default","module","exports"],"sources":["C:/Users/W/Desktop/vue_map/node_modules/zrender/lib/graphic/Path.js"],"sourcesContent":["var Displayable = require(\"./Displayable\");\n\nvar zrUtil = require(\"../core/util\");\n\nvar PathProxy = require(\"../core/PathProxy\");\n\nvar pathContain = require(\"../contain/path\");\n\nvar Pattern = require(\"./Pattern\");\n\nvar getCanvasPattern = Pattern.prototype.getCanvasPattern;\nvar abs = Math.abs;\nvar pathProxyForDraw = new PathProxy(true);\n/**\n * @alias module:zrender/graphic/Path\n * @extends module:zrender/graphic/Displayable\n * @constructor\n * @param {Object} opts\n */\n\nfunction Path(opts) {\n  Displayable.call(this, opts);\n  /**\n   * @type {module:zrender/core/PathProxy}\n   * @readOnly\n   */\n\n  this.path = null;\n}\n\nPath.prototype = {\n  constructor: Path,\n  type: 'path',\n  __dirtyPath: true,\n  strokeContainThreshold: 5,\n  brush: function (ctx, prevEl) {\n    var style = this.style;\n    var path = this.path || pathProxyForDraw;\n    var hasStroke = style.hasStroke();\n    var hasFill = style.hasFill();\n    var fill = style.fill;\n    var stroke = style.stroke;\n    var hasFillGradient = hasFill && !!fill.colorStops;\n    var hasStrokeGradient = hasStroke && !!stroke.colorStops;\n    var hasFillPattern = hasFill && !!fill.image;\n    var hasStrokePattern = hasStroke && !!stroke.image;\n    style.bind(ctx, this, prevEl);\n    this.setTransform(ctx);\n\n    if (this.__dirty) {\n      var rect; // Update gradient because bounding rect may changed\n\n      if (hasFillGradient) {\n        rect = rect || this.getBoundingRect();\n        this._fillGradient = style.getGradient(ctx, fill, rect);\n      }\n\n      if (hasStrokeGradient) {\n        rect = rect || this.getBoundingRect();\n        this._strokeGradient = style.getGradient(ctx, stroke, rect);\n      }\n    } // Use the gradient or pattern\n\n\n    if (hasFillGradient) {\n      // PENDING If may have affect the state\n      ctx.fillStyle = this._fillGradient;\n    } else if (hasFillPattern) {\n      ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n    }\n\n    if (hasStrokeGradient) {\n      ctx.strokeStyle = this._strokeGradient;\n    } else if (hasStrokePattern) {\n      ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n    }\n\n    var lineDash = style.lineDash;\n    var lineDashOffset = style.lineDashOffset;\n    var ctxLineDash = !!ctx.setLineDash; // Update path sx, sy\n\n    var scale = this.getGlobalScale();\n    path.setScale(scale[0], scale[1]); // Proxy context\n    // Rebuild path in following 2 cases\n    // 1. Path is dirty\n    // 2. Path needs javascript implemented lineDash stroking.\n    //    In this case, lineDash information will not be saved in PathProxy\n\n    if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {\n      path.beginPath(ctx); // Setting line dash before build path\n\n      if (lineDash && !ctxLineDash) {\n        path.setLineDash(lineDash);\n        path.setLineDashOffset(lineDashOffset);\n      }\n\n      this.buildPath(path, this.shape, false); // Clear path dirty flag\n\n      if (this.path) {\n        this.__dirtyPath = false;\n      }\n    } else {\n      // Replay path building\n      ctx.beginPath();\n      this.path.rebuildPath(ctx);\n    }\n\n    hasFill && path.fill(ctx);\n\n    if (lineDash && ctxLineDash) {\n      ctx.setLineDash(lineDash);\n      ctx.lineDashOffset = lineDashOffset;\n    }\n\n    hasStroke && path.stroke(ctx);\n\n    if (lineDash && ctxLineDash) {\n      // PENDING\n      // Remove lineDash\n      ctx.setLineDash([]);\n    } // Draw rect text\n\n\n    if (style.text != null) {\n      // Only restore transform when needs draw text.\n      this.restoreTransform(ctx);\n      this.drawRectText(ctx, this.getBoundingRect());\n    }\n  },\n  // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n  // Like in circle\n  buildPath: function (ctx, shapeCfg, inBundle) {},\n  createPathProxy: function () {\n    this.path = new PathProxy();\n  },\n  getBoundingRect: function () {\n    var rect = this._rect;\n    var style = this.style;\n    var needsUpdateRect = !rect;\n\n    if (needsUpdateRect) {\n      var path = this.path;\n\n      if (!path) {\n        // Create path on demand.\n        path = this.path = new PathProxy();\n      }\n\n      if (this.__dirtyPath) {\n        path.beginPath();\n        this.buildPath(path, this.shape, false);\n      }\n\n      rect = path.getBoundingRect();\n    }\n\n    this._rect = rect;\n\n    if (style.hasStroke()) {\n      // Needs update rect with stroke lineWidth when\n      // 1. Element changes scale or lineWidth\n      // 2. Shape is changed\n      var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n\n      if (this.__dirty || needsUpdateRect) {\n        rectWithStroke.copy(rect); // FIXME Must after updateTransform\n\n        var w = style.lineWidth; // PENDING, Min line width is needed when line is horizontal or vertical\n\n        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Only add extra hover lineWidth when there are no fill\n\n        if (!style.hasFill()) {\n          w = Math.max(w, this.strokeContainThreshold || 4);\n        } // Consider line width\n        // Line scale can't be 0;\n\n\n        if (lineScale > 1e-10) {\n          rectWithStroke.width += w / lineScale;\n          rectWithStroke.height += w / lineScale;\n          rectWithStroke.x -= w / lineScale / 2;\n          rectWithStroke.y -= w / lineScale / 2;\n        }\n      } // Return rect with stroke\n\n\n      return rectWithStroke;\n    }\n\n    return rect;\n  },\n  contain: function (x, y) {\n    var localPos = this.transformCoordToLocal(x, y);\n    var rect = this.getBoundingRect();\n    var style = this.style;\n    x = localPos[0];\n    y = localPos[1];\n\n    if (rect.contain(x, y)) {\n      var pathData = this.path.data;\n\n      if (style.hasStroke()) {\n        var lineWidth = style.lineWidth;\n        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Line scale can't be 0;\n\n        if (lineScale > 1e-10) {\n          // Only add extra hover lineWidth when there are no fill\n          if (!style.hasFill()) {\n            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n          }\n\n          if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {\n            return true;\n          }\n        }\n      }\n\n      if (style.hasFill()) {\n        return pathContain.contain(pathData, x, y);\n      }\n    }\n\n    return false;\n  },\n\n  /**\n   * @param  {boolean} dirtyPath\n   */\n  dirty: function (dirtyPath) {\n    if (dirtyPath == null) {\n      dirtyPath = true;\n    } // Only mark dirty, not mark clean\n\n\n    if (dirtyPath) {\n      this.__dirtyPath = dirtyPath;\n      this._rect = null;\n    }\n\n    this.__dirty = true;\n    this.__zr && this.__zr.refresh(); // Used as a clipping path\n\n    if (this.__clipTarget) {\n      this.__clipTarget.dirty();\n    }\n  },\n\n  /**\n   * Alias for animate('shape')\n   * @param {boolean} loop\n   */\n  animateShape: function (loop) {\n    return this.animate('shape', loop);\n  },\n  // Overwrite attrKV\n  attrKV: function (key, value) {\n    // FIXME\n    if (key === 'shape') {\n      this.setShape(value);\n      this.__dirtyPath = true;\n      this._rect = null;\n    } else {\n      Displayable.prototype.attrKV.call(this, key, value);\n    }\n  },\n\n  /**\n   * @param {Object|string} key\n   * @param {*} value\n   */\n  setShape: function (key, value) {\n    var shape = this.shape; // Path from string may not have shape\n\n    if (shape) {\n      if (zrUtil.isObject(key)) {\n        for (var name in key) {\n          if (key.hasOwnProperty(name)) {\n            shape[name] = key[name];\n          }\n        }\n      } else {\n        shape[key] = value;\n      }\n\n      this.dirty(true);\n    }\n\n    return this;\n  },\n  getLineScale: function () {\n    var m = this.transform; // Get the line scale.\n    // Determinant of `m` means how much the area is enlarged by the\n    // transformation. So its square root can be used as a scale factor\n    // for width.\n\n    return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;\n  }\n};\n/**\n * 扩展一个 Path element, 比如星形，圆等。\n * Extend a path element\n * @param {Object} props\n * @param {string} props.type Path type\n * @param {Function} props.init Initialize\n * @param {Function} props.buildPath Overwrite buildPath method\n * @param {Object} [props.style] Extended default style config\n * @param {Object} [props.shape] Extended default shape config\n */\n\nPath.extend = function (defaults) {\n  var Sub = function (opts) {\n    Path.call(this, opts);\n\n    if (defaults.style) {\n      // Extend default style\n      this.style.extendFrom(defaults.style, false);\n    } // Extend default shape\n\n\n    var defaultShape = defaults.shape;\n\n    if (defaultShape) {\n      this.shape = this.shape || {};\n      var thisShape = this.shape;\n\n      for (var name in defaultShape) {\n        if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {\n          thisShape[name] = defaultShape[name];\n        }\n      }\n    }\n\n    defaults.init && defaults.init.call(this, opts);\n  };\n\n  zrUtil.inherits(Sub, Path); // FIXME 不能 extend position, rotation 等引用对象\n\n  for (var name in defaults) {\n    // Extending prototype values and methods\n    if (name !== 'style' && name !== 'shape') {\n      Sub.prototype[name] = defaults[name];\n    }\n  }\n\n  return Sub;\n};\n\nzrUtil.inherits(Path, Displayable);\nvar _default = Path;\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}