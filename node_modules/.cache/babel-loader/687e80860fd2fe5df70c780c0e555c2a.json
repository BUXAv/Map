{"ast":null,"code":"var _config = require(\"./config\");\n\nvar devicePixelRatio = _config.devicePixelRatio;\n\nvar util = require(\"./core/util\");\n\nvar log = require(\"./core/log\");\n\nvar BoundingRect = require(\"./core/BoundingRect\");\n\nvar timsort = require(\"./core/timsort\");\n\nvar Layer = require(\"./Layer\");\n\nvar requestAnimationFrame = require(\"./animation/requestAnimationFrame\");\n\nvar Image = require(\"./graphic/Image\");\n\nvar env = require(\"./core/env\");\n\nvar HOVER_LAYER_ZLEVEL = 1e5;\nvar CANVAS_ZLEVEL = 314159;\nvar EL_AFTER_INCREMENTAL_INC = 0.01;\nvar INCREMENTAL_INC = 0.001;\n\nfunction parseInt10(val) {\n  return parseInt(val, 10);\n}\n\nfunction isLayerValid(layer) {\n  if (!layer) {\n    return false;\n  }\n\n  if (layer.__builtin__) {\n    return true;\n  }\n\n  if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {\n    return false;\n  }\n\n  return true;\n}\n\nvar tmpRect = new BoundingRect(0, 0, 0, 0);\nvar viewRect = new BoundingRect(0, 0, 0, 0);\n\nfunction isDisplayableCulled(el, width, height) {\n  tmpRect.copy(el.getBoundingRect());\n\n  if (el.transform) {\n    tmpRect.applyTransform(el.transform);\n  }\n\n  viewRect.width = width;\n  viewRect.height = height;\n  return !tmpRect.intersect(viewRect);\n}\n\nfunction isClipPathChanged(clipPaths, prevClipPaths) {\n  if (clipPaths == prevClipPaths) {\n    // Can both be null or undefined\n    return false;\n  }\n\n  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {\n    return true;\n  }\n\n  for (var i = 0; i < clipPaths.length; i++) {\n    if (clipPaths[i] !== prevClipPaths[i]) {\n      return true;\n    }\n  }\n}\n\nfunction doClip(clipPaths, ctx) {\n  for (var i = 0; i < clipPaths.length; i++) {\n    var clipPath = clipPaths[i];\n    clipPath.setTransform(ctx);\n    ctx.beginPath();\n    clipPath.buildPath(ctx, clipPath.shape);\n    ctx.clip(); // Transform back\n\n    clipPath.restoreTransform(ctx);\n  }\n}\n\nfunction createRoot(width, height) {\n  var domRoot = document.createElement('div'); // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬\n\n  domRoot.style.cssText = ['position:relative', 'overflow:hidden', 'width:' + width + 'px', 'height:' + height + 'px', 'padding:0', 'margin:0', 'border-width:0'].join(';') + ';';\n  return domRoot;\n}\n/**\n * @alias module:zrender/Painter\n * @constructor\n * @param {HTMLElement} root 绘图容器\n * @param {module:zrender/Storage} storage\n * @param {Object} opts\n */\n\n\nvar Painter = function (root, storage, opts) {\n  this.type = 'canvas'; // In node environment using node-canvas\n\n  var singleCanvas = !root.nodeName // In node ?\n  || root.nodeName.toUpperCase() === 'CANVAS';\n  this._opts = opts = util.extend({}, opts || {});\n  /**\n   * @type {number}\n   */\n\n  this.dpr = opts.devicePixelRatio || devicePixelRatio;\n  /**\n   * @type {boolean}\n   * @private\n   */\n\n  this._singleCanvas = singleCanvas;\n  /**\n   * 绘图容器\n   * @type {HTMLElement}\n   */\n\n  this.root = root;\n  var rootStyle = root.style;\n\n  if (rootStyle) {\n    rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n    rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';\n    root.innerHTML = '';\n  }\n  /**\n   * @type {module:zrender/Storage}\n   */\n\n\n  this.storage = storage;\n  /**\n   * @type {Array.<number>}\n   * @private\n   */\n\n  var zlevelList = this._zlevelList = [];\n  /**\n   * @type {Object.<string, module:zrender/Layer>}\n   * @private\n   */\n\n  var layers = this._layers = {};\n  /**\n   * @type {Object.<string, Object>}\n   * @private\n   */\n\n  this._layerConfig = {};\n  /**\n   * zrender will do compositing when root is a canvas and have multiple zlevels.\n   */\n\n  this._needsManuallyCompositing = false;\n\n  if (!singleCanvas) {\n    this._width = this._getSize(0);\n    this._height = this._getSize(1);\n    var domRoot = this._domRoot = createRoot(this._width, this._height);\n    root.appendChild(domRoot);\n  } else {\n    var width = root.width;\n    var height = root.height;\n\n    if (opts.width != null) {\n      width = opts.width;\n    }\n\n    if (opts.height != null) {\n      height = opts.height;\n    }\n\n    this.dpr = opts.devicePixelRatio || 1; // Use canvas width and height directly\n\n    root.width = width * this.dpr;\n    root.height = height * this.dpr;\n    this._width = width;\n    this._height = height; // Create layer if only one given canvas\n    // Device can be specified to create a high dpi image.\n\n    var mainLayer = new Layer(root, this, this.dpr);\n    mainLayer.__builtin__ = true;\n    mainLayer.initContext(); // FIXME Use canvas width and height\n    // mainLayer.resize(width, height);\n\n    layers[CANVAS_ZLEVEL] = mainLayer;\n    mainLayer.zlevel = CANVAS_ZLEVEL; // Not use common zlevel.\n\n    zlevelList.push(CANVAS_ZLEVEL);\n    this._domRoot = root;\n  }\n  /**\n   * @type {module:zrender/Layer}\n   * @private\n   */\n\n\n  this._hoverlayer = null;\n  this._hoverElements = [];\n};\n\nPainter.prototype = {\n  constructor: Painter,\n  getType: function () {\n    return 'canvas';\n  },\n\n  /**\n   * If painter use a single canvas\n   * @return {boolean}\n   */\n  isSingleCanvas: function () {\n    return this._singleCanvas;\n  },\n\n  /**\n   * @return {HTMLDivElement}\n   */\n  getViewportRoot: function () {\n    return this._domRoot;\n  },\n  getViewportRootOffset: function () {\n    var viewportRoot = this.getViewportRoot();\n\n    if (viewportRoot) {\n      return {\n        offsetLeft: viewportRoot.offsetLeft || 0,\n        offsetTop: viewportRoot.offsetTop || 0\n      };\n    }\n  },\n\n  /**\n   * 刷新\n   * @param {boolean} [paintAll=false] 强制绘制所有displayable\n   */\n  refresh: function (paintAll) {\n    var list = this.storage.getDisplayList(true);\n    var zlevelList = this._zlevelList;\n    this._redrawId = Math.random();\n\n    this._paintList(list, paintAll, this._redrawId); // Paint custum layers\n\n\n    for (var i = 0; i < zlevelList.length; i++) {\n      var z = zlevelList[i];\n      var layer = this._layers[z];\n\n      if (!layer.__builtin__ && layer.refresh) {\n        var clearColor = i === 0 ? this._backgroundColor : null;\n        layer.refresh(clearColor);\n      }\n    }\n\n    this.refreshHover();\n    return this;\n  },\n  addHover: function (el, hoverStyle) {\n    if (el.__hoverMir) {\n      return;\n    }\n\n    var elMirror = new el.constructor({\n      style: el.style,\n      shape: el.shape\n    });\n    elMirror.__from = el;\n    el.__hoverMir = elMirror;\n    elMirror.setStyle(hoverStyle);\n\n    this._hoverElements.push(elMirror);\n  },\n  removeHover: function (el) {\n    var elMirror = el.__hoverMir;\n    var hoverElements = this._hoverElements;\n    var idx = util.indexOf(hoverElements, elMirror);\n\n    if (idx >= 0) {\n      hoverElements.splice(idx, 1);\n    }\n\n    el.__hoverMir = null;\n  },\n  clearHover: function (el) {\n    var hoverElements = this._hoverElements;\n\n    for (var i = 0; i < hoverElements.length; i++) {\n      var from = hoverElements[i].__from;\n\n      if (from) {\n        from.__hoverMir = null;\n      }\n    }\n\n    hoverElements.length = 0;\n  },\n  refreshHover: function () {\n    var hoverElements = this._hoverElements;\n    var len = hoverElements.length;\n    var hoverLayer = this._hoverlayer;\n    hoverLayer && hoverLayer.clear();\n\n    if (!len) {\n      return;\n    }\n\n    timsort(hoverElements, this.storage.displayableSortFunc); // Use a extream large zlevel\n    // FIXME?\n\n    if (!hoverLayer) {\n      hoverLayer = this._hoverlayer = this.getLayer(HOVER_LAYER_ZLEVEL);\n    }\n\n    var scope = {};\n    hoverLayer.ctx.save();\n\n    for (var i = 0; i < len;) {\n      var el = hoverElements[i];\n      var originalEl = el.__from; // Original el is removed\n      // PENDING\n\n      if (!(originalEl && originalEl.__zr)) {\n        hoverElements.splice(i, 1);\n        originalEl.__hoverMir = null;\n        len--;\n        continue;\n      }\n\n      i++; // Use transform\n      // FIXME style and shape ?\n\n      if (!originalEl.invisible) {\n        el.transform = originalEl.transform;\n        el.invTransform = originalEl.invTransform;\n        el.__clipPaths = originalEl.__clipPaths; // el.\n\n        this._doPaintEl(el, hoverLayer, true, scope);\n      }\n    }\n\n    hoverLayer.ctx.restore();\n  },\n  getHoverLayer: function () {\n    return this.getLayer(HOVER_LAYER_ZLEVEL);\n  },\n  _paintList: function (list, paintAll, redrawId) {\n    if (this._redrawId !== redrawId) {\n      return;\n    }\n\n    paintAll = paintAll || false;\n\n    this._updateLayerStatus(list);\n\n    var finished = this._doPaintList(list, paintAll);\n\n    if (this._needsManuallyCompositing) {\n      this._compositeManually();\n    }\n\n    if (!finished) {\n      var self = this;\n      requestAnimationFrame(function () {\n        self._paintList(list, paintAll, redrawId);\n      });\n    }\n  },\n  _compositeManually: function () {\n    var ctx = this.getLayer(CANVAS_ZLEVEL).ctx;\n    var width = this._domRoot.width;\n    var height = this._domRoot.height;\n    ctx.clearRect(0, 0, width, height); // PENDING, If only builtin layer?\n\n    this.eachBuiltinLayer(function (layer) {\n      if (layer.virtual) {\n        ctx.drawImage(layer.dom, 0, 0, width, height);\n      }\n    });\n  },\n  _doPaintList: function (list, paintAll) {\n    var layerList = [];\n\n    for (var zi = 0; zi < this._zlevelList.length; zi++) {\n      var zlevel = this._zlevelList[zi];\n      var layer = this._layers[zlevel];\n\n      if (layer.__builtin__ && layer !== this._hoverlayer && (layer.__dirty || paintAll)) {\n        layerList.push(layer);\n      }\n    }\n\n    var finished = true;\n\n    for (var k = 0; k < layerList.length; k++) {\n      var layer = layerList[k];\n      var ctx = layer.ctx;\n      var scope = {};\n      ctx.save();\n      var start = paintAll ? layer.__startIndex : layer.__drawIndex;\n      var useTimer = !paintAll && layer.incremental && Date.now;\n      var startTime = useTimer && Date.now();\n      var clearColor = layer.zlevel === this._zlevelList[0] ? this._backgroundColor : null; // All elements in this layer are cleared.\n\n      if (layer.__startIndex === layer.__endIndex) {\n        layer.clear(false, clearColor);\n      } else if (start === layer.__startIndex) {\n        var firstEl = list[start];\n\n        if (!firstEl.incremental || !firstEl.notClear || paintAll) {\n          layer.clear(false, clearColor);\n        }\n      }\n\n      if (start === -1) {\n        console.error('For some unknown reason. drawIndex is -1');\n        start = layer.__startIndex;\n      }\n\n      for (var i = start; i < layer.__endIndex; i++) {\n        var el = list[i];\n\n        this._doPaintEl(el, layer, paintAll, scope);\n\n        el.__dirty = false;\n\n        if (useTimer) {\n          // Date.now can be executed in 13,025,305 ops/second.\n          var dTime = Date.now() - startTime; // Give 15 millisecond to draw.\n          // The rest elements will be drawn in the next frame.\n\n          if (dTime > 15) {\n            break;\n          }\n        }\n      }\n\n      layer.__drawIndex = i;\n\n      if (layer.__drawIndex < layer.__endIndex) {\n        finished = false;\n      }\n\n      if (scope.prevElClipPaths) {\n        // Needs restore the state. If last drawn element is in the clipping area.\n        ctx.restore();\n      }\n\n      ctx.restore();\n    }\n\n    if (env.wxa) {\n      // Flush for weixin application\n      util.each(this._layers, function (layer) {\n        if (layer && layer.ctx && layer.ctx.draw) {\n          layer.ctx.draw();\n        }\n      });\n    }\n\n    return finished;\n  },\n  _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n    var ctx = currentLayer.ctx;\n    var m = el.transform;\n\n    if ((currentLayer.__dirty || forcePaint) && // Ignore invisible element\n    !el.invisible // Ignore transparent element\n    && el.style.opacity !== 0 // Ignore scale 0 element, in some environment like node-canvas\n    // Draw a scale 0 element can cause all following draw wrong\n    // And setTransform with scale 0 will cause set back transform failed.\n    && !(m && !m[0] && !m[3]) // Ignore culled element\n    && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {\n      var clipPaths = el.__clipPaths; // Optimize when clipping on group with several elements\n\n      if (!scope.prevElClipPaths || isClipPathChanged(clipPaths, scope.prevElClipPaths)) {\n        // If has previous clipping state, restore from it\n        if (scope.prevElClipPaths) {\n          currentLayer.ctx.restore();\n          scope.prevElClipPaths = null; // Reset prevEl since context has been restored\n\n          scope.prevEl = null;\n        } // New clipping state\n\n\n        if (clipPaths) {\n          ctx.save();\n          doClip(clipPaths, ctx);\n          scope.prevElClipPaths = clipPaths;\n        }\n      }\n\n      el.beforeBrush && el.beforeBrush(ctx);\n      el.brush(ctx, scope.prevEl || null);\n      scope.prevEl = el;\n      el.afterBrush && el.afterBrush(ctx);\n    }\n  },\n\n  /**\n   * 获取 zlevel 所在层，如果不存在则会创建一个新的层\n   * @param {number} zlevel\n   * @param {boolean} virtual Virtual layer will not be inserted into dom.\n   * @return {module:zrender/Layer}\n   */\n  getLayer: function (zlevel, virtual) {\n    if (this._singleCanvas && !this._needsManuallyCompositing) {\n      zlevel = CANVAS_ZLEVEL;\n    }\n\n    var layer = this._layers[zlevel];\n\n    if (!layer) {\n      // Create a new layer\n      layer = new Layer('zr_' + zlevel, this, this.dpr);\n      layer.zlevel = zlevel;\n      layer.__builtin__ = true;\n\n      if (this._layerConfig[zlevel]) {\n        util.merge(layer, this._layerConfig[zlevel], true);\n      }\n\n      if (virtual) {\n        layer.virtual = virtual;\n      }\n\n      this.insertLayer(zlevel, layer); // Context is created after dom inserted to document\n      // Or excanvas will get 0px clientWidth and clientHeight\n\n      layer.initContext();\n    }\n\n    return layer;\n  },\n  insertLayer: function (zlevel, layer) {\n    var layersMap = this._layers;\n    var zlevelList = this._zlevelList;\n    var len = zlevelList.length;\n    var prevLayer = null;\n    var i = -1;\n    var domRoot = this._domRoot;\n\n    if (layersMap[zlevel]) {\n      log('ZLevel ' + zlevel + ' has been used already');\n      return;\n    } // Check if is a valid layer\n\n\n    if (!isLayerValid(layer)) {\n      log('Layer of zlevel ' + zlevel + ' is not valid');\n      return;\n    }\n\n    if (len > 0 && zlevel > zlevelList[0]) {\n      for (i = 0; i < len - 1; i++) {\n        if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {\n          break;\n        }\n      }\n\n      prevLayer = layersMap[zlevelList[i]];\n    }\n\n    zlevelList.splice(i + 1, 0, zlevel);\n    layersMap[zlevel] = layer; // Vitual layer will not directly show on the screen.\n    // (It can be a WebGL layer and assigned to a ZImage element)\n    // But it still under management of zrender.\n\n    if (!layer.virtual) {\n      if (prevLayer) {\n        var prevDom = prevLayer.dom;\n\n        if (prevDom.nextSibling) {\n          domRoot.insertBefore(layer.dom, prevDom.nextSibling);\n        } else {\n          domRoot.appendChild(layer.dom);\n        }\n      } else {\n        if (domRoot.firstChild) {\n          domRoot.insertBefore(layer.dom, domRoot.firstChild);\n        } else {\n          domRoot.appendChild(layer.dom);\n        }\n      }\n    }\n  },\n  // Iterate each layer\n  eachLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      cb.call(context, this._layers[z], z);\n    }\n  },\n  // Iterate each buildin layer\n  eachBuiltinLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var layer;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      layer = this._layers[z];\n\n      if (layer.__builtin__) {\n        cb.call(context, layer, z);\n      }\n    }\n  },\n  // Iterate each other layer except buildin layer\n  eachOtherLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var layer;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      layer = this._layers[z];\n\n      if (!layer.__builtin__) {\n        cb.call(context, layer, z);\n      }\n    }\n  },\n\n  /**\n   * 获取所有已创建的层\n   * @param {Array.<module:zrender/Layer>} [prevLayer]\n   */\n  getLayers: function () {\n    return this._layers;\n  },\n  _updateLayerStatus: function (list) {\n    this.eachBuiltinLayer(function (layer, z) {\n      layer.__dirty = layer.__used = false;\n    });\n\n    function updatePrevLayer(idx) {\n      if (prevLayer) {\n        if (prevLayer.__endIndex !== idx) {\n          prevLayer.__dirty = true;\n        }\n\n        prevLayer.__endIndex = idx;\n      }\n    }\n\n    if (this._singleCanvas) {\n      for (var i = 1; i < list.length; i++) {\n        var el = list[i];\n\n        if (el.zlevel !== list[i - 1].zlevel || el.incremental) {\n          this._needsManuallyCompositing = true;\n          break;\n        }\n      }\n    }\n\n    var prevLayer = null;\n    var incrementalLayerCount = 0;\n\n    for (var i = 0; i < list.length; i++) {\n      var el = list[i];\n      var zlevel = el.zlevel;\n      var layer; // PENDING If change one incremental element style ?\n      // TODO Where there are non-incremental elements between incremental elements.\n\n      if (el.incremental) {\n        layer = this.getLayer(zlevel + INCREMENTAL_INC, this._needsManuallyCompositing);\n        layer.incremental = true;\n        incrementalLayerCount = 1;\n      } else {\n        layer = this.getLayer(zlevel + (incrementalLayerCount > 0 ? EL_AFTER_INCREMENTAL_INC : 0), this._needsManuallyCompositing);\n      }\n\n      if (!layer.__builtin__) {\n        log('ZLevel ' + zlevel + ' has been used by unkown layer ' + layer.id);\n      }\n\n      if (layer !== prevLayer) {\n        layer.__used = true;\n\n        if (layer.__startIndex !== i) {\n          layer.__dirty = true;\n        }\n\n        layer.__startIndex = i;\n\n        if (!layer.incremental) {\n          layer.__drawIndex = i;\n        } else {\n          // Mark layer draw index needs to update.\n          layer.__drawIndex = -1;\n        }\n\n        updatePrevLayer(i);\n        prevLayer = layer;\n      }\n\n      if (el.__dirty) {\n        layer.__dirty = true;\n\n        if (layer.incremental && layer.__drawIndex < 0) {\n          // Start draw from the first dirty element.\n          layer.__drawIndex = i;\n        }\n      }\n    }\n\n    updatePrevLayer(i);\n    this.eachBuiltinLayer(function (layer, z) {\n      // Used in last frame but not in this frame. Needs clear\n      if (!layer.__used && layer.getElementCount() > 0) {\n        layer.__dirty = true;\n        layer.__startIndex = layer.__endIndex = layer.__drawIndex = 0;\n      } // For incremental layer. In case start index changed and no elements are dirty.\n\n\n      if (layer.__dirty && layer.__drawIndex < 0) {\n        layer.__drawIndex = layer.__startIndex;\n      }\n    });\n  },\n\n  /**\n   * 清除hover层外所有内容\n   */\n  clear: function () {\n    this.eachBuiltinLayer(this._clearLayer);\n    return this;\n  },\n  _clearLayer: function (layer) {\n    layer.clear();\n  },\n  setBackgroundColor: function (backgroundColor) {\n    this._backgroundColor = backgroundColor;\n  },\n\n  /**\n   * 修改指定zlevel的绘制参数\n   *\n   * @param {string} zlevel\n   * @param {Object} config 配置对象\n   * @param {string} [config.clearColor=0] 每次清空画布的颜色\n   * @param {string} [config.motionBlur=false] 是否开启动态模糊\n   * @param {number} [config.lastFrameAlpha=0.7]\n   *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n   */\n  configLayer: function (zlevel, config) {\n    if (config) {\n      var layerConfig = this._layerConfig;\n\n      if (!layerConfig[zlevel]) {\n        layerConfig[zlevel] = config;\n      } else {\n        util.merge(layerConfig[zlevel], config, true);\n      }\n\n      for (var i = 0; i < this._zlevelList.length; i++) {\n        var _zlevel = this._zlevelList[i];\n\n        if (_zlevel === zlevel || _zlevel === zlevel + EL_AFTER_INCREMENTAL_INC) {\n          var layer = this._layers[_zlevel];\n          util.merge(layer, layerConfig[zlevel], true);\n        }\n      }\n    }\n  },\n\n  /**\n   * 删除指定层\n   * @param {number} zlevel 层所在的zlevel\n   */\n  delLayer: function (zlevel) {\n    var layers = this._layers;\n    var zlevelList = this._zlevelList;\n    var layer = layers[zlevel];\n\n    if (!layer) {\n      return;\n    }\n\n    layer.dom.parentNode.removeChild(layer.dom);\n    delete layers[zlevel];\n    zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n  },\n\n  /**\n   * 区域大小变化后重绘\n   */\n  resize: function (width, height) {\n    if (!this._domRoot.style) {\n      // Maybe in node or worker\n      if (width == null || height == null) {\n        return;\n      }\n\n      this._width = width;\n      this._height = height;\n      this.getLayer(CANVAS_ZLEVEL).resize(width, height);\n    } else {\n      var domRoot = this._domRoot; // FIXME Why ?\n\n      domRoot.style.display = 'none'; // Save input w/h\n\n      var opts = this._opts;\n      width != null && (opts.width = width);\n      height != null && (opts.height = height);\n      width = this._getSize(0);\n      height = this._getSize(1);\n      domRoot.style.display = ''; // 优化没有实际改变的resize\n\n      if (this._width != width || height != this._height) {\n        domRoot.style.width = width + 'px';\n        domRoot.style.height = height + 'px';\n\n        for (var id in this._layers) {\n          if (this._layers.hasOwnProperty(id)) {\n            this._layers[id].resize(width, height);\n          }\n        }\n\n        util.each(this._progressiveLayers, function (layer) {\n          layer.resize(width, height);\n        });\n        this.refresh(true);\n      }\n\n      this._width = width;\n      this._height = height;\n    }\n\n    return this;\n  },\n\n  /**\n   * 清除单独的一个层\n   * @param {number} zlevel\n   */\n  clearLayer: function (zlevel) {\n    var layer = this._layers[zlevel];\n\n    if (layer) {\n      layer.clear();\n    }\n  },\n\n  /**\n   * 释放\n   */\n  dispose: function () {\n    this.root.innerHTML = '';\n    this.root = this.storage = this._domRoot = this._layers = null;\n  },\n\n  /**\n   * Get canvas which has all thing rendered\n   * @param {Object} opts\n   * @param {string} [opts.backgroundColor]\n   * @param {number} [opts.pixelRatio]\n   */\n  getRenderedCanvas: function (opts) {\n    opts = opts || {};\n\n    if (this._singleCanvas && !this._compositeManually) {\n      return this._layers[CANVAS_ZLEVEL].dom;\n    }\n\n    var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n    imageLayer.initContext();\n    imageLayer.clear(false, opts.backgroundColor || this._backgroundColor);\n\n    if (opts.pixelRatio <= this.dpr) {\n      this.refresh();\n      var width = imageLayer.dom.width;\n      var height = imageLayer.dom.height;\n      var ctx = imageLayer.ctx;\n      this.eachLayer(function (layer) {\n        if (layer.__builtin__) {\n          ctx.drawImage(layer.dom, 0, 0, width, height);\n        } else if (layer.renderToCanvas) {\n          imageLayer.ctx.save();\n          layer.renderToCanvas(imageLayer.ctx);\n          imageLayer.ctx.restore();\n        }\n      });\n    } else {\n      // PENDING, echarts-gl and incremental rendering.\n      var scope = {};\n      var displayList = this.storage.getDisplayList(true);\n\n      for (var i = 0; i < displayList.length; i++) {\n        var el = displayList[i];\n\n        this._doPaintEl(el, imageLayer, true, scope);\n      }\n    }\n\n    return imageLayer.dom;\n  },\n\n  /**\n   * 获取绘图区域宽度\n   */\n  getWidth: function () {\n    return this._width;\n  },\n\n  /**\n   * 获取绘图区域高度\n   */\n  getHeight: function () {\n    return this._height;\n  },\n  _getSize: function (whIdx) {\n    var opts = this._opts;\n    var wh = ['width', 'height'][whIdx];\n    var cwh = ['clientWidth', 'clientHeight'][whIdx];\n    var plt = ['paddingLeft', 'paddingTop'][whIdx];\n    var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n    if (opts[wh] != null && opts[wh] !== 'auto') {\n      return parseFloat(opts[wh]);\n    }\n\n    var root = this.root; // IE8 does not support getComputedStyle, but it use VML.\n\n    var stl = document.defaultView.getComputedStyle(root);\n    return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;\n  },\n  pathToImage: function (path, dpr) {\n    dpr = dpr || this.dpr;\n    var canvas = document.createElement('canvas');\n    var ctx = canvas.getContext('2d');\n    var rect = path.getBoundingRect();\n    var style = path.style;\n    var shadowBlurSize = style.shadowBlur * dpr;\n    var shadowOffsetX = style.shadowOffsetX * dpr;\n    var shadowOffsetY = style.shadowOffsetY * dpr;\n    var lineWidth = style.hasStroke() ? style.lineWidth : 0;\n    var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n    var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n    var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n    var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n    var width = rect.width + leftMargin + rightMargin;\n    var height = rect.height + topMargin + bottomMargin;\n    canvas.width = width * dpr;\n    canvas.height = height * dpr;\n    ctx.scale(dpr, dpr);\n    ctx.clearRect(0, 0, width, height);\n    ctx.dpr = dpr;\n    var pathTransform = {\n      position: path.position,\n      rotation: path.rotation,\n      scale: path.scale\n    };\n    path.position = [leftMargin - rect.x, topMargin - rect.y];\n    path.rotation = 0;\n    path.scale = [1, 1];\n    path.updateTransform();\n\n    if (path) {\n      path.brush(ctx);\n    }\n\n    var ImageShape = Image;\n    var imgShape = new ImageShape({\n      style: {\n        x: 0,\n        y: 0,\n        image: canvas\n      }\n    });\n\n    if (pathTransform.position != null) {\n      imgShape.position = path.position = pathTransform.position;\n    }\n\n    if (pathTransform.rotation != null) {\n      imgShape.rotation = path.rotation = pathTransform.rotation;\n    }\n\n    if (pathTransform.scale != null) {\n      imgShape.scale = path.scale = pathTransform.scale;\n    }\n\n    return imgShape;\n  }\n};\nvar _default = Painter;\nmodule.exports = _default;","map":{"version":3,"names":["_config","require","devicePixelRatio","util","log","BoundingRect","timsort","Layer","requestAnimationFrame","Image","env","HOVER_LAYER_ZLEVEL","CANVAS_ZLEVEL","EL_AFTER_INCREMENTAL_INC","INCREMENTAL_INC","parseInt10","val","parseInt","isLayerValid","layer","__builtin__","resize","refresh","tmpRect","viewRect","isDisplayableCulled","el","width","height","copy","getBoundingRect","transform","applyTransform","intersect","isClipPathChanged","clipPaths","prevClipPaths","length","i","doClip","ctx","clipPath","setTransform","beginPath","buildPath","shape","clip","restoreTransform","createRoot","domRoot","document","createElement","style","cssText","join","Painter","root","storage","opts","type","singleCanvas","nodeName","toUpperCase","_opts","extend","dpr","_singleCanvas","rootStyle","innerHTML","zlevelList","_zlevelList","layers","_layers","_layerConfig","_needsManuallyCompositing","_width","_getSize","_height","_domRoot","appendChild","mainLayer","initContext","zlevel","push","_hoverlayer","_hoverElements","prototype","constructor","getType","isSingleCanvas","getViewportRoot","getViewportRootOffset","viewportRoot","offsetLeft","offsetTop","paintAll","list","getDisplayList","_redrawId","Math","random","_paintList","z","clearColor","_backgroundColor","refreshHover","addHover","hoverStyle","__hoverMir","elMirror","__from","setStyle","removeHover","hoverElements","idx","indexOf","splice","clearHover","from","len","hoverLayer","clear","displayableSortFunc","getLayer","scope","save","originalEl","__zr","invisible","invTransform","__clipPaths","_doPaintEl","restore","getHoverLayer","redrawId","_updateLayerStatus","finished","_doPaintList","_compositeManually","self","clearRect","eachBuiltinLayer","virtual","drawImage","dom","layerList","zi","__dirty","k","start","__startIndex","__drawIndex","useTimer","incremental","Date","now","startTime","__endIndex","firstEl","notClear","console","error","dTime","prevElClipPaths","wxa","each","draw","currentLayer","forcePaint","m","opacity","culling","prevEl","beforeBrush","brush","afterBrush","merge","insertLayer","layersMap","prevLayer","prevDom","nextSibling","insertBefore","firstChild","eachLayer","cb","context","call","eachOtherLayer","getLayers","__used","updatePrevLayer","incrementalLayerCount","id","getElementCount","_clearLayer","setBackgroundColor","backgroundColor","configLayer","config","layerConfig","_zlevel","delLayer","parentNode","removeChild","display","hasOwnProperty","_progressiveLayers","clearLayer","dispose","getRenderedCanvas","imageLayer","pixelRatio","renderToCanvas","displayList","getWidth","getHeight","whIdx","wh","cwh","plt","prb","parseFloat","stl","defaultView","getComputedStyle","pathToImage","path","canvas","getContext","rect","shadowBlurSize","shadowBlur","shadowOffsetX","shadowOffsetY","lineWidth","hasStroke","leftMargin","max","rightMargin","topMargin","bottomMargin","scale","pathTransform","position","rotation","x","y","updateTransform","ImageShape","imgShape","image","_default","module","exports"],"sources":["C:/Users/W/Desktop/vue_map/node_modules/zrender/lib/Painter.js"],"sourcesContent":["var _config = require(\"./config\");\n\nvar devicePixelRatio = _config.devicePixelRatio;\n\nvar util = require(\"./core/util\");\n\nvar log = require(\"./core/log\");\n\nvar BoundingRect = require(\"./core/BoundingRect\");\n\nvar timsort = require(\"./core/timsort\");\n\nvar Layer = require(\"./Layer\");\n\nvar requestAnimationFrame = require(\"./animation/requestAnimationFrame\");\n\nvar Image = require(\"./graphic/Image\");\n\nvar env = require(\"./core/env\");\n\nvar HOVER_LAYER_ZLEVEL = 1e5;\nvar CANVAS_ZLEVEL = 314159;\nvar EL_AFTER_INCREMENTAL_INC = 0.01;\nvar INCREMENTAL_INC = 0.001;\n\nfunction parseInt10(val) {\n  return parseInt(val, 10);\n}\n\nfunction isLayerValid(layer) {\n  if (!layer) {\n    return false;\n  }\n\n  if (layer.__builtin__) {\n    return true;\n  }\n\n  if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {\n    return false;\n  }\n\n  return true;\n}\n\nvar tmpRect = new BoundingRect(0, 0, 0, 0);\nvar viewRect = new BoundingRect(0, 0, 0, 0);\n\nfunction isDisplayableCulled(el, width, height) {\n  tmpRect.copy(el.getBoundingRect());\n\n  if (el.transform) {\n    tmpRect.applyTransform(el.transform);\n  }\n\n  viewRect.width = width;\n  viewRect.height = height;\n  return !tmpRect.intersect(viewRect);\n}\n\nfunction isClipPathChanged(clipPaths, prevClipPaths) {\n  if (clipPaths == prevClipPaths) {\n    // Can both be null or undefined\n    return false;\n  }\n\n  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {\n    return true;\n  }\n\n  for (var i = 0; i < clipPaths.length; i++) {\n    if (clipPaths[i] !== prevClipPaths[i]) {\n      return true;\n    }\n  }\n}\n\nfunction doClip(clipPaths, ctx) {\n  for (var i = 0; i < clipPaths.length; i++) {\n    var clipPath = clipPaths[i];\n    clipPath.setTransform(ctx);\n    ctx.beginPath();\n    clipPath.buildPath(ctx, clipPath.shape);\n    ctx.clip(); // Transform back\n\n    clipPath.restoreTransform(ctx);\n  }\n}\n\nfunction createRoot(width, height) {\n  var domRoot = document.createElement('div'); // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬\n\n  domRoot.style.cssText = ['position:relative', 'overflow:hidden', 'width:' + width + 'px', 'height:' + height + 'px', 'padding:0', 'margin:0', 'border-width:0'].join(';') + ';';\n  return domRoot;\n}\n/**\n * @alias module:zrender/Painter\n * @constructor\n * @param {HTMLElement} root 绘图容器\n * @param {module:zrender/Storage} storage\n * @param {Object} opts\n */\n\n\nvar Painter = function (root, storage, opts) {\n  this.type = 'canvas'; // In node environment using node-canvas\n\n  var singleCanvas = !root.nodeName // In node ?\n  || root.nodeName.toUpperCase() === 'CANVAS';\n  this._opts = opts = util.extend({}, opts || {});\n  /**\n   * @type {number}\n   */\n\n  this.dpr = opts.devicePixelRatio || devicePixelRatio;\n  /**\n   * @type {boolean}\n   * @private\n   */\n\n  this._singleCanvas = singleCanvas;\n  /**\n   * 绘图容器\n   * @type {HTMLElement}\n   */\n\n  this.root = root;\n  var rootStyle = root.style;\n\n  if (rootStyle) {\n    rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n    rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';\n    root.innerHTML = '';\n  }\n  /**\n   * @type {module:zrender/Storage}\n   */\n\n\n  this.storage = storage;\n  /**\n   * @type {Array.<number>}\n   * @private\n   */\n\n  var zlevelList = this._zlevelList = [];\n  /**\n   * @type {Object.<string, module:zrender/Layer>}\n   * @private\n   */\n\n  var layers = this._layers = {};\n  /**\n   * @type {Object.<string, Object>}\n   * @private\n   */\n\n  this._layerConfig = {};\n  /**\n   * zrender will do compositing when root is a canvas and have multiple zlevels.\n   */\n\n  this._needsManuallyCompositing = false;\n\n  if (!singleCanvas) {\n    this._width = this._getSize(0);\n    this._height = this._getSize(1);\n    var domRoot = this._domRoot = createRoot(this._width, this._height);\n    root.appendChild(domRoot);\n  } else {\n    var width = root.width;\n    var height = root.height;\n\n    if (opts.width != null) {\n      width = opts.width;\n    }\n\n    if (opts.height != null) {\n      height = opts.height;\n    }\n\n    this.dpr = opts.devicePixelRatio || 1; // Use canvas width and height directly\n\n    root.width = width * this.dpr;\n    root.height = height * this.dpr;\n    this._width = width;\n    this._height = height; // Create layer if only one given canvas\n    // Device can be specified to create a high dpi image.\n\n    var mainLayer = new Layer(root, this, this.dpr);\n    mainLayer.__builtin__ = true;\n    mainLayer.initContext(); // FIXME Use canvas width and height\n    // mainLayer.resize(width, height);\n\n    layers[CANVAS_ZLEVEL] = mainLayer;\n    mainLayer.zlevel = CANVAS_ZLEVEL; // Not use common zlevel.\n\n    zlevelList.push(CANVAS_ZLEVEL);\n    this._domRoot = root;\n  }\n  /**\n   * @type {module:zrender/Layer}\n   * @private\n   */\n\n\n  this._hoverlayer = null;\n  this._hoverElements = [];\n};\n\nPainter.prototype = {\n  constructor: Painter,\n  getType: function () {\n    return 'canvas';\n  },\n\n  /**\n   * If painter use a single canvas\n   * @return {boolean}\n   */\n  isSingleCanvas: function () {\n    return this._singleCanvas;\n  },\n\n  /**\n   * @return {HTMLDivElement}\n   */\n  getViewportRoot: function () {\n    return this._domRoot;\n  },\n  getViewportRootOffset: function () {\n    var viewportRoot = this.getViewportRoot();\n\n    if (viewportRoot) {\n      return {\n        offsetLeft: viewportRoot.offsetLeft || 0,\n        offsetTop: viewportRoot.offsetTop || 0\n      };\n    }\n  },\n\n  /**\n   * 刷新\n   * @param {boolean} [paintAll=false] 强制绘制所有displayable\n   */\n  refresh: function (paintAll) {\n    var list = this.storage.getDisplayList(true);\n    var zlevelList = this._zlevelList;\n    this._redrawId = Math.random();\n\n    this._paintList(list, paintAll, this._redrawId); // Paint custum layers\n\n\n    for (var i = 0; i < zlevelList.length; i++) {\n      var z = zlevelList[i];\n      var layer = this._layers[z];\n\n      if (!layer.__builtin__ && layer.refresh) {\n        var clearColor = i === 0 ? this._backgroundColor : null;\n        layer.refresh(clearColor);\n      }\n    }\n\n    this.refreshHover();\n    return this;\n  },\n  addHover: function (el, hoverStyle) {\n    if (el.__hoverMir) {\n      return;\n    }\n\n    var elMirror = new el.constructor({\n      style: el.style,\n      shape: el.shape\n    });\n    elMirror.__from = el;\n    el.__hoverMir = elMirror;\n    elMirror.setStyle(hoverStyle);\n\n    this._hoverElements.push(elMirror);\n  },\n  removeHover: function (el) {\n    var elMirror = el.__hoverMir;\n    var hoverElements = this._hoverElements;\n    var idx = util.indexOf(hoverElements, elMirror);\n\n    if (idx >= 0) {\n      hoverElements.splice(idx, 1);\n    }\n\n    el.__hoverMir = null;\n  },\n  clearHover: function (el) {\n    var hoverElements = this._hoverElements;\n\n    for (var i = 0; i < hoverElements.length; i++) {\n      var from = hoverElements[i].__from;\n\n      if (from) {\n        from.__hoverMir = null;\n      }\n    }\n\n    hoverElements.length = 0;\n  },\n  refreshHover: function () {\n    var hoverElements = this._hoverElements;\n    var len = hoverElements.length;\n    var hoverLayer = this._hoverlayer;\n    hoverLayer && hoverLayer.clear();\n\n    if (!len) {\n      return;\n    }\n\n    timsort(hoverElements, this.storage.displayableSortFunc); // Use a extream large zlevel\n    // FIXME?\n\n    if (!hoverLayer) {\n      hoverLayer = this._hoverlayer = this.getLayer(HOVER_LAYER_ZLEVEL);\n    }\n\n    var scope = {};\n    hoverLayer.ctx.save();\n\n    for (var i = 0; i < len;) {\n      var el = hoverElements[i];\n      var originalEl = el.__from; // Original el is removed\n      // PENDING\n\n      if (!(originalEl && originalEl.__zr)) {\n        hoverElements.splice(i, 1);\n        originalEl.__hoverMir = null;\n        len--;\n        continue;\n      }\n\n      i++; // Use transform\n      // FIXME style and shape ?\n\n      if (!originalEl.invisible) {\n        el.transform = originalEl.transform;\n        el.invTransform = originalEl.invTransform;\n        el.__clipPaths = originalEl.__clipPaths; // el.\n\n        this._doPaintEl(el, hoverLayer, true, scope);\n      }\n    }\n\n    hoverLayer.ctx.restore();\n  },\n  getHoverLayer: function () {\n    return this.getLayer(HOVER_LAYER_ZLEVEL);\n  },\n  _paintList: function (list, paintAll, redrawId) {\n    if (this._redrawId !== redrawId) {\n      return;\n    }\n\n    paintAll = paintAll || false;\n\n    this._updateLayerStatus(list);\n\n    var finished = this._doPaintList(list, paintAll);\n\n    if (this._needsManuallyCompositing) {\n      this._compositeManually();\n    }\n\n    if (!finished) {\n      var self = this;\n      requestAnimationFrame(function () {\n        self._paintList(list, paintAll, redrawId);\n      });\n    }\n  },\n  _compositeManually: function () {\n    var ctx = this.getLayer(CANVAS_ZLEVEL).ctx;\n    var width = this._domRoot.width;\n    var height = this._domRoot.height;\n    ctx.clearRect(0, 0, width, height); // PENDING, If only builtin layer?\n\n    this.eachBuiltinLayer(function (layer) {\n      if (layer.virtual) {\n        ctx.drawImage(layer.dom, 0, 0, width, height);\n      }\n    });\n  },\n  _doPaintList: function (list, paintAll) {\n    var layerList = [];\n\n    for (var zi = 0; zi < this._zlevelList.length; zi++) {\n      var zlevel = this._zlevelList[zi];\n      var layer = this._layers[zlevel];\n\n      if (layer.__builtin__ && layer !== this._hoverlayer && (layer.__dirty || paintAll)) {\n        layerList.push(layer);\n      }\n    }\n\n    var finished = true;\n\n    for (var k = 0; k < layerList.length; k++) {\n      var layer = layerList[k];\n      var ctx = layer.ctx;\n      var scope = {};\n      ctx.save();\n      var start = paintAll ? layer.__startIndex : layer.__drawIndex;\n      var useTimer = !paintAll && layer.incremental && Date.now;\n      var startTime = useTimer && Date.now();\n      var clearColor = layer.zlevel === this._zlevelList[0] ? this._backgroundColor : null; // All elements in this layer are cleared.\n\n      if (layer.__startIndex === layer.__endIndex) {\n        layer.clear(false, clearColor);\n      } else if (start === layer.__startIndex) {\n        var firstEl = list[start];\n\n        if (!firstEl.incremental || !firstEl.notClear || paintAll) {\n          layer.clear(false, clearColor);\n        }\n      }\n\n      if (start === -1) {\n        console.error('For some unknown reason. drawIndex is -1');\n        start = layer.__startIndex;\n      }\n\n      for (var i = start; i < layer.__endIndex; i++) {\n        var el = list[i];\n\n        this._doPaintEl(el, layer, paintAll, scope);\n\n        el.__dirty = false;\n\n        if (useTimer) {\n          // Date.now can be executed in 13,025,305 ops/second.\n          var dTime = Date.now() - startTime; // Give 15 millisecond to draw.\n          // The rest elements will be drawn in the next frame.\n\n          if (dTime > 15) {\n            break;\n          }\n        }\n      }\n\n      layer.__drawIndex = i;\n\n      if (layer.__drawIndex < layer.__endIndex) {\n        finished = false;\n      }\n\n      if (scope.prevElClipPaths) {\n        // Needs restore the state. If last drawn element is in the clipping area.\n        ctx.restore();\n      }\n\n      ctx.restore();\n    }\n\n    if (env.wxa) {\n      // Flush for weixin application\n      util.each(this._layers, function (layer) {\n        if (layer && layer.ctx && layer.ctx.draw) {\n          layer.ctx.draw();\n        }\n      });\n    }\n\n    return finished;\n  },\n  _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n    var ctx = currentLayer.ctx;\n    var m = el.transform;\n\n    if ((currentLayer.__dirty || forcePaint) && // Ignore invisible element\n    !el.invisible // Ignore transparent element\n    && el.style.opacity !== 0 // Ignore scale 0 element, in some environment like node-canvas\n    // Draw a scale 0 element can cause all following draw wrong\n    // And setTransform with scale 0 will cause set back transform failed.\n    && !(m && !m[0] && !m[3]) // Ignore culled element\n    && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {\n      var clipPaths = el.__clipPaths; // Optimize when clipping on group with several elements\n\n      if (!scope.prevElClipPaths || isClipPathChanged(clipPaths, scope.prevElClipPaths)) {\n        // If has previous clipping state, restore from it\n        if (scope.prevElClipPaths) {\n          currentLayer.ctx.restore();\n          scope.prevElClipPaths = null; // Reset prevEl since context has been restored\n\n          scope.prevEl = null;\n        } // New clipping state\n\n\n        if (clipPaths) {\n          ctx.save();\n          doClip(clipPaths, ctx);\n          scope.prevElClipPaths = clipPaths;\n        }\n      }\n\n      el.beforeBrush && el.beforeBrush(ctx);\n      el.brush(ctx, scope.prevEl || null);\n      scope.prevEl = el;\n      el.afterBrush && el.afterBrush(ctx);\n    }\n  },\n\n  /**\n   * 获取 zlevel 所在层，如果不存在则会创建一个新的层\n   * @param {number} zlevel\n   * @param {boolean} virtual Virtual layer will not be inserted into dom.\n   * @return {module:zrender/Layer}\n   */\n  getLayer: function (zlevel, virtual) {\n    if (this._singleCanvas && !this._needsManuallyCompositing) {\n      zlevel = CANVAS_ZLEVEL;\n    }\n\n    var layer = this._layers[zlevel];\n\n    if (!layer) {\n      // Create a new layer\n      layer = new Layer('zr_' + zlevel, this, this.dpr);\n      layer.zlevel = zlevel;\n      layer.__builtin__ = true;\n\n      if (this._layerConfig[zlevel]) {\n        util.merge(layer, this._layerConfig[zlevel], true);\n      }\n\n      if (virtual) {\n        layer.virtual = virtual;\n      }\n\n      this.insertLayer(zlevel, layer); // Context is created after dom inserted to document\n      // Or excanvas will get 0px clientWidth and clientHeight\n\n      layer.initContext();\n    }\n\n    return layer;\n  },\n  insertLayer: function (zlevel, layer) {\n    var layersMap = this._layers;\n    var zlevelList = this._zlevelList;\n    var len = zlevelList.length;\n    var prevLayer = null;\n    var i = -1;\n    var domRoot = this._domRoot;\n\n    if (layersMap[zlevel]) {\n      log('ZLevel ' + zlevel + ' has been used already');\n      return;\n    } // Check if is a valid layer\n\n\n    if (!isLayerValid(layer)) {\n      log('Layer of zlevel ' + zlevel + ' is not valid');\n      return;\n    }\n\n    if (len > 0 && zlevel > zlevelList[0]) {\n      for (i = 0; i < len - 1; i++) {\n        if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {\n          break;\n        }\n      }\n\n      prevLayer = layersMap[zlevelList[i]];\n    }\n\n    zlevelList.splice(i + 1, 0, zlevel);\n    layersMap[zlevel] = layer; // Vitual layer will not directly show on the screen.\n    // (It can be a WebGL layer and assigned to a ZImage element)\n    // But it still under management of zrender.\n\n    if (!layer.virtual) {\n      if (prevLayer) {\n        var prevDom = prevLayer.dom;\n\n        if (prevDom.nextSibling) {\n          domRoot.insertBefore(layer.dom, prevDom.nextSibling);\n        } else {\n          domRoot.appendChild(layer.dom);\n        }\n      } else {\n        if (domRoot.firstChild) {\n          domRoot.insertBefore(layer.dom, domRoot.firstChild);\n        } else {\n          domRoot.appendChild(layer.dom);\n        }\n      }\n    }\n  },\n  // Iterate each layer\n  eachLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      cb.call(context, this._layers[z], z);\n    }\n  },\n  // Iterate each buildin layer\n  eachBuiltinLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var layer;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      layer = this._layers[z];\n\n      if (layer.__builtin__) {\n        cb.call(context, layer, z);\n      }\n    }\n  },\n  // Iterate each other layer except buildin layer\n  eachOtherLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var layer;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      layer = this._layers[z];\n\n      if (!layer.__builtin__) {\n        cb.call(context, layer, z);\n      }\n    }\n  },\n\n  /**\n   * 获取所有已创建的层\n   * @param {Array.<module:zrender/Layer>} [prevLayer]\n   */\n  getLayers: function () {\n    return this._layers;\n  },\n  _updateLayerStatus: function (list) {\n    this.eachBuiltinLayer(function (layer, z) {\n      layer.__dirty = layer.__used = false;\n    });\n\n    function updatePrevLayer(idx) {\n      if (prevLayer) {\n        if (prevLayer.__endIndex !== idx) {\n          prevLayer.__dirty = true;\n        }\n\n        prevLayer.__endIndex = idx;\n      }\n    }\n\n    if (this._singleCanvas) {\n      for (var i = 1; i < list.length; i++) {\n        var el = list[i];\n\n        if (el.zlevel !== list[i - 1].zlevel || el.incremental) {\n          this._needsManuallyCompositing = true;\n          break;\n        }\n      }\n    }\n\n    var prevLayer = null;\n    var incrementalLayerCount = 0;\n\n    for (var i = 0; i < list.length; i++) {\n      var el = list[i];\n      var zlevel = el.zlevel;\n      var layer; // PENDING If change one incremental element style ?\n      // TODO Where there are non-incremental elements between incremental elements.\n\n      if (el.incremental) {\n        layer = this.getLayer(zlevel + INCREMENTAL_INC, this._needsManuallyCompositing);\n        layer.incremental = true;\n        incrementalLayerCount = 1;\n      } else {\n        layer = this.getLayer(zlevel + (incrementalLayerCount > 0 ? EL_AFTER_INCREMENTAL_INC : 0), this._needsManuallyCompositing);\n      }\n\n      if (!layer.__builtin__) {\n        log('ZLevel ' + zlevel + ' has been used by unkown layer ' + layer.id);\n      }\n\n      if (layer !== prevLayer) {\n        layer.__used = true;\n\n        if (layer.__startIndex !== i) {\n          layer.__dirty = true;\n        }\n\n        layer.__startIndex = i;\n\n        if (!layer.incremental) {\n          layer.__drawIndex = i;\n        } else {\n          // Mark layer draw index needs to update.\n          layer.__drawIndex = -1;\n        }\n\n        updatePrevLayer(i);\n        prevLayer = layer;\n      }\n\n      if (el.__dirty) {\n        layer.__dirty = true;\n\n        if (layer.incremental && layer.__drawIndex < 0) {\n          // Start draw from the first dirty element.\n          layer.__drawIndex = i;\n        }\n      }\n    }\n\n    updatePrevLayer(i);\n    this.eachBuiltinLayer(function (layer, z) {\n      // Used in last frame but not in this frame. Needs clear\n      if (!layer.__used && layer.getElementCount() > 0) {\n        layer.__dirty = true;\n        layer.__startIndex = layer.__endIndex = layer.__drawIndex = 0;\n      } // For incremental layer. In case start index changed and no elements are dirty.\n\n\n      if (layer.__dirty && layer.__drawIndex < 0) {\n        layer.__drawIndex = layer.__startIndex;\n      }\n    });\n  },\n\n  /**\n   * 清除hover层外所有内容\n   */\n  clear: function () {\n    this.eachBuiltinLayer(this._clearLayer);\n    return this;\n  },\n  _clearLayer: function (layer) {\n    layer.clear();\n  },\n  setBackgroundColor: function (backgroundColor) {\n    this._backgroundColor = backgroundColor;\n  },\n\n  /**\n   * 修改指定zlevel的绘制参数\n   *\n   * @param {string} zlevel\n   * @param {Object} config 配置对象\n   * @param {string} [config.clearColor=0] 每次清空画布的颜色\n   * @param {string} [config.motionBlur=false] 是否开启动态模糊\n   * @param {number} [config.lastFrameAlpha=0.7]\n   *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n   */\n  configLayer: function (zlevel, config) {\n    if (config) {\n      var layerConfig = this._layerConfig;\n\n      if (!layerConfig[zlevel]) {\n        layerConfig[zlevel] = config;\n      } else {\n        util.merge(layerConfig[zlevel], config, true);\n      }\n\n      for (var i = 0; i < this._zlevelList.length; i++) {\n        var _zlevel = this._zlevelList[i];\n\n        if (_zlevel === zlevel || _zlevel === zlevel + EL_AFTER_INCREMENTAL_INC) {\n          var layer = this._layers[_zlevel];\n          util.merge(layer, layerConfig[zlevel], true);\n        }\n      }\n    }\n  },\n\n  /**\n   * 删除指定层\n   * @param {number} zlevel 层所在的zlevel\n   */\n  delLayer: function (zlevel) {\n    var layers = this._layers;\n    var zlevelList = this._zlevelList;\n    var layer = layers[zlevel];\n\n    if (!layer) {\n      return;\n    }\n\n    layer.dom.parentNode.removeChild(layer.dom);\n    delete layers[zlevel];\n    zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n  },\n\n  /**\n   * 区域大小变化后重绘\n   */\n  resize: function (width, height) {\n    if (!this._domRoot.style) {\n      // Maybe in node or worker\n      if (width == null || height == null) {\n        return;\n      }\n\n      this._width = width;\n      this._height = height;\n      this.getLayer(CANVAS_ZLEVEL).resize(width, height);\n    } else {\n      var domRoot = this._domRoot; // FIXME Why ?\n\n      domRoot.style.display = 'none'; // Save input w/h\n\n      var opts = this._opts;\n      width != null && (opts.width = width);\n      height != null && (opts.height = height);\n      width = this._getSize(0);\n      height = this._getSize(1);\n      domRoot.style.display = ''; // 优化没有实际改变的resize\n\n      if (this._width != width || height != this._height) {\n        domRoot.style.width = width + 'px';\n        domRoot.style.height = height + 'px';\n\n        for (var id in this._layers) {\n          if (this._layers.hasOwnProperty(id)) {\n            this._layers[id].resize(width, height);\n          }\n        }\n\n        util.each(this._progressiveLayers, function (layer) {\n          layer.resize(width, height);\n        });\n        this.refresh(true);\n      }\n\n      this._width = width;\n      this._height = height;\n    }\n\n    return this;\n  },\n\n  /**\n   * 清除单独的一个层\n   * @param {number} zlevel\n   */\n  clearLayer: function (zlevel) {\n    var layer = this._layers[zlevel];\n\n    if (layer) {\n      layer.clear();\n    }\n  },\n\n  /**\n   * 释放\n   */\n  dispose: function () {\n    this.root.innerHTML = '';\n    this.root = this.storage = this._domRoot = this._layers = null;\n  },\n\n  /**\n   * Get canvas which has all thing rendered\n   * @param {Object} opts\n   * @param {string} [opts.backgroundColor]\n   * @param {number} [opts.pixelRatio]\n   */\n  getRenderedCanvas: function (opts) {\n    opts = opts || {};\n\n    if (this._singleCanvas && !this._compositeManually) {\n      return this._layers[CANVAS_ZLEVEL].dom;\n    }\n\n    var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n    imageLayer.initContext();\n    imageLayer.clear(false, opts.backgroundColor || this._backgroundColor);\n\n    if (opts.pixelRatio <= this.dpr) {\n      this.refresh();\n      var width = imageLayer.dom.width;\n      var height = imageLayer.dom.height;\n      var ctx = imageLayer.ctx;\n      this.eachLayer(function (layer) {\n        if (layer.__builtin__) {\n          ctx.drawImage(layer.dom, 0, 0, width, height);\n        } else if (layer.renderToCanvas) {\n          imageLayer.ctx.save();\n          layer.renderToCanvas(imageLayer.ctx);\n          imageLayer.ctx.restore();\n        }\n      });\n    } else {\n      // PENDING, echarts-gl and incremental rendering.\n      var scope = {};\n      var displayList = this.storage.getDisplayList(true);\n\n      for (var i = 0; i < displayList.length; i++) {\n        var el = displayList[i];\n\n        this._doPaintEl(el, imageLayer, true, scope);\n      }\n    }\n\n    return imageLayer.dom;\n  },\n\n  /**\n   * 获取绘图区域宽度\n   */\n  getWidth: function () {\n    return this._width;\n  },\n\n  /**\n   * 获取绘图区域高度\n   */\n  getHeight: function () {\n    return this._height;\n  },\n  _getSize: function (whIdx) {\n    var opts = this._opts;\n    var wh = ['width', 'height'][whIdx];\n    var cwh = ['clientWidth', 'clientHeight'][whIdx];\n    var plt = ['paddingLeft', 'paddingTop'][whIdx];\n    var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n    if (opts[wh] != null && opts[wh] !== 'auto') {\n      return parseFloat(opts[wh]);\n    }\n\n    var root = this.root; // IE8 does not support getComputedStyle, but it use VML.\n\n    var stl = document.defaultView.getComputedStyle(root);\n    return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;\n  },\n  pathToImage: function (path, dpr) {\n    dpr = dpr || this.dpr;\n    var canvas = document.createElement('canvas');\n    var ctx = canvas.getContext('2d');\n    var rect = path.getBoundingRect();\n    var style = path.style;\n    var shadowBlurSize = style.shadowBlur * dpr;\n    var shadowOffsetX = style.shadowOffsetX * dpr;\n    var shadowOffsetY = style.shadowOffsetY * dpr;\n    var lineWidth = style.hasStroke() ? style.lineWidth : 0;\n    var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n    var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n    var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n    var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n    var width = rect.width + leftMargin + rightMargin;\n    var height = rect.height + topMargin + bottomMargin;\n    canvas.width = width * dpr;\n    canvas.height = height * dpr;\n    ctx.scale(dpr, dpr);\n    ctx.clearRect(0, 0, width, height);\n    ctx.dpr = dpr;\n    var pathTransform = {\n      position: path.position,\n      rotation: path.rotation,\n      scale: path.scale\n    };\n    path.position = [leftMargin - rect.x, topMargin - rect.y];\n    path.rotation = 0;\n    path.scale = [1, 1];\n    path.updateTransform();\n\n    if (path) {\n      path.brush(ctx);\n    }\n\n    var ImageShape = Image;\n    var imgShape = new ImageShape({\n      style: {\n        x: 0,\n        y: 0,\n        image: canvas\n      }\n    });\n\n    if (pathTransform.position != null) {\n      imgShape.position = path.position = pathTransform.position;\n    }\n\n    if (pathTransform.rotation != null) {\n      imgShape.rotation = path.rotation = pathTransform.rotation;\n    }\n\n    if (pathTransform.scale != null) {\n      imgShape.scale = path.scale = pathTransform.scale;\n    }\n\n    return imgShape;\n  }\n};\nvar _default = Painter;\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}