{"ast":null,"code":"var BoundingRect = require(\"../core/BoundingRect\");\n\nvar imageHelper = require(\"../graphic/helper/image\");\n\nvar _util = require(\"../core/util\");\n\nvar getContext = _util.getContext;\nvar extend = _util.extend;\nvar retrieve2 = _util.retrieve2;\nvar retrieve3 = _util.retrieve3;\nvar trim = _util.trim;\nvar textWidthCache = {};\nvar textWidthCacheCounter = 0;\nvar TEXT_CACHE_MAX = 5000;\nvar STYLE_REG = /\\{([a-zA-Z0-9_]+)\\|([^}]*)\\}/g;\nvar DEFAULT_FONT = '12px sans-serif'; // Avoid assign to an exported variable, for transforming to cjs.\n\nvar methods = {};\n\nfunction $override(name, fn) {\n  methods[name] = fn;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {number} width\n */\n\n\nfunction getWidth(text, font) {\n  font = font || DEFAULT_FONT;\n  var key = text + ':' + font;\n\n  if (textWidthCache[key]) {\n    return textWidthCache[key];\n  }\n\n  var textLines = (text + '').split('\\n');\n  var width = 0;\n\n  for (var i = 0, l = textLines.length; i < l; i++) {\n    // textContain.measureText may be overrided in SVG or VML\n    width = Math.max(measureText(textLines[i], font).width, width);\n  }\n\n  if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n    textWidthCacheCounter = 0;\n    textWidthCache = {};\n  }\n\n  textWidthCacheCounter++;\n  textWidthCache[key] = width;\n  return width;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {string} [textAlign='left']\n * @param {string} [textVerticalAlign='top']\n * @param {Array.<number>} [textPadding]\n * @param {Object} [rich]\n * @param {Object} [truncate]\n * @return {Object} {x, y, width, height, lineHeight}\n */\n\n\nfunction getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n  return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate);\n}\n\nfunction getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate) {\n  var contentBlock = parsePlainText(text, font, textPadding, truncate);\n  var outerWidth = getWidth(text, font);\n\n  if (textPadding) {\n    outerWidth += textPadding[1] + textPadding[3];\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  var rect = new BoundingRect(x, y, outerWidth, outerHeight);\n  rect.lineHeight = contentBlock.lineHeight;\n  return rect;\n}\n\nfunction getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n  var contentBlock = parseRichText(text, {\n    rich: rich,\n    truncate: truncate,\n    font: font,\n    textAlign: textAlign,\n    textPadding: textPadding\n  });\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  return new BoundingRect(x, y, outerWidth, outerHeight);\n}\n/**\n * @public\n * @param {number} x\n * @param {number} width\n * @param {string} [textAlign='left']\n * @return {number} Adjusted x.\n */\n\n\nfunction adjustTextX(x, width, textAlign) {\n  // FIXME Right to left language\n  if (textAlign === 'right') {\n    x -= width;\n  } else if (textAlign === 'center') {\n    x -= width / 2;\n  }\n\n  return x;\n}\n/**\n * @public\n * @param {number} y\n * @param {number} height\n * @param {string} [textVerticalAlign='top']\n * @return {number} Adjusted y.\n */\n\n\nfunction adjustTextY(y, height, textVerticalAlign) {\n  if (textVerticalAlign === 'middle') {\n    y -= height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y -= height;\n  }\n\n  return y;\n}\n/**\n * @public\n * @param {stirng} textPosition\n * @param {Object} rect {x, y, width, height}\n * @param {number} distance\n * @return {Object} {x, y, textAlign, textVerticalAlign}\n */\n\n\nfunction adjustTextPositionOnRect(textPosition, rect, distance) {\n  var x = rect.x;\n  var y = rect.y;\n  var height = rect.height;\n  var width = rect.width;\n  var halfHeight = height / 2;\n  var textAlign = 'left';\n  var textVerticalAlign = 'top';\n\n  switch (textPosition) {\n    case 'left':\n      x -= distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'right':\n      x += distance + width;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'top':\n      x += width / 2;\n      y -= distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'bottom':\n      x += width / 2;\n      y += height + distance;\n      textAlign = 'center';\n      break;\n\n    case 'inside':\n      x += width / 2;\n      y += halfHeight;\n      textAlign = 'center';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideLeft':\n      x += distance;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideRight':\n      x += width - distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideTop':\n      x += width / 2;\n      y += distance;\n      textAlign = 'center';\n      break;\n\n    case 'insideBottom':\n      x += width / 2;\n      y += height - distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideTopLeft':\n      x += distance;\n      y += distance;\n      break;\n\n    case 'insideTopRight':\n      x += width - distance;\n      y += distance;\n      textAlign = 'right';\n      break;\n\n    case 'insideBottomLeft':\n      x += distance;\n      y += height - distance;\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideBottomRight':\n      x += width - distance;\n      y += height - distance;\n      textAlign = 'right';\n      textVerticalAlign = 'bottom';\n      break;\n  }\n\n  return {\n    x: x,\n    y: y,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n/**\n * Show ellipsis if overflow.\n *\n * @public\n * @param  {string} text\n * @param  {string} containerWidth\n * @param  {string} font\n * @param  {number} [ellipsis='...']\n * @param  {Object} [options]\n * @param  {number} [options.maxIterations=3]\n * @param  {number} [options.minChar=0] If truncate result are less\n *                  then minChar, ellipsis will not show, which is\n *                  better for user hint in some cases.\n * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n * @return {string}\n */\n\n\nfunction truncateText(text, containerWidth, font, ellipsis, options) {\n  if (!containerWidth) {\n    return '';\n  }\n\n  var textLines = (text + '').split('\\n');\n  options = prepareTruncateOptions(containerWidth, font, ellipsis, options); // FIXME\n  // It is not appropriate that every line has '...' when truncate multiple lines.\n\n  for (var i = 0, len = textLines.length; i < len; i++) {\n    textLines[i] = truncateSingleLine(textLines[i], options);\n  }\n\n  return textLines.join('\\n');\n}\n\nfunction prepareTruncateOptions(containerWidth, font, ellipsis, options) {\n  options = extend({}, options);\n  options.font = font;\n  var ellipsis = retrieve2(ellipsis, '...');\n  options.maxIterations = retrieve2(options.maxIterations, 2);\n  var minChar = options.minChar = retrieve2(options.minChar, 0); // FIXME\n  // Other languages?\n\n  options.cnCharWidth = getWidth('国', font); // FIXME\n  // Consider proportional font?\n\n  var ascCharWidth = options.ascCharWidth = getWidth('a', font);\n  options.placeholder = retrieve2(options.placeholder, ''); // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n  // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.\n\n  var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n\n  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n    contentWidth -= ascCharWidth;\n  }\n\n  var ellipsisWidth = getWidth(ellipsis);\n\n  if (ellipsisWidth > contentWidth) {\n    ellipsis = '';\n    ellipsisWidth = 0;\n  }\n\n  contentWidth = containerWidth - ellipsisWidth;\n  options.ellipsis = ellipsis;\n  options.ellipsisWidth = ellipsisWidth;\n  options.contentWidth = contentWidth;\n  options.containerWidth = containerWidth;\n  return options;\n}\n\nfunction truncateSingleLine(textLine, options) {\n  var containerWidth = options.containerWidth;\n  var font = options.font;\n  var contentWidth = options.contentWidth;\n\n  if (!containerWidth) {\n    return '';\n  }\n\n  var lineWidth = getWidth(textLine, font);\n\n  if (lineWidth <= containerWidth) {\n    return textLine;\n  }\n\n  for (var j = 0;; j++) {\n    if (lineWidth <= contentWidth || j >= options.maxIterations) {\n      textLine += options.ellipsis;\n      break;\n    }\n\n    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;\n    textLine = textLine.substr(0, subLength);\n    lineWidth = getWidth(textLine, font);\n  }\n\n  if (textLine === '') {\n    textLine = options.placeholder;\n  }\n\n  return textLine;\n}\n\nfunction estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n  var width = 0;\n  var i = 0;\n\n  for (var len = text.length; i < len && width < contentWidth; i++) {\n    var charCode = text.charCodeAt(i);\n    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;\n  }\n\n  return i;\n}\n/**\n * @public\n * @param {string} font\n * @return {number} line height\n */\n\n\nfunction getLineHeight(font) {\n  // FIXME A rough approach.\n  return getWidth('国', font);\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {Object} width\n */\n\n\nfunction measureText(text, font) {\n  return methods.measureText(text, font);\n} // Avoid assign to an exported variable, for transforming to cjs.\n\n\nmethods.measureText = function (text, font) {\n  var ctx = getContext();\n  ctx.font = font || DEFAULT_FONT;\n  return ctx.measureText(text);\n};\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {Object} [truncate]\n * @return {Object} block: {lineHeight, lines, height, outerHeight}\n *  Notice: for performance, do not calculate outerWidth util needed.\n */\n\n\nfunction parsePlainText(text, font, padding, truncate) {\n  text != null && (text += '');\n  var lineHeight = getLineHeight(font);\n  var lines = text ? text.split('\\n') : [];\n  var height = lines.length * lineHeight;\n  var outerHeight = height;\n\n  if (padding) {\n    outerHeight += padding[0] + padding[2];\n  }\n\n  if (text && truncate) {\n    var truncOuterHeight = truncate.outerHeight;\n    var truncOuterWidth = truncate.outerWidth;\n\n    if (truncOuterHeight != null && outerHeight > truncOuterHeight) {\n      text = '';\n      lines = [];\n    } else if (truncOuterWidth != null) {\n      var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {\n        minChar: truncate.minChar,\n        placeholder: truncate.placeholder\n      }); // FIXME\n      // It is not appropriate that every line has '...' when truncate multiple lines.\n\n      for (var i = 0, len = lines.length; i < len; i++) {\n        lines[i] = truncateSingleLine(lines[i], options);\n      }\n    }\n  }\n\n  return {\n    lines: lines,\n    height: height,\n    outerHeight: outerHeight,\n    lineHeight: lineHeight\n  };\n}\n/**\n * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'\n * Also consider 'bbbb{a|xxx\\nzzz}xxxx\\naaaa'.\n *\n * @public\n * @param {string} text\n * @param {Object} style\n * @return {Object} block\n * {\n *      width,\n *      height,\n *      lines: [{\n *          lineHeight,\n *          width,\n *          tokens: [[{\n *              styleName,\n *              text,\n *              width,      // include textPadding\n *              height,     // include textPadding\n *              textWidth, // pure text width\n *              textHeight, // pure text height\n *              lineHeihgt,\n *              font,\n *              textAlign,\n *              textVerticalAlign\n *          }], [...], ...]\n *      }, ...]\n * }\n * If styleName is undefined, it is plain text.\n */\n\n\nfunction parseRichText(text, style) {\n  var contentBlock = {\n    lines: [],\n    width: 0,\n    height: 0\n  };\n  text != null && (text += '');\n\n  if (!text) {\n    return contentBlock;\n  }\n\n  var lastIndex = STYLE_REG.lastIndex = 0;\n  var result;\n\n  while ((result = STYLE_REG.exec(text)) != null) {\n    var matchedIndex = result.index;\n\n    if (matchedIndex > lastIndex) {\n      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));\n    }\n\n    pushTokens(contentBlock, result[2], result[1]);\n    lastIndex = STYLE_REG.lastIndex;\n  }\n\n  if (lastIndex < text.length) {\n    pushTokens(contentBlock, text.substring(lastIndex, text.length));\n  }\n\n  var lines = contentBlock.lines;\n  var contentHeight = 0;\n  var contentWidth = 0; // For `textWidth: 100%`\n\n  var pendingList = [];\n  var stlPadding = style.textPadding;\n  var truncate = style.truncate;\n  var truncateWidth = truncate && truncate.outerWidth;\n  var truncateHeight = truncate && truncate.outerHeight;\n\n  if (stlPadding) {\n    truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);\n    truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);\n  } // Calculate layout info of tokens.\n\n\n  for (var i = 0; i < lines.length; i++) {\n    var line = lines[i];\n    var lineHeight = 0;\n    var lineWidth = 0;\n\n    for (var j = 0; j < line.tokens.length; j++) {\n      var token = line.tokens[j];\n      var tokenStyle = token.styleName && style.rich[token.styleName] || {}; // textPadding should not inherit from style.\n\n      var textPadding = token.textPadding = tokenStyle.textPadding; // textFont has been asigned to font by `normalizeStyle`.\n\n      var font = token.font = tokenStyle.font || style.font; // textHeight can be used when textVerticalAlign is specified in token.\n\n      var tokenHeight = token.textHeight = retrieve2( // textHeight should not be inherited, consider it can be specified\n      // as box height of the block.\n      tokenStyle.textHeight, getLineHeight(font));\n      textPadding && (tokenHeight += textPadding[0] + textPadding[2]);\n      token.height = tokenHeight;\n      token.lineHeight = retrieve3(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);\n      token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;\n      token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';\n\n      if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {\n        return {\n          lines: [],\n          width: 0,\n          height: 0\n        };\n      }\n\n      token.textWidth = getWidth(token.text, font);\n      var tokenWidth = tokenStyle.textWidth;\n      var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto'; // Percent width, can be `100%`, can be used in drawing separate\n      // line when box width is needed to be auto.\n\n      if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {\n        token.percentWidth = tokenWidth;\n        pendingList.push(token);\n        tokenWidth = 0; // Do not truncate in this case, because there is no user case\n        // and it is too complicated.\n      } else {\n        if (tokenWidthNotSpecified) {\n          tokenWidth = token.textWidth; // FIXME: If image is not loaded and textWidth is not specified, calling\n          // `getBoundingRect()` will not get correct result.\n\n          var textBackgroundColor = tokenStyle.textBackgroundColor;\n          var bgImg = textBackgroundColor && textBackgroundColor.image; // Use cases:\n          // (1) If image is not loaded, it will be loaded at render phase and call\n          // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded\n          // image, and then the right size will be calculated here at the next tick.\n          // See `graphic/helper/text.js`.\n          // (2) If image loaded, and `textBackgroundColor.image` is image src string,\n          // use `imageHelper.findExistImage` to find cached image.\n          // `imageHelper.findExistImage` will always be called here before\n          // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`\n          // which ensures that image will not be rendered before correct size calcualted.\n\n          if (bgImg) {\n            bgImg = imageHelper.findExistImage(bgImg);\n\n            if (imageHelper.isImageReady(bgImg)) {\n              tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);\n            }\n          }\n        }\n\n        var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;\n        tokenWidth += paddingW;\n        var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;\n\n        if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {\n          if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {\n            token.text = '';\n            token.textWidth = tokenWidth = 0;\n          } else {\n            token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {\n              minChar: truncate.minChar\n            });\n            token.textWidth = getWidth(token.text, font);\n            tokenWidth = token.textWidth + paddingW;\n          }\n        }\n      }\n\n      lineWidth += token.width = tokenWidth;\n      tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));\n    }\n\n    line.width = lineWidth;\n    line.lineHeight = lineHeight;\n    contentHeight += lineHeight;\n    contentWidth = Math.max(contentWidth, lineWidth);\n  }\n\n  contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);\n  contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);\n\n  if (stlPadding) {\n    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];\n    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];\n  }\n\n  for (var i = 0; i < pendingList.length; i++) {\n    var token = pendingList[i];\n    var percentWidth = token.percentWidth; // Should not base on outerWidth, because token can not be placed out of padding.\n\n    token.width = parseInt(percentWidth, 10) / 100 * contentWidth;\n  }\n\n  return contentBlock;\n}\n\nfunction pushTokens(block, str, styleName) {\n  var isEmptyStr = str === '';\n  var strs = str.split('\\n');\n  var lines = block.lines;\n\n  for (var i = 0; i < strs.length; i++) {\n    var text = strs[i];\n    var token = {\n      styleName: styleName,\n      text: text,\n      isLineHolder: !text && !isEmptyStr\n    }; // The first token should be appended to the last line.\n\n    if (!i) {\n      var tokens = (lines[lines.length - 1] || (lines[0] = {\n        tokens: []\n      })).tokens; // Consider cases:\n      // (1) ''.split('\\n') => ['', '\\n', ''], the '' at the first item\n      // (which is a placeholder) should be replaced by new token.\n      // (2) A image backage, where token likes {a|}.\n      // (3) A redundant '' will affect textAlign in line.\n      // (4) tokens with the same tplName should not be merged, because\n      // they should be displayed in different box (with border and padding).\n\n      var tokensLen = tokens.length;\n      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : // Consider text is '', only insert when it is the \"lineHolder\" or\n      // \"emptyStr\". Otherwise a redundant '' will affect textAlign in line.\n      (text || !tokensLen || isEmptyStr) && tokens.push(token);\n    } // Other tokens always start a new line.\n    else {\n      // If there is '', insert it as a placeholder.\n      lines.push({\n        tokens: [token]\n      });\n    }\n  }\n}\n\nfunction makeFont(style) {\n  // FIXME in node-canvas fontWeight is before fontStyle\n  // Use `fontSize` `fontFamily` to check whether font properties are defined.\n  var font = (style.fontSize || style.fontFamily) && [style.fontStyle, style.fontWeight, (style.fontSize || 12) + 'px', // If font properties are defined, `fontFamily` should not be ignored.\n  style.fontFamily || 'sans-serif'].join(' ');\n  return font && trim(font) || style.textFont || style.font;\n}\n\nexports.DEFAULT_FONT = DEFAULT_FONT;\nexports.$override = $override;\nexports.getWidth = getWidth;\nexports.getBoundingRect = getBoundingRect;\nexports.adjustTextX = adjustTextX;\nexports.adjustTextY = adjustTextY;\nexports.adjustTextPositionOnRect = adjustTextPositionOnRect;\nexports.truncateText = truncateText;\nexports.getLineHeight = getLineHeight;\nexports.measureText = measureText;\nexports.parsePlainText = parsePlainText;\nexports.parseRichText = parseRichText;\nexports.makeFont = makeFont;","map":{"version":3,"names":["BoundingRect","require","imageHelper","_util","getContext","extend","retrieve2","retrieve3","trim","textWidthCache","textWidthCacheCounter","TEXT_CACHE_MAX","STYLE_REG","DEFAULT_FONT","methods","$override","name","fn","getWidth","text","font","key","textLines","split","width","i","l","length","Math","max","measureText","getBoundingRect","textAlign","textVerticalAlign","textPadding","rich","truncate","getRichTextRect","getPlainTextRect","contentBlock","parsePlainText","outerWidth","outerHeight","x","adjustTextX","y","adjustTextY","rect","lineHeight","parseRichText","height","adjustTextPositionOnRect","textPosition","distance","halfHeight","truncateText","containerWidth","ellipsis","options","prepareTruncateOptions","len","truncateSingleLine","join","maxIterations","minChar","cnCharWidth","ascCharWidth","placeholder","contentWidth","ellipsisWidth","textLine","lineWidth","j","subLength","estimateLength","floor","substr","charCode","charCodeAt","getLineHeight","ctx","padding","lines","truncOuterHeight","truncOuterWidth","style","lastIndex","result","exec","matchedIndex","index","pushTokens","substring","contentHeight","pendingList","stlPadding","truncateWidth","truncateHeight","line","tokens","token","tokenStyle","styleName","tokenHeight","textHeight","textLineHeight","textWidth","tokenWidth","tokenWidthNotSpecified","charAt","percentWidth","push","textBackgroundColor","bgImg","image","findExistImage","isImageReady","paddingW","remianTruncWidth","parseInt","block","str","isEmptyStr","strs","isLineHolder","tokensLen","makeFont","fontSize","fontFamily","fontStyle","fontWeight","textFont","exports"],"sources":["C:/Users/W/Desktop/vue_map/node_modules/zrender/lib/contain/text.js"],"sourcesContent":["var BoundingRect = require(\"../core/BoundingRect\");\n\nvar imageHelper = require(\"../graphic/helper/image\");\n\nvar _util = require(\"../core/util\");\n\nvar getContext = _util.getContext;\nvar extend = _util.extend;\nvar retrieve2 = _util.retrieve2;\nvar retrieve3 = _util.retrieve3;\nvar trim = _util.trim;\nvar textWidthCache = {};\nvar textWidthCacheCounter = 0;\nvar TEXT_CACHE_MAX = 5000;\nvar STYLE_REG = /\\{([a-zA-Z0-9_]+)\\|([^}]*)\\}/g;\nvar DEFAULT_FONT = '12px sans-serif'; // Avoid assign to an exported variable, for transforming to cjs.\n\nvar methods = {};\n\nfunction $override(name, fn) {\n  methods[name] = fn;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {number} width\n */\n\n\nfunction getWidth(text, font) {\n  font = font || DEFAULT_FONT;\n  var key = text + ':' + font;\n\n  if (textWidthCache[key]) {\n    return textWidthCache[key];\n  }\n\n  var textLines = (text + '').split('\\n');\n  var width = 0;\n\n  for (var i = 0, l = textLines.length; i < l; i++) {\n    // textContain.measureText may be overrided in SVG or VML\n    width = Math.max(measureText(textLines[i], font).width, width);\n  }\n\n  if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n    textWidthCacheCounter = 0;\n    textWidthCache = {};\n  }\n\n  textWidthCacheCounter++;\n  textWidthCache[key] = width;\n  return width;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {string} [textAlign='left']\n * @param {string} [textVerticalAlign='top']\n * @param {Array.<number>} [textPadding]\n * @param {Object} [rich]\n * @param {Object} [truncate]\n * @return {Object} {x, y, width, height, lineHeight}\n */\n\n\nfunction getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n  return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate);\n}\n\nfunction getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate) {\n  var contentBlock = parsePlainText(text, font, textPadding, truncate);\n  var outerWidth = getWidth(text, font);\n\n  if (textPadding) {\n    outerWidth += textPadding[1] + textPadding[3];\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  var rect = new BoundingRect(x, y, outerWidth, outerHeight);\n  rect.lineHeight = contentBlock.lineHeight;\n  return rect;\n}\n\nfunction getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n  var contentBlock = parseRichText(text, {\n    rich: rich,\n    truncate: truncate,\n    font: font,\n    textAlign: textAlign,\n    textPadding: textPadding\n  });\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  return new BoundingRect(x, y, outerWidth, outerHeight);\n}\n/**\n * @public\n * @param {number} x\n * @param {number} width\n * @param {string} [textAlign='left']\n * @return {number} Adjusted x.\n */\n\n\nfunction adjustTextX(x, width, textAlign) {\n  // FIXME Right to left language\n  if (textAlign === 'right') {\n    x -= width;\n  } else if (textAlign === 'center') {\n    x -= width / 2;\n  }\n\n  return x;\n}\n/**\n * @public\n * @param {number} y\n * @param {number} height\n * @param {string} [textVerticalAlign='top']\n * @return {number} Adjusted y.\n */\n\n\nfunction adjustTextY(y, height, textVerticalAlign) {\n  if (textVerticalAlign === 'middle') {\n    y -= height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y -= height;\n  }\n\n  return y;\n}\n/**\n * @public\n * @param {stirng} textPosition\n * @param {Object} rect {x, y, width, height}\n * @param {number} distance\n * @return {Object} {x, y, textAlign, textVerticalAlign}\n */\n\n\nfunction adjustTextPositionOnRect(textPosition, rect, distance) {\n  var x = rect.x;\n  var y = rect.y;\n  var height = rect.height;\n  var width = rect.width;\n  var halfHeight = height / 2;\n  var textAlign = 'left';\n  var textVerticalAlign = 'top';\n\n  switch (textPosition) {\n    case 'left':\n      x -= distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'right':\n      x += distance + width;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'top':\n      x += width / 2;\n      y -= distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'bottom':\n      x += width / 2;\n      y += height + distance;\n      textAlign = 'center';\n      break;\n\n    case 'inside':\n      x += width / 2;\n      y += halfHeight;\n      textAlign = 'center';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideLeft':\n      x += distance;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideRight':\n      x += width - distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideTop':\n      x += width / 2;\n      y += distance;\n      textAlign = 'center';\n      break;\n\n    case 'insideBottom':\n      x += width / 2;\n      y += height - distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideTopLeft':\n      x += distance;\n      y += distance;\n      break;\n\n    case 'insideTopRight':\n      x += width - distance;\n      y += distance;\n      textAlign = 'right';\n      break;\n\n    case 'insideBottomLeft':\n      x += distance;\n      y += height - distance;\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideBottomRight':\n      x += width - distance;\n      y += height - distance;\n      textAlign = 'right';\n      textVerticalAlign = 'bottom';\n      break;\n  }\n\n  return {\n    x: x,\n    y: y,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n/**\n * Show ellipsis if overflow.\n *\n * @public\n * @param  {string} text\n * @param  {string} containerWidth\n * @param  {string} font\n * @param  {number} [ellipsis='...']\n * @param  {Object} [options]\n * @param  {number} [options.maxIterations=3]\n * @param  {number} [options.minChar=0] If truncate result are less\n *                  then minChar, ellipsis will not show, which is\n *                  better for user hint in some cases.\n * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n * @return {string}\n */\n\n\nfunction truncateText(text, containerWidth, font, ellipsis, options) {\n  if (!containerWidth) {\n    return '';\n  }\n\n  var textLines = (text + '').split('\\n');\n  options = prepareTruncateOptions(containerWidth, font, ellipsis, options); // FIXME\n  // It is not appropriate that every line has '...' when truncate multiple lines.\n\n  for (var i = 0, len = textLines.length; i < len; i++) {\n    textLines[i] = truncateSingleLine(textLines[i], options);\n  }\n\n  return textLines.join('\\n');\n}\n\nfunction prepareTruncateOptions(containerWidth, font, ellipsis, options) {\n  options = extend({}, options);\n  options.font = font;\n  var ellipsis = retrieve2(ellipsis, '...');\n  options.maxIterations = retrieve2(options.maxIterations, 2);\n  var minChar = options.minChar = retrieve2(options.minChar, 0); // FIXME\n  // Other languages?\n\n  options.cnCharWidth = getWidth('国', font); // FIXME\n  // Consider proportional font?\n\n  var ascCharWidth = options.ascCharWidth = getWidth('a', font);\n  options.placeholder = retrieve2(options.placeholder, ''); // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n  // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.\n\n  var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n\n  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n    contentWidth -= ascCharWidth;\n  }\n\n  var ellipsisWidth = getWidth(ellipsis);\n\n  if (ellipsisWidth > contentWidth) {\n    ellipsis = '';\n    ellipsisWidth = 0;\n  }\n\n  contentWidth = containerWidth - ellipsisWidth;\n  options.ellipsis = ellipsis;\n  options.ellipsisWidth = ellipsisWidth;\n  options.contentWidth = contentWidth;\n  options.containerWidth = containerWidth;\n  return options;\n}\n\nfunction truncateSingleLine(textLine, options) {\n  var containerWidth = options.containerWidth;\n  var font = options.font;\n  var contentWidth = options.contentWidth;\n\n  if (!containerWidth) {\n    return '';\n  }\n\n  var lineWidth = getWidth(textLine, font);\n\n  if (lineWidth <= containerWidth) {\n    return textLine;\n  }\n\n  for (var j = 0;; j++) {\n    if (lineWidth <= contentWidth || j >= options.maxIterations) {\n      textLine += options.ellipsis;\n      break;\n    }\n\n    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;\n    textLine = textLine.substr(0, subLength);\n    lineWidth = getWidth(textLine, font);\n  }\n\n  if (textLine === '') {\n    textLine = options.placeholder;\n  }\n\n  return textLine;\n}\n\nfunction estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n  var width = 0;\n  var i = 0;\n\n  for (var len = text.length; i < len && width < contentWidth; i++) {\n    var charCode = text.charCodeAt(i);\n    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;\n  }\n\n  return i;\n}\n/**\n * @public\n * @param {string} font\n * @return {number} line height\n */\n\n\nfunction getLineHeight(font) {\n  // FIXME A rough approach.\n  return getWidth('国', font);\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {Object} width\n */\n\n\nfunction measureText(text, font) {\n  return methods.measureText(text, font);\n} // Avoid assign to an exported variable, for transforming to cjs.\n\n\nmethods.measureText = function (text, font) {\n  var ctx = getContext();\n  ctx.font = font || DEFAULT_FONT;\n  return ctx.measureText(text);\n};\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {Object} [truncate]\n * @return {Object} block: {lineHeight, lines, height, outerHeight}\n *  Notice: for performance, do not calculate outerWidth util needed.\n */\n\n\nfunction parsePlainText(text, font, padding, truncate) {\n  text != null && (text += '');\n  var lineHeight = getLineHeight(font);\n  var lines = text ? text.split('\\n') : [];\n  var height = lines.length * lineHeight;\n  var outerHeight = height;\n\n  if (padding) {\n    outerHeight += padding[0] + padding[2];\n  }\n\n  if (text && truncate) {\n    var truncOuterHeight = truncate.outerHeight;\n    var truncOuterWidth = truncate.outerWidth;\n\n    if (truncOuterHeight != null && outerHeight > truncOuterHeight) {\n      text = '';\n      lines = [];\n    } else if (truncOuterWidth != null) {\n      var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {\n        minChar: truncate.minChar,\n        placeholder: truncate.placeholder\n      }); // FIXME\n      // It is not appropriate that every line has '...' when truncate multiple lines.\n\n      for (var i = 0, len = lines.length; i < len; i++) {\n        lines[i] = truncateSingleLine(lines[i], options);\n      }\n    }\n  }\n\n  return {\n    lines: lines,\n    height: height,\n    outerHeight: outerHeight,\n    lineHeight: lineHeight\n  };\n}\n/**\n * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'\n * Also consider 'bbbb{a|xxx\\nzzz}xxxx\\naaaa'.\n *\n * @public\n * @param {string} text\n * @param {Object} style\n * @return {Object} block\n * {\n *      width,\n *      height,\n *      lines: [{\n *          lineHeight,\n *          width,\n *          tokens: [[{\n *              styleName,\n *              text,\n *              width,      // include textPadding\n *              height,     // include textPadding\n *              textWidth, // pure text width\n *              textHeight, // pure text height\n *              lineHeihgt,\n *              font,\n *              textAlign,\n *              textVerticalAlign\n *          }], [...], ...]\n *      }, ...]\n * }\n * If styleName is undefined, it is plain text.\n */\n\n\nfunction parseRichText(text, style) {\n  var contentBlock = {\n    lines: [],\n    width: 0,\n    height: 0\n  };\n  text != null && (text += '');\n\n  if (!text) {\n    return contentBlock;\n  }\n\n  var lastIndex = STYLE_REG.lastIndex = 0;\n  var result;\n\n  while ((result = STYLE_REG.exec(text)) != null) {\n    var matchedIndex = result.index;\n\n    if (matchedIndex > lastIndex) {\n      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));\n    }\n\n    pushTokens(contentBlock, result[2], result[1]);\n    lastIndex = STYLE_REG.lastIndex;\n  }\n\n  if (lastIndex < text.length) {\n    pushTokens(contentBlock, text.substring(lastIndex, text.length));\n  }\n\n  var lines = contentBlock.lines;\n  var contentHeight = 0;\n  var contentWidth = 0; // For `textWidth: 100%`\n\n  var pendingList = [];\n  var stlPadding = style.textPadding;\n  var truncate = style.truncate;\n  var truncateWidth = truncate && truncate.outerWidth;\n  var truncateHeight = truncate && truncate.outerHeight;\n\n  if (stlPadding) {\n    truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);\n    truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);\n  } // Calculate layout info of tokens.\n\n\n  for (var i = 0; i < lines.length; i++) {\n    var line = lines[i];\n    var lineHeight = 0;\n    var lineWidth = 0;\n\n    for (var j = 0; j < line.tokens.length; j++) {\n      var token = line.tokens[j];\n      var tokenStyle = token.styleName && style.rich[token.styleName] || {}; // textPadding should not inherit from style.\n\n      var textPadding = token.textPadding = tokenStyle.textPadding; // textFont has been asigned to font by `normalizeStyle`.\n\n      var font = token.font = tokenStyle.font || style.font; // textHeight can be used when textVerticalAlign is specified in token.\n\n      var tokenHeight = token.textHeight = retrieve2( // textHeight should not be inherited, consider it can be specified\n      // as box height of the block.\n      tokenStyle.textHeight, getLineHeight(font));\n      textPadding && (tokenHeight += textPadding[0] + textPadding[2]);\n      token.height = tokenHeight;\n      token.lineHeight = retrieve3(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);\n      token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;\n      token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';\n\n      if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {\n        return {\n          lines: [],\n          width: 0,\n          height: 0\n        };\n      }\n\n      token.textWidth = getWidth(token.text, font);\n      var tokenWidth = tokenStyle.textWidth;\n      var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto'; // Percent width, can be `100%`, can be used in drawing separate\n      // line when box width is needed to be auto.\n\n      if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {\n        token.percentWidth = tokenWidth;\n        pendingList.push(token);\n        tokenWidth = 0; // Do not truncate in this case, because there is no user case\n        // and it is too complicated.\n      } else {\n        if (tokenWidthNotSpecified) {\n          tokenWidth = token.textWidth; // FIXME: If image is not loaded and textWidth is not specified, calling\n          // `getBoundingRect()` will not get correct result.\n\n          var textBackgroundColor = tokenStyle.textBackgroundColor;\n          var bgImg = textBackgroundColor && textBackgroundColor.image; // Use cases:\n          // (1) If image is not loaded, it will be loaded at render phase and call\n          // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded\n          // image, and then the right size will be calculated here at the next tick.\n          // See `graphic/helper/text.js`.\n          // (2) If image loaded, and `textBackgroundColor.image` is image src string,\n          // use `imageHelper.findExistImage` to find cached image.\n          // `imageHelper.findExistImage` will always be called here before\n          // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`\n          // which ensures that image will not be rendered before correct size calcualted.\n\n          if (bgImg) {\n            bgImg = imageHelper.findExistImage(bgImg);\n\n            if (imageHelper.isImageReady(bgImg)) {\n              tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);\n            }\n          }\n        }\n\n        var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;\n        tokenWidth += paddingW;\n        var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;\n\n        if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {\n          if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {\n            token.text = '';\n            token.textWidth = tokenWidth = 0;\n          } else {\n            token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {\n              minChar: truncate.minChar\n            });\n            token.textWidth = getWidth(token.text, font);\n            tokenWidth = token.textWidth + paddingW;\n          }\n        }\n      }\n\n      lineWidth += token.width = tokenWidth;\n      tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));\n    }\n\n    line.width = lineWidth;\n    line.lineHeight = lineHeight;\n    contentHeight += lineHeight;\n    contentWidth = Math.max(contentWidth, lineWidth);\n  }\n\n  contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);\n  contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);\n\n  if (stlPadding) {\n    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];\n    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];\n  }\n\n  for (var i = 0; i < pendingList.length; i++) {\n    var token = pendingList[i];\n    var percentWidth = token.percentWidth; // Should not base on outerWidth, because token can not be placed out of padding.\n\n    token.width = parseInt(percentWidth, 10) / 100 * contentWidth;\n  }\n\n  return contentBlock;\n}\n\nfunction pushTokens(block, str, styleName) {\n  var isEmptyStr = str === '';\n  var strs = str.split('\\n');\n  var lines = block.lines;\n\n  for (var i = 0; i < strs.length; i++) {\n    var text = strs[i];\n    var token = {\n      styleName: styleName,\n      text: text,\n      isLineHolder: !text && !isEmptyStr\n    }; // The first token should be appended to the last line.\n\n    if (!i) {\n      var tokens = (lines[lines.length - 1] || (lines[0] = {\n        tokens: []\n      })).tokens; // Consider cases:\n      // (1) ''.split('\\n') => ['', '\\n', ''], the '' at the first item\n      // (which is a placeholder) should be replaced by new token.\n      // (2) A image backage, where token likes {a|}.\n      // (3) A redundant '' will affect textAlign in line.\n      // (4) tokens with the same tplName should not be merged, because\n      // they should be displayed in different box (with border and padding).\n\n      var tokensLen = tokens.length;\n      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : // Consider text is '', only insert when it is the \"lineHolder\" or\n      // \"emptyStr\". Otherwise a redundant '' will affect textAlign in line.\n      (text || !tokensLen || isEmptyStr) && tokens.push(token);\n    } // Other tokens always start a new line.\n    else {\n        // If there is '', insert it as a placeholder.\n        lines.push({\n          tokens: [token]\n        });\n      }\n  }\n}\n\nfunction makeFont(style) {\n  // FIXME in node-canvas fontWeight is before fontStyle\n  // Use `fontSize` `fontFamily` to check whether font properties are defined.\n  var font = (style.fontSize || style.fontFamily) && [style.fontStyle, style.fontWeight, (style.fontSize || 12) + 'px', // If font properties are defined, `fontFamily` should not be ignored.\n  style.fontFamily || 'sans-serif'].join(' ');\n  return font && trim(font) || style.textFont || style.font;\n}\n\nexports.DEFAULT_FONT = DEFAULT_FONT;\nexports.$override = $override;\nexports.getWidth = getWidth;\nexports.getBoundingRect = getBoundingRect;\nexports.adjustTextX = adjustTextX;\nexports.adjustTextY = adjustTextY;\nexports.adjustTextPositionOnRect = adjustTextPositionOnRect;\nexports.truncateText = truncateText;\nexports.getLineHeight = getLineHeight;\nexports.measureText = measureText;\nexports.parsePlainText = parsePlainText;\nexports.parseRichText = parseRichText;\nexports.makeFont = makeFont;"],"mappings":"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"},"metadata":{},"sourceType":"script"}