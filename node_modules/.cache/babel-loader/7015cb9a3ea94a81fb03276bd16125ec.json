{"ast":null,"code":"var _config = require(\"../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = require(\"../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar modelUtil = require(\"../util/model\");\n\nvar graphicUtil = require(\"../util/graphic\");\n\nvar layoutUtil = require(\"../util/layout\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// -------------\n// Preprocessor\n// -------------\n\n\necharts.registerPreprocessor(function (option) {\n  var graphicOption = option.graphic; // Convert\n  // {graphic: [{left: 10, type: 'circle'}, ...]}\n  // or\n  // {graphic: {left: 10, type: 'circle'}}\n  // to\n  // {graphic: [{elements: [{left: 10, type: 'circle'}, ...]}]}\n\n  if (zrUtil.isArray(graphicOption)) {\n    if (!graphicOption[0] || !graphicOption[0].elements) {\n      option.graphic = [{\n        elements: graphicOption\n      }];\n    } else {\n      // Only one graphic instance can be instantiated. (We dont\n      // want that too many views are created in echarts._viewMap)\n      option.graphic = [option.graphic[0]];\n    }\n  } else if (graphicOption && !graphicOption.elements) {\n    option.graphic = [{\n      elements: [graphicOption]\n    }];\n  }\n}); // ------\n// Model\n// ------\n\nvar GraphicModel = echarts.extendComponentModel({\n  type: 'graphic',\n  defaultOption: {\n    // Extra properties for each elements:\n    //\n    // left/right/top/bottom: (like 12, '22%', 'center', default undefined)\n    //      If left/rigth is set, shape.x/shape.cx/position will not be used.\n    //      If top/bottom is set, shape.y/shape.cy/position will not be used.\n    //      This mechanism is useful when you want to position a group/element\n    //      against the right side or the center of this container.\n    //\n    // width/height: (can only be pixel value, default 0)\n    //      Only be used to specify contianer(group) size, if needed. And\n    //      can not be percentage value (like '33%'). See the reason in the\n    //      layout algorithm below.\n    //\n    // bounding: (enum: 'all' (default) | 'raw')\n    //      Specify how to calculate boundingRect when locating.\n    //      'all': Get uioned and transformed boundingRect\n    //          from both itself and its descendants.\n    //          This mode simplies confining a group of elements in the bounding\n    //          of their ancester container (e.g., using 'right: 0').\n    //      'raw': Only use the boundingRect of itself and before transformed.\n    //          This mode is similar to css behavior, which is useful when you\n    //          want an element to be able to overflow its container. (Consider\n    //          a rotated circle needs to be located in a corner.)\n    // Note: elements is always behind its ancestors in this elements array.\n    elements: [],\n    parentId: null\n  },\n\n  /**\n   * Save el options for the sake of the performance (only update modified graphics).\n   * The order is the same as those in option. (ancesters -> descendants)\n   *\n   * @private\n   * @type {Array.<Object>}\n   */\n  _elOptionsToUpdate: null,\n\n  /**\n   * @override\n   */\n  mergeOption: function (option) {\n    // Prevent default merge to elements\n    var elements = this.option.elements;\n    this.option.elements = null;\n    GraphicModel.superApply(this, 'mergeOption', arguments);\n    this.option.elements = elements;\n  },\n\n  /**\n   * @override\n   */\n  optionUpdated: function (newOption, isInit) {\n    var thisOption = this.option;\n    var newList = (isInit ? thisOption : newOption).elements;\n    var existList = thisOption.elements = isInit ? [] : thisOption.elements;\n    var flattenedList = [];\n\n    this._flatten(newList, flattenedList);\n\n    var mappingResult = modelUtil.mappingToExists(existList, flattenedList);\n    modelUtil.makeIdAndName(mappingResult); // Clear elOptionsToUpdate\n\n    var elOptionsToUpdate = this._elOptionsToUpdate = [];\n    zrUtil.each(mappingResult, function (resultItem, index) {\n      var newElOption = resultItem.option;\n\n      if (!newElOption) {\n        return;\n      }\n\n      elOptionsToUpdate.push(newElOption);\n      setKeyInfoToNewElOption(resultItem, newElOption);\n      mergeNewElOptionToExist(existList, index, newElOption);\n      setLayoutInfoToExist(existList[index], newElOption);\n    }, this); // Clean\n\n    for (var i = existList.length - 1; i >= 0; i--) {\n      if (existList[i] == null) {\n        existList.splice(i, 1);\n      } else {\n        // $action should be volatile, otherwise option gotten from\n        // `getOption` will contain unexpected $action.\n        delete existList[i].$action;\n      }\n    }\n  },\n\n  /**\n   * Convert\n   * [{\n   *  type: 'group',\n   *  id: 'xx',\n   *  children: [{type: 'circle'}, {type: 'polygon'}]\n   * }]\n   * to\n   * [\n   *  {type: 'group', id: 'xx'},\n   *  {type: 'circle', parentId: 'xx'},\n   *  {type: 'polygon', parentId: 'xx'}\n   * ]\n   *\n   * @private\n   * @param {Array.<Object>} optionList option list\n   * @param {Array.<Object>} result result of flatten\n   * @param {Object} parentOption parent option\n   */\n  _flatten: function (optionList, result, parentOption) {\n    zrUtil.each(optionList, function (option) {\n      if (!option) {\n        return;\n      }\n\n      if (parentOption) {\n        option.parentOption = parentOption;\n      }\n\n      result.push(option);\n      var children = option.children;\n\n      if (option.type === 'group' && children) {\n        this._flatten(children, result, option);\n      } // Deleting for JSON output, and for not affecting group creation.\n\n\n      delete option.children;\n    }, this);\n  },\n  // FIXME\n  // Pass to view using payload? setOption has a payload?\n  useElOptionsToUpdate: function () {\n    var els = this._elOptionsToUpdate; // Clear to avoid render duplicately when zooming.\n\n    this._elOptionsToUpdate = null;\n    return els;\n  }\n}); // -----\n// View\n// -----\n\necharts.extendComponentView({\n  type: 'graphic',\n\n  /**\n   * @override\n   */\n  init: function (ecModel, api) {\n    /**\n     * @private\n     * @type {module:zrender/core/util.HashMap}\n     */\n    this._elMap = zrUtil.createHashMap();\n    /**\n     * @private\n     * @type {module:echarts/graphic/GraphicModel}\n     */\n\n    this._lastGraphicModel;\n  },\n\n  /**\n   * @override\n   */\n  render: function (graphicModel, ecModel, api) {\n    // Having leveraged between use cases and algorithm complexity, a very\n    // simple layout mechanism is used:\n    // The size(width/height) can be determined by itself or its parent (not\n    // implemented yet), but can not by its children. (Top-down travel)\n    // The location(x/y) can be determined by the bounding rect of itself\n    // (can including its descendants or not) and the size of its parent.\n    // (Bottom-up travel)\n    // When `chart.clear()` or `chart.setOption({...}, true)` with the same id,\n    // view will be reused.\n    if (graphicModel !== this._lastGraphicModel) {\n      this._clear();\n    }\n\n    this._lastGraphicModel = graphicModel;\n\n    this._updateElements(graphicModel, api);\n\n    this._relocate(graphicModel, api);\n  },\n\n  /**\n   * Update graphic elements.\n   *\n   * @private\n   * @param {Object} graphicModel graphic model\n   * @param {module:echarts/ExtensionAPI} api extension API\n   */\n  _updateElements: function (graphicModel, api) {\n    var elOptionsToUpdate = graphicModel.useElOptionsToUpdate();\n\n    if (!elOptionsToUpdate) {\n      return;\n    }\n\n    var elMap = this._elMap;\n    var rootGroup = this.group; // Top-down tranverse to assign graphic settings to each elements.\n\n    zrUtil.each(elOptionsToUpdate, function (elOption) {\n      var $action = elOption.$action;\n      var id = elOption.id;\n      var existEl = elMap.get(id);\n      var parentId = elOption.parentId;\n      var targetElParent = parentId != null ? elMap.get(parentId) : rootGroup;\n\n      if (elOption.type === 'text') {\n        var elOptionStyle = elOption.style; // In top/bottom mode, textVerticalAlign should not be used, which cause\n        // inaccurately locating.\n\n        if (elOption.hv && elOption.hv[1]) {\n          elOptionStyle.textVerticalAlign = elOptionStyle.textBaseline = null;\n        } // Compatible with previous setting: both support fill and textFill,\n        // stroke and textStroke.\n\n\n        !elOptionStyle.hasOwnProperty('textFill') && elOptionStyle.fill && (elOptionStyle.textFill = elOptionStyle.fill);\n        !elOptionStyle.hasOwnProperty('textStroke') && elOptionStyle.stroke && (elOptionStyle.textStroke = elOptionStyle.stroke);\n      } // Remove unnecessary props to avoid potential problems.\n\n\n      var elOptionCleaned = getCleanedElOption(elOption); // For simple, do not support parent change, otherwise reorder is needed.\n\n      if (!$action || $action === 'merge') {\n        existEl ? existEl.attr(elOptionCleaned) : createEl(id, targetElParent, elOptionCleaned, elMap);\n      } else if ($action === 'replace') {\n        removeEl(existEl, elMap);\n        createEl(id, targetElParent, elOptionCleaned, elMap);\n      } else if ($action === 'remove') {\n        removeEl(existEl, elMap);\n      }\n\n      var el = elMap.get(id);\n\n      if (el) {\n        el.__ecGraphicWidth = elOption.width;\n        el.__ecGraphicHeight = elOption.height;\n      }\n    });\n  },\n\n  /**\n   * Locate graphic elements.\n   *\n   * @private\n   * @param {Object} graphicModel graphic model\n   * @param {module:echarts/ExtensionAPI} api extension API\n   */\n  _relocate: function (graphicModel, api) {\n    var elOptions = graphicModel.option.elements;\n    var rootGroup = this.group;\n    var elMap = this._elMap; // Bottom-up tranvese all elements (consider ec resize) to locate elements.\n\n    for (var i = elOptions.length - 1; i >= 0; i--) {\n      var elOption = elOptions[i];\n      var el = elMap.get(elOption.id);\n\n      if (!el) {\n        continue;\n      }\n\n      var parentEl = el.parent;\n      var containerInfo = parentEl === rootGroup ? {\n        width: api.getWidth(),\n        height: api.getHeight()\n      } : {\n        // Like 'position:absolut' in css, default 0.\n        width: parentEl.__ecGraphicWidth || 0,\n        height: parentEl.__ecGraphicHeight || 0\n      };\n      layoutUtil.positionElement(el, elOption, containerInfo, null, {\n        hv: elOption.hv,\n        boundingMode: elOption.bounding\n      });\n    }\n  },\n\n  /**\n   * Clear all elements.\n   *\n   * @private\n   */\n  _clear: function () {\n    var elMap = this._elMap;\n    elMap.each(function (el) {\n      removeEl(el, elMap);\n    });\n    this._elMap = zrUtil.createHashMap();\n  },\n\n  /**\n   * @override\n   */\n  dispose: function () {\n    this._clear();\n  }\n});\n\nfunction createEl(id, targetElParent, elOption, elMap) {\n  var graphicType = elOption.type;\n  var Clz = graphicUtil[graphicType.charAt(0).toUpperCase() + graphicType.slice(1)];\n  var el = new Clz(elOption);\n  targetElParent.add(el);\n  elMap.set(id, el);\n  el.__ecGraphicId = id;\n}\n\nfunction removeEl(existEl, elMap) {\n  var existElParent = existEl && existEl.parent;\n\n  if (existElParent) {\n    existEl.type === 'group' && existEl.traverse(function (el) {\n      removeEl(el, elMap);\n    });\n    elMap.removeKey(existEl.__ecGraphicId);\n    existElParent.remove(existEl);\n  }\n} // Remove unnecessary props to avoid potential problems.\n\n\nfunction getCleanedElOption(elOption) {\n  elOption = zrUtil.extend({}, elOption);\n  zrUtil.each(['id', 'parentId', '$action', 'hv', 'bounding'].concat(layoutUtil.LOCATION_PARAMS), function (name) {\n    delete elOption[name];\n  });\n  return elOption;\n}\n\nfunction isSetLoc(obj, props) {\n  var isSet;\n  zrUtil.each(props, function (prop) {\n    obj[prop] != null && obj[prop] !== 'auto' && (isSet = true);\n  });\n  return isSet;\n}\n\nfunction setKeyInfoToNewElOption(resultItem, newElOption) {\n  var existElOption = resultItem.exist; // Set id and type after id assigned.\n\n  newElOption.id = resultItem.keyInfo.id;\n  !newElOption.type && existElOption && (newElOption.type = existElOption.type); // Set parent id if not specified\n\n  if (newElOption.parentId == null) {\n    var newElParentOption = newElOption.parentOption;\n\n    if (newElParentOption) {\n      newElOption.parentId = newElParentOption.id;\n    } else if (existElOption) {\n      newElOption.parentId = existElOption.parentId;\n    }\n  } // Clear\n\n\n  newElOption.parentOption = null;\n}\n\nfunction mergeNewElOptionToExist(existList, index, newElOption) {\n  // Update existing options, for `getOption` feature.\n  var newElOptCopy = zrUtil.extend({}, newElOption);\n  var existElOption = existList[index];\n  var $action = newElOption.$action || 'merge';\n\n  if ($action === 'merge') {\n    if (existElOption) {\n      // We can ensure that newElOptCopy and existElOption are not\n      // the same object, so `merge` will not change newElOptCopy.\n      zrUtil.merge(existElOption, newElOptCopy, true); // Rigid body, use ignoreSize.\n\n      layoutUtil.mergeLayoutParam(existElOption, newElOptCopy, {\n        ignoreSize: true\n      }); // Will be used in render.\n\n      layoutUtil.copyLayoutParams(newElOption, existElOption);\n    } else {\n      existList[index] = newElOptCopy;\n    }\n  } else if ($action === 'replace') {\n    existList[index] = newElOptCopy;\n  } else if ($action === 'remove') {\n    // null will be cleaned later.\n    existElOption && (existList[index] = null);\n  }\n}\n\nfunction setLayoutInfoToExist(existItem, newElOption) {\n  if (!existItem) {\n    return;\n  }\n\n  existItem.hv = newElOption.hv = [// Rigid body, dont care `width`.\n  isSetLoc(newElOption, ['left', 'right']), // Rigid body, dont care `height`.\n  isSetLoc(newElOption, ['top', 'bottom'])]; // Give default group size. Otherwise layout error may occur.\n\n  if (existItem.type === 'group') {\n    existItem.width == null && (existItem.width = newElOption.width = 0);\n    existItem.height == null && (existItem.height = newElOption.height = 0);\n  }\n}","map":{"version":3,"names":["_config","require","__DEV__","echarts","zrUtil","modelUtil","graphicUtil","layoutUtil","registerPreprocessor","option","graphicOption","graphic","isArray","elements","GraphicModel","extendComponentModel","type","defaultOption","parentId","_elOptionsToUpdate","mergeOption","superApply","arguments","optionUpdated","newOption","isInit","thisOption","newList","existList","flattenedList","_flatten","mappingResult","mappingToExists","makeIdAndName","elOptionsToUpdate","each","resultItem","index","newElOption","push","setKeyInfoToNewElOption","mergeNewElOptionToExist","setLayoutInfoToExist","i","length","splice","$action","optionList","result","parentOption","children","useElOptionsToUpdate","els","extendComponentView","init","ecModel","api","_elMap","createHashMap","_lastGraphicModel","render","graphicModel","_clear","_updateElements","_relocate","elMap","rootGroup","group","elOption","id","existEl","get","targetElParent","elOptionStyle","style","hv","textVerticalAlign","textBaseline","hasOwnProperty","fill","textFill","stroke","textStroke","elOptionCleaned","getCleanedElOption","attr","createEl","removeEl","el","__ecGraphicWidth","width","__ecGraphicHeight","height","elOptions","parentEl","parent","containerInfo","getWidth","getHeight","positionElement","boundingMode","bounding","dispose","graphicType","Clz","charAt","toUpperCase","slice","add","set","__ecGraphicId","existElParent","traverse","removeKey","remove","extend","concat","LOCATION_PARAMS","name","isSetLoc","obj","props","isSet","prop","existElOption","exist","keyInfo","newElParentOption","newElOptCopy","merge","mergeLayoutParam","ignoreSize","copyLayoutParams","existItem"],"sources":["C:/Users/W/Desktop/vue_map/node_modules/echarts/lib/component/graphic.js"],"sourcesContent":["var _config = require(\"../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = require(\"../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar modelUtil = require(\"../util/model\");\n\nvar graphicUtil = require(\"../util/graphic\");\n\nvar layoutUtil = require(\"../util/layout\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// -------------\n// Preprocessor\n// -------------\necharts.registerPreprocessor(function (option) {\n  var graphicOption = option.graphic; // Convert\n  // {graphic: [{left: 10, type: 'circle'}, ...]}\n  // or\n  // {graphic: {left: 10, type: 'circle'}}\n  // to\n  // {graphic: [{elements: [{left: 10, type: 'circle'}, ...]}]}\n\n  if (zrUtil.isArray(graphicOption)) {\n    if (!graphicOption[0] || !graphicOption[0].elements) {\n      option.graphic = [{\n        elements: graphicOption\n      }];\n    } else {\n      // Only one graphic instance can be instantiated. (We dont\n      // want that too many views are created in echarts._viewMap)\n      option.graphic = [option.graphic[0]];\n    }\n  } else if (graphicOption && !graphicOption.elements) {\n    option.graphic = [{\n      elements: [graphicOption]\n    }];\n  }\n}); // ------\n// Model\n// ------\n\nvar GraphicModel = echarts.extendComponentModel({\n  type: 'graphic',\n  defaultOption: {\n    // Extra properties for each elements:\n    //\n    // left/right/top/bottom: (like 12, '22%', 'center', default undefined)\n    //      If left/rigth is set, shape.x/shape.cx/position will not be used.\n    //      If top/bottom is set, shape.y/shape.cy/position will not be used.\n    //      This mechanism is useful when you want to position a group/element\n    //      against the right side or the center of this container.\n    //\n    // width/height: (can only be pixel value, default 0)\n    //      Only be used to specify contianer(group) size, if needed. And\n    //      can not be percentage value (like '33%'). See the reason in the\n    //      layout algorithm below.\n    //\n    // bounding: (enum: 'all' (default) | 'raw')\n    //      Specify how to calculate boundingRect when locating.\n    //      'all': Get uioned and transformed boundingRect\n    //          from both itself and its descendants.\n    //          This mode simplies confining a group of elements in the bounding\n    //          of their ancester container (e.g., using 'right: 0').\n    //      'raw': Only use the boundingRect of itself and before transformed.\n    //          This mode is similar to css behavior, which is useful when you\n    //          want an element to be able to overflow its container. (Consider\n    //          a rotated circle needs to be located in a corner.)\n    // Note: elements is always behind its ancestors in this elements array.\n    elements: [],\n    parentId: null\n  },\n\n  /**\n   * Save el options for the sake of the performance (only update modified graphics).\n   * The order is the same as those in option. (ancesters -> descendants)\n   *\n   * @private\n   * @type {Array.<Object>}\n   */\n  _elOptionsToUpdate: null,\n\n  /**\n   * @override\n   */\n  mergeOption: function (option) {\n    // Prevent default merge to elements\n    var elements = this.option.elements;\n    this.option.elements = null;\n    GraphicModel.superApply(this, 'mergeOption', arguments);\n    this.option.elements = elements;\n  },\n\n  /**\n   * @override\n   */\n  optionUpdated: function (newOption, isInit) {\n    var thisOption = this.option;\n    var newList = (isInit ? thisOption : newOption).elements;\n    var existList = thisOption.elements = isInit ? [] : thisOption.elements;\n    var flattenedList = [];\n\n    this._flatten(newList, flattenedList);\n\n    var mappingResult = modelUtil.mappingToExists(existList, flattenedList);\n    modelUtil.makeIdAndName(mappingResult); // Clear elOptionsToUpdate\n\n    var elOptionsToUpdate = this._elOptionsToUpdate = [];\n    zrUtil.each(mappingResult, function (resultItem, index) {\n      var newElOption = resultItem.option;\n\n      if (!newElOption) {\n        return;\n      }\n\n      elOptionsToUpdate.push(newElOption);\n      setKeyInfoToNewElOption(resultItem, newElOption);\n      mergeNewElOptionToExist(existList, index, newElOption);\n      setLayoutInfoToExist(existList[index], newElOption);\n    }, this); // Clean\n\n    for (var i = existList.length - 1; i >= 0; i--) {\n      if (existList[i] == null) {\n        existList.splice(i, 1);\n      } else {\n        // $action should be volatile, otherwise option gotten from\n        // `getOption` will contain unexpected $action.\n        delete existList[i].$action;\n      }\n    }\n  },\n\n  /**\n   * Convert\n   * [{\n   *  type: 'group',\n   *  id: 'xx',\n   *  children: [{type: 'circle'}, {type: 'polygon'}]\n   * }]\n   * to\n   * [\n   *  {type: 'group', id: 'xx'},\n   *  {type: 'circle', parentId: 'xx'},\n   *  {type: 'polygon', parentId: 'xx'}\n   * ]\n   *\n   * @private\n   * @param {Array.<Object>} optionList option list\n   * @param {Array.<Object>} result result of flatten\n   * @param {Object} parentOption parent option\n   */\n  _flatten: function (optionList, result, parentOption) {\n    zrUtil.each(optionList, function (option) {\n      if (!option) {\n        return;\n      }\n\n      if (parentOption) {\n        option.parentOption = parentOption;\n      }\n\n      result.push(option);\n      var children = option.children;\n\n      if (option.type === 'group' && children) {\n        this._flatten(children, result, option);\n      } // Deleting for JSON output, and for not affecting group creation.\n\n\n      delete option.children;\n    }, this);\n  },\n  // FIXME\n  // Pass to view using payload? setOption has a payload?\n  useElOptionsToUpdate: function () {\n    var els = this._elOptionsToUpdate; // Clear to avoid render duplicately when zooming.\n\n    this._elOptionsToUpdate = null;\n    return els;\n  }\n}); // -----\n// View\n// -----\n\necharts.extendComponentView({\n  type: 'graphic',\n\n  /**\n   * @override\n   */\n  init: function (ecModel, api) {\n    /**\n     * @private\n     * @type {module:zrender/core/util.HashMap}\n     */\n    this._elMap = zrUtil.createHashMap();\n    /**\n     * @private\n     * @type {module:echarts/graphic/GraphicModel}\n     */\n\n    this._lastGraphicModel;\n  },\n\n  /**\n   * @override\n   */\n  render: function (graphicModel, ecModel, api) {\n    // Having leveraged between use cases and algorithm complexity, a very\n    // simple layout mechanism is used:\n    // The size(width/height) can be determined by itself or its parent (not\n    // implemented yet), but can not by its children. (Top-down travel)\n    // The location(x/y) can be determined by the bounding rect of itself\n    // (can including its descendants or not) and the size of its parent.\n    // (Bottom-up travel)\n    // When `chart.clear()` or `chart.setOption({...}, true)` with the same id,\n    // view will be reused.\n    if (graphicModel !== this._lastGraphicModel) {\n      this._clear();\n    }\n\n    this._lastGraphicModel = graphicModel;\n\n    this._updateElements(graphicModel, api);\n\n    this._relocate(graphicModel, api);\n  },\n\n  /**\n   * Update graphic elements.\n   *\n   * @private\n   * @param {Object} graphicModel graphic model\n   * @param {module:echarts/ExtensionAPI} api extension API\n   */\n  _updateElements: function (graphicModel, api) {\n    var elOptionsToUpdate = graphicModel.useElOptionsToUpdate();\n\n    if (!elOptionsToUpdate) {\n      return;\n    }\n\n    var elMap = this._elMap;\n    var rootGroup = this.group; // Top-down tranverse to assign graphic settings to each elements.\n\n    zrUtil.each(elOptionsToUpdate, function (elOption) {\n      var $action = elOption.$action;\n      var id = elOption.id;\n      var existEl = elMap.get(id);\n      var parentId = elOption.parentId;\n      var targetElParent = parentId != null ? elMap.get(parentId) : rootGroup;\n\n      if (elOption.type === 'text') {\n        var elOptionStyle = elOption.style; // In top/bottom mode, textVerticalAlign should not be used, which cause\n        // inaccurately locating.\n\n        if (elOption.hv && elOption.hv[1]) {\n          elOptionStyle.textVerticalAlign = elOptionStyle.textBaseline = null;\n        } // Compatible with previous setting: both support fill and textFill,\n        // stroke and textStroke.\n\n\n        !elOptionStyle.hasOwnProperty('textFill') && elOptionStyle.fill && (elOptionStyle.textFill = elOptionStyle.fill);\n        !elOptionStyle.hasOwnProperty('textStroke') && elOptionStyle.stroke && (elOptionStyle.textStroke = elOptionStyle.stroke);\n      } // Remove unnecessary props to avoid potential problems.\n\n\n      var elOptionCleaned = getCleanedElOption(elOption); // For simple, do not support parent change, otherwise reorder is needed.\n\n      if (!$action || $action === 'merge') {\n        existEl ? existEl.attr(elOptionCleaned) : createEl(id, targetElParent, elOptionCleaned, elMap);\n      } else if ($action === 'replace') {\n        removeEl(existEl, elMap);\n        createEl(id, targetElParent, elOptionCleaned, elMap);\n      } else if ($action === 'remove') {\n        removeEl(existEl, elMap);\n      }\n\n      var el = elMap.get(id);\n\n      if (el) {\n        el.__ecGraphicWidth = elOption.width;\n        el.__ecGraphicHeight = elOption.height;\n      }\n    });\n  },\n\n  /**\n   * Locate graphic elements.\n   *\n   * @private\n   * @param {Object} graphicModel graphic model\n   * @param {module:echarts/ExtensionAPI} api extension API\n   */\n  _relocate: function (graphicModel, api) {\n    var elOptions = graphicModel.option.elements;\n    var rootGroup = this.group;\n    var elMap = this._elMap; // Bottom-up tranvese all elements (consider ec resize) to locate elements.\n\n    for (var i = elOptions.length - 1; i >= 0; i--) {\n      var elOption = elOptions[i];\n      var el = elMap.get(elOption.id);\n\n      if (!el) {\n        continue;\n      }\n\n      var parentEl = el.parent;\n      var containerInfo = parentEl === rootGroup ? {\n        width: api.getWidth(),\n        height: api.getHeight()\n      } : {\n        // Like 'position:absolut' in css, default 0.\n        width: parentEl.__ecGraphicWidth || 0,\n        height: parentEl.__ecGraphicHeight || 0\n      };\n      layoutUtil.positionElement(el, elOption, containerInfo, null, {\n        hv: elOption.hv,\n        boundingMode: elOption.bounding\n      });\n    }\n  },\n\n  /**\n   * Clear all elements.\n   *\n   * @private\n   */\n  _clear: function () {\n    var elMap = this._elMap;\n    elMap.each(function (el) {\n      removeEl(el, elMap);\n    });\n    this._elMap = zrUtil.createHashMap();\n  },\n\n  /**\n   * @override\n   */\n  dispose: function () {\n    this._clear();\n  }\n});\n\nfunction createEl(id, targetElParent, elOption, elMap) {\n  var graphicType = elOption.type;\n  var Clz = graphicUtil[graphicType.charAt(0).toUpperCase() + graphicType.slice(1)];\n  var el = new Clz(elOption);\n  targetElParent.add(el);\n  elMap.set(id, el);\n  el.__ecGraphicId = id;\n}\n\nfunction removeEl(existEl, elMap) {\n  var existElParent = existEl && existEl.parent;\n\n  if (existElParent) {\n    existEl.type === 'group' && existEl.traverse(function (el) {\n      removeEl(el, elMap);\n    });\n    elMap.removeKey(existEl.__ecGraphicId);\n    existElParent.remove(existEl);\n  }\n} // Remove unnecessary props to avoid potential problems.\n\n\nfunction getCleanedElOption(elOption) {\n  elOption = zrUtil.extend({}, elOption);\n  zrUtil.each(['id', 'parentId', '$action', 'hv', 'bounding'].concat(layoutUtil.LOCATION_PARAMS), function (name) {\n    delete elOption[name];\n  });\n  return elOption;\n}\n\nfunction isSetLoc(obj, props) {\n  var isSet;\n  zrUtil.each(props, function (prop) {\n    obj[prop] != null && obj[prop] !== 'auto' && (isSet = true);\n  });\n  return isSet;\n}\n\nfunction setKeyInfoToNewElOption(resultItem, newElOption) {\n  var existElOption = resultItem.exist; // Set id and type after id assigned.\n\n  newElOption.id = resultItem.keyInfo.id;\n  !newElOption.type && existElOption && (newElOption.type = existElOption.type); // Set parent id if not specified\n\n  if (newElOption.parentId == null) {\n    var newElParentOption = newElOption.parentOption;\n\n    if (newElParentOption) {\n      newElOption.parentId = newElParentOption.id;\n    } else if (existElOption) {\n      newElOption.parentId = existElOption.parentId;\n    }\n  } // Clear\n\n\n  newElOption.parentOption = null;\n}\n\nfunction mergeNewElOptionToExist(existList, index, newElOption) {\n  // Update existing options, for `getOption` feature.\n  var newElOptCopy = zrUtil.extend({}, newElOption);\n  var existElOption = existList[index];\n  var $action = newElOption.$action || 'merge';\n\n  if ($action === 'merge') {\n    if (existElOption) {\n      // We can ensure that newElOptCopy and existElOption are not\n      // the same object, so `merge` will not change newElOptCopy.\n      zrUtil.merge(existElOption, newElOptCopy, true); // Rigid body, use ignoreSize.\n\n      layoutUtil.mergeLayoutParam(existElOption, newElOptCopy, {\n        ignoreSize: true\n      }); // Will be used in render.\n\n      layoutUtil.copyLayoutParams(newElOption, existElOption);\n    } else {\n      existList[index] = newElOptCopy;\n    }\n  } else if ($action === 'replace') {\n    existList[index] = newElOptCopy;\n  } else if ($action === 'remove') {\n    // null will be cleaned later.\n    existElOption && (existList[index] = null);\n  }\n}\n\nfunction setLayoutInfoToExist(existItem, newElOption) {\n  if (!existItem) {\n    return;\n  }\n\n  existItem.hv = newElOption.hv = [// Rigid body, dont care `width`.\n  isSetLoc(newElOption, ['left', 'right']), // Rigid body, dont care `height`.\n  isSetLoc(newElOption, ['top', 'bottom'])]; // Give default group size. Otherwise layout error may occur.\n\n  if (existItem.type === 'group') {\n    existItem.width == null && (existItem.width = newElOption.width = 0);\n    existItem.height == null && (existItem.height = newElOption.height = 0);\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}