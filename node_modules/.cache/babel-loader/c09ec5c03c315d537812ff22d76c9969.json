{"ast":null,"code":"var zrUtil = require(\"zrender/lib/core/util\");\n\nvar BoundingRect = require(\"zrender/lib/core/BoundingRect\");\n\nvar parseGeoJson = require(\"./parseGeoJson\");\n\nvar View = require(\"../View\");\n\nvar fixNanhai = require(\"./fix/nanhai\");\n\nvar fixTextCoord = require(\"./fix/textCoord\");\n\nvar fixGeoCoord = require(\"./fix/geoCoord\");\n\nvar fixDiaoyuIsland = require(\"./fix/diaoyuIsland\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Geo fix functions\n\n\nvar geoFixFuncs = [fixNanhai, fixTextCoord, fixGeoCoord, fixDiaoyuIsland];\n/**\n * [Geo description]\n * @param {string} name Geo name\n * @param {string} map Map type\n * @param {Object} geoJson\n * @param {Object} [specialAreas]\n *        Specify the positioned areas by left, top, width, height\n * @param {Object.<string, string>} [nameMap]\n *        Specify name alias\n */\n\nfunction Geo(name, map, geoJson, specialAreas, nameMap) {\n  View.call(this, name);\n  /**\n   * Map type\n   * @type {string}\n   */\n\n  this.map = map;\n  this._nameCoordMap = zrUtil.createHashMap();\n  this.loadGeoJson(geoJson, specialAreas, nameMap);\n}\n\nGeo.prototype = {\n  constructor: Geo,\n  type: 'geo',\n\n  /**\n   * @param {Array.<string>}\n   * @readOnly\n   */\n  dimensions: ['lng', 'lat'],\n\n  /**\n   * If contain given lng,lat coord\n   * @param {Array.<number>}\n   * @readOnly\n   */\n  containCoord: function (coord) {\n    var regions = this.regions;\n\n    for (var i = 0; i < regions.length; i++) {\n      if (regions[i].contain(coord)) {\n        return true;\n      }\n    }\n\n    return false;\n  },\n\n  /**\n   * @param {Object} geoJson\n   * @param {Object} [specialAreas]\n   *        Specify the positioned areas by left, top, width, height\n   * @param {Object.<string, string>} [nameMap]\n   *        Specify name alias\n   */\n  loadGeoJson: function (geoJson, specialAreas, nameMap) {\n    // https://jsperf.com/try-catch-performance-overhead\n    try {\n      this.regions = geoJson ? parseGeoJson(geoJson) : [];\n    } catch (e) {\n      throw 'Invalid geoJson format\\n' + e.message;\n    }\n\n    specialAreas = specialAreas || {};\n    nameMap = nameMap || {};\n    var regions = this.regions;\n    var regionsMap = zrUtil.createHashMap();\n\n    for (var i = 0; i < regions.length; i++) {\n      var regionName = regions[i].name; // Try use the alias in nameMap\n\n      regionName = nameMap.hasOwnProperty(regionName) ? nameMap[regionName] : regionName;\n      regions[i].name = regionName;\n      regionsMap.set(regionName, regions[i]); // Add geoJson\n\n      this.addGeoCoord(regionName, regions[i].center); // Some area like Alaska in USA map needs to be tansformed\n      // to look better\n\n      var specialArea = specialAreas[regionName];\n\n      if (specialArea) {\n        regions[i].transformTo(specialArea.left, specialArea.top, specialArea.width, specialArea.height);\n      }\n    }\n\n    this._regionsMap = regionsMap;\n    this._rect = null;\n    zrUtil.each(geoFixFuncs, function (fixFunc) {\n      fixFunc(this);\n    }, this);\n  },\n  // Overwrite\n  transformTo: function (x, y, width, height) {\n    var rect = this.getBoundingRect();\n    rect = rect.clone(); // Longitute is inverted\n\n    rect.y = -rect.y - rect.height;\n    var rawTransformable = this._rawTransformable;\n    rawTransformable.transform = rect.calculateTransform(new BoundingRect(x, y, width, height));\n    rawTransformable.decomposeTransform();\n    var scale = rawTransformable.scale;\n    scale[1] = -scale[1];\n    rawTransformable.updateTransform();\n\n    this._updateTransform();\n  },\n\n  /**\n   * @param {string} name\n   * @return {module:echarts/coord/geo/Region}\n   */\n  getRegion: function (name) {\n    return this._regionsMap.get(name);\n  },\n  getRegionByCoord: function (coord) {\n    var regions = this.regions;\n\n    for (var i = 0; i < regions.length; i++) {\n      if (regions[i].contain(coord)) {\n        return regions[i];\n      }\n    }\n  },\n\n  /**\n   * Add geoCoord for indexing by name\n   * @param {string} name\n   * @param {Array.<number>} geoCoord\n   */\n  addGeoCoord: function (name, geoCoord) {\n    this._nameCoordMap.set(name, geoCoord);\n  },\n\n  /**\n   * Get geoCoord by name\n   * @param {string} name\n   * @return {Array.<number>}\n   */\n  getGeoCoord: function (name) {\n    return this._nameCoordMap.get(name);\n  },\n  // Overwrite\n  getBoundingRect: function () {\n    if (this._rect) {\n      return this._rect;\n    }\n\n    var rect;\n    var regions = this.regions;\n\n    for (var i = 0; i < regions.length; i++) {\n      var regionRect = regions[i].getBoundingRect();\n      rect = rect || regionRect.clone();\n      rect.union(regionRect);\n    } // FIXME Always return new ?\n\n\n    return this._rect = rect || new BoundingRect(0, 0, 0, 0);\n  },\n\n  /**\n   * @param {string|Array.<number>} data\n   * @param {boolean} noRoam\n   * @param {Array.<number>} [out]\n   * @return {Array.<number>}\n   */\n  dataToPoint: function (data, noRoam, out) {\n    if (typeof data === 'string') {\n      // Map area name to geoCoord\n      data = this.getGeoCoord(data);\n    }\n\n    if (data) {\n      return View.prototype.dataToPoint.call(this, data, noRoam, out);\n    }\n  },\n\n  /**\n   * @inheritDoc\n   */\n  convertToPixel: zrUtil.curry(doConvert, 'dataToPoint'),\n\n  /**\n   * @inheritDoc\n   */\n  convertFromPixel: zrUtil.curry(doConvert, 'pointToData')\n};\nzrUtil.mixin(Geo, View);\n\nfunction doConvert(methodName, ecModel, finder, value) {\n  var geoModel = finder.geoModel;\n  var seriesModel = finder.seriesModel;\n  var coordSys = geoModel ? geoModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem // For map.\n  || (seriesModel.getReferringComponents('geo')[0] || {}).coordinateSystem : null;\n  return coordSys === this ? coordSys[methodName](value) : null;\n}\n\nvar _default = Geo;\nmodule.exports = _default;","map":{"version":3,"names":["zrUtil","require","BoundingRect","parseGeoJson","View","fixNanhai","fixTextCoord","fixGeoCoord","fixDiaoyuIsland","geoFixFuncs","Geo","name","map","geoJson","specialAreas","nameMap","call","_nameCoordMap","createHashMap","loadGeoJson","prototype","constructor","type","dimensions","containCoord","coord","regions","i","length","contain","e","message","regionsMap","regionName","hasOwnProperty","set","addGeoCoord","center","specialArea","transformTo","left","top","width","height","_regionsMap","_rect","each","fixFunc","x","y","rect","getBoundingRect","clone","rawTransformable","_rawTransformable","transform","calculateTransform","decomposeTransform","scale","updateTransform","_updateTransform","getRegion","get","getRegionByCoord","geoCoord","getGeoCoord","regionRect","union","dataToPoint","data","noRoam","out","convertToPixel","curry","doConvert","convertFromPixel","mixin","methodName","ecModel","finder","value","geoModel","seriesModel","coordSys","coordinateSystem","getReferringComponents","_default","module","exports"],"sources":["C:/Users/W/Desktop/vue_map/node_modules/echarts/lib/coord/geo/Geo.js"],"sourcesContent":["var zrUtil = require(\"zrender/lib/core/util\");\n\nvar BoundingRect = require(\"zrender/lib/core/BoundingRect\");\n\nvar parseGeoJson = require(\"./parseGeoJson\");\n\nvar View = require(\"../View\");\n\nvar fixNanhai = require(\"./fix/nanhai\");\n\nvar fixTextCoord = require(\"./fix/textCoord\");\n\nvar fixGeoCoord = require(\"./fix/geoCoord\");\n\nvar fixDiaoyuIsland = require(\"./fix/diaoyuIsland\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Geo fix functions\nvar geoFixFuncs = [fixNanhai, fixTextCoord, fixGeoCoord, fixDiaoyuIsland];\n/**\n * [Geo description]\n * @param {string} name Geo name\n * @param {string} map Map type\n * @param {Object} geoJson\n * @param {Object} [specialAreas]\n *        Specify the positioned areas by left, top, width, height\n * @param {Object.<string, string>} [nameMap]\n *        Specify name alias\n */\n\nfunction Geo(name, map, geoJson, specialAreas, nameMap) {\n  View.call(this, name);\n  /**\n   * Map type\n   * @type {string}\n   */\n\n  this.map = map;\n  this._nameCoordMap = zrUtil.createHashMap();\n  this.loadGeoJson(geoJson, specialAreas, nameMap);\n}\n\nGeo.prototype = {\n  constructor: Geo,\n  type: 'geo',\n\n  /**\n   * @param {Array.<string>}\n   * @readOnly\n   */\n  dimensions: ['lng', 'lat'],\n\n  /**\n   * If contain given lng,lat coord\n   * @param {Array.<number>}\n   * @readOnly\n   */\n  containCoord: function (coord) {\n    var regions = this.regions;\n\n    for (var i = 0; i < regions.length; i++) {\n      if (regions[i].contain(coord)) {\n        return true;\n      }\n    }\n\n    return false;\n  },\n\n  /**\n   * @param {Object} geoJson\n   * @param {Object} [specialAreas]\n   *        Specify the positioned areas by left, top, width, height\n   * @param {Object.<string, string>} [nameMap]\n   *        Specify name alias\n   */\n  loadGeoJson: function (geoJson, specialAreas, nameMap) {\n    // https://jsperf.com/try-catch-performance-overhead\n    try {\n      this.regions = geoJson ? parseGeoJson(geoJson) : [];\n    } catch (e) {\n      throw 'Invalid geoJson format\\n' + e.message;\n    }\n\n    specialAreas = specialAreas || {};\n    nameMap = nameMap || {};\n    var regions = this.regions;\n    var regionsMap = zrUtil.createHashMap();\n\n    for (var i = 0; i < regions.length; i++) {\n      var regionName = regions[i].name; // Try use the alias in nameMap\n\n      regionName = nameMap.hasOwnProperty(regionName) ? nameMap[regionName] : regionName;\n      regions[i].name = regionName;\n      regionsMap.set(regionName, regions[i]); // Add geoJson\n\n      this.addGeoCoord(regionName, regions[i].center); // Some area like Alaska in USA map needs to be tansformed\n      // to look better\n\n      var specialArea = specialAreas[regionName];\n\n      if (specialArea) {\n        regions[i].transformTo(specialArea.left, specialArea.top, specialArea.width, specialArea.height);\n      }\n    }\n\n    this._regionsMap = regionsMap;\n    this._rect = null;\n    zrUtil.each(geoFixFuncs, function (fixFunc) {\n      fixFunc(this);\n    }, this);\n  },\n  // Overwrite\n  transformTo: function (x, y, width, height) {\n    var rect = this.getBoundingRect();\n    rect = rect.clone(); // Longitute is inverted\n\n    rect.y = -rect.y - rect.height;\n    var rawTransformable = this._rawTransformable;\n    rawTransformable.transform = rect.calculateTransform(new BoundingRect(x, y, width, height));\n    rawTransformable.decomposeTransform();\n    var scale = rawTransformable.scale;\n    scale[1] = -scale[1];\n    rawTransformable.updateTransform();\n\n    this._updateTransform();\n  },\n\n  /**\n   * @param {string} name\n   * @return {module:echarts/coord/geo/Region}\n   */\n  getRegion: function (name) {\n    return this._regionsMap.get(name);\n  },\n  getRegionByCoord: function (coord) {\n    var regions = this.regions;\n\n    for (var i = 0; i < regions.length; i++) {\n      if (regions[i].contain(coord)) {\n        return regions[i];\n      }\n    }\n  },\n\n  /**\n   * Add geoCoord for indexing by name\n   * @param {string} name\n   * @param {Array.<number>} geoCoord\n   */\n  addGeoCoord: function (name, geoCoord) {\n    this._nameCoordMap.set(name, geoCoord);\n  },\n\n  /**\n   * Get geoCoord by name\n   * @param {string} name\n   * @return {Array.<number>}\n   */\n  getGeoCoord: function (name) {\n    return this._nameCoordMap.get(name);\n  },\n  // Overwrite\n  getBoundingRect: function () {\n    if (this._rect) {\n      return this._rect;\n    }\n\n    var rect;\n    var regions = this.regions;\n\n    for (var i = 0; i < regions.length; i++) {\n      var regionRect = regions[i].getBoundingRect();\n      rect = rect || regionRect.clone();\n      rect.union(regionRect);\n    } // FIXME Always return new ?\n\n\n    return this._rect = rect || new BoundingRect(0, 0, 0, 0);\n  },\n\n  /**\n   * @param {string|Array.<number>} data\n   * @param {boolean} noRoam\n   * @param {Array.<number>} [out]\n   * @return {Array.<number>}\n   */\n  dataToPoint: function (data, noRoam, out) {\n    if (typeof data === 'string') {\n      // Map area name to geoCoord\n      data = this.getGeoCoord(data);\n    }\n\n    if (data) {\n      return View.prototype.dataToPoint.call(this, data, noRoam, out);\n    }\n  },\n\n  /**\n   * @inheritDoc\n   */\n  convertToPixel: zrUtil.curry(doConvert, 'dataToPoint'),\n\n  /**\n   * @inheritDoc\n   */\n  convertFromPixel: zrUtil.curry(doConvert, 'pointToData')\n};\nzrUtil.mixin(Geo, View);\n\nfunction doConvert(methodName, ecModel, finder, value) {\n  var geoModel = finder.geoModel;\n  var seriesModel = finder.seriesModel;\n  var coordSys = geoModel ? geoModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem // For map.\n  || (seriesModel.getReferringComponents('geo')[0] || {}).coordinateSystem : null;\n  return coordSys === this ? coordSys[methodName](value) : null;\n}\n\nvar _default = Geo;\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}