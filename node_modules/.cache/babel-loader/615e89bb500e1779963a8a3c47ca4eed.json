{"ast":null,"code":"var PointerPath = require(\"./PointerPath\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar ChartView = require(\"../../view/Chart\");\n\nvar _number = require(\"../../util/number\");\n\nvar parsePercent = _number.parsePercent;\nvar round = _number.round;\nvar linearMap = _number.linearMap;\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nfunction parsePosition(seriesModel, api) {\n  var center = seriesModel.get('center');\n  var width = api.getWidth();\n  var height = api.getHeight();\n  var size = Math.min(width, height);\n  var cx = parsePercent(center[0], api.getWidth());\n  var cy = parsePercent(center[1], api.getHeight());\n  var r = parsePercent(seriesModel.get('radius'), size / 2);\n  return {\n    cx: cx,\n    cy: cy,\n    r: r\n  };\n}\n\nfunction formatLabel(label, labelFormatter) {\n  if (labelFormatter) {\n    if (typeof labelFormatter === 'string') {\n      label = labelFormatter.replace('{value}', label != null ? label : '');\n    } else if (typeof labelFormatter === 'function') {\n      label = labelFormatter(label);\n    }\n  }\n\n  return label;\n}\n\nvar PI2 = Math.PI * 2;\nvar GaugeView = ChartView.extend({\n  type: 'gauge',\n  render: function (seriesModel, ecModel, api) {\n    this.group.removeAll();\n    var colorList = seriesModel.get('axisLine.lineStyle.color');\n    var posInfo = parsePosition(seriesModel, api);\n\n    this._renderMain(seriesModel, ecModel, api, colorList, posInfo);\n  },\n  dispose: function () {},\n  _renderMain: function (seriesModel, ecModel, api, colorList, posInfo) {\n    var group = this.group;\n    var axisLineModel = seriesModel.getModel('axisLine');\n    var lineStyleModel = axisLineModel.getModel('lineStyle');\n    var clockwise = seriesModel.get('clockwise');\n    var startAngle = -seriesModel.get('startAngle') / 180 * Math.PI;\n    var endAngle = -seriesModel.get('endAngle') / 180 * Math.PI;\n    var angleRangeSpan = (endAngle - startAngle) % PI2;\n    var prevEndAngle = startAngle;\n    var axisLineWidth = lineStyleModel.get('width');\n\n    for (var i = 0; i < colorList.length; i++) {\n      // Clamp\n      var percent = Math.min(Math.max(colorList[i][0], 0), 1);\n      var endAngle = startAngle + angleRangeSpan * percent;\n      var sector = new graphic.Sector({\n        shape: {\n          startAngle: prevEndAngle,\n          endAngle: endAngle,\n          cx: posInfo.cx,\n          cy: posInfo.cy,\n          clockwise: clockwise,\n          r0: posInfo.r - axisLineWidth,\n          r: posInfo.r\n        },\n        silent: true\n      });\n      sector.setStyle({\n        fill: colorList[i][1]\n      });\n      sector.setStyle(lineStyleModel.getLineStyle( // Because we use sector to simulate arc\n      // so the properties for stroking are useless\n      ['color', 'borderWidth', 'borderColor']));\n      group.add(sector);\n      prevEndAngle = endAngle;\n    }\n\n    var getColor = function (percent) {\n      // Less than 0\n      if (percent <= 0) {\n        return colorList[0][1];\n      }\n\n      for (var i = 0; i < colorList.length; i++) {\n        if (colorList[i][0] >= percent && (i === 0 ? 0 : colorList[i - 1][0]) < percent) {\n          return colorList[i][1];\n        }\n      } // More than 1\n\n\n      return colorList[i - 1][1];\n    };\n\n    if (!clockwise) {\n      var tmp = startAngle;\n      startAngle = endAngle;\n      endAngle = tmp;\n    }\n\n    this._renderTicks(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise);\n\n    this._renderPointer(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise);\n\n    this._renderTitle(seriesModel, ecModel, api, getColor, posInfo);\n\n    this._renderDetail(seriesModel, ecModel, api, getColor, posInfo);\n  },\n  _renderTicks: function (seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise) {\n    var group = this.group;\n    var cx = posInfo.cx;\n    var cy = posInfo.cy;\n    var r = posInfo.r;\n    var minVal = +seriesModel.get('min');\n    var maxVal = +seriesModel.get('max');\n    var splitLineModel = seriesModel.getModel('splitLine');\n    var tickModel = seriesModel.getModel('axisTick');\n    var labelModel = seriesModel.getModel('axisLabel');\n    var splitNumber = seriesModel.get('splitNumber');\n    var subSplitNumber = tickModel.get('splitNumber');\n    var splitLineLen = parsePercent(splitLineModel.get('length'), r);\n    var tickLen = parsePercent(tickModel.get('length'), r);\n    var angle = startAngle;\n    var step = (endAngle - startAngle) / splitNumber;\n    var subStep = step / subSplitNumber;\n    var splitLineStyle = splitLineModel.getModel('lineStyle').getLineStyle();\n    var tickLineStyle = tickModel.getModel('lineStyle').getLineStyle();\n\n    for (var i = 0; i <= splitNumber; i++) {\n      var unitX = Math.cos(angle);\n      var unitY = Math.sin(angle); // Split line\n\n      if (splitLineModel.get('show')) {\n        var splitLine = new graphic.Line({\n          shape: {\n            x1: unitX * r + cx,\n            y1: unitY * r + cy,\n            x2: unitX * (r - splitLineLen) + cx,\n            y2: unitY * (r - splitLineLen) + cy\n          },\n          style: splitLineStyle,\n          silent: true\n        });\n\n        if (splitLineStyle.stroke === 'auto') {\n          splitLine.setStyle({\n            stroke: getColor(i / splitNumber)\n          });\n        }\n\n        group.add(splitLine);\n      } // Label\n\n\n      if (labelModel.get('show')) {\n        var label = formatLabel(round(i / splitNumber * (maxVal - minVal) + minVal), labelModel.get('formatter'));\n        var distance = labelModel.get('distance');\n        var autoColor = getColor(i / splitNumber);\n        group.add(new graphic.Text({\n          style: graphic.setTextStyle({}, labelModel, {\n            text: label,\n            x: unitX * (r - splitLineLen - distance) + cx,\n            y: unitY * (r - splitLineLen - distance) + cy,\n            textVerticalAlign: unitY < -0.4 ? 'top' : unitY > 0.4 ? 'bottom' : 'middle',\n            textAlign: unitX < -0.4 ? 'left' : unitX > 0.4 ? 'right' : 'center'\n          }, {\n            autoColor: autoColor\n          }),\n          silent: true\n        }));\n      } // Axis tick\n\n\n      if (tickModel.get('show') && i !== splitNumber) {\n        for (var j = 0; j <= subSplitNumber; j++) {\n          var unitX = Math.cos(angle);\n          var unitY = Math.sin(angle);\n          var tickLine = new graphic.Line({\n            shape: {\n              x1: unitX * r + cx,\n              y1: unitY * r + cy,\n              x2: unitX * (r - tickLen) + cx,\n              y2: unitY * (r - tickLen) + cy\n            },\n            silent: true,\n            style: tickLineStyle\n          });\n\n          if (tickLineStyle.stroke === 'auto') {\n            tickLine.setStyle({\n              stroke: getColor((i + j / subSplitNumber) / splitNumber)\n            });\n          }\n\n          group.add(tickLine);\n          angle += subStep;\n        }\n\n        angle -= subStep;\n      } else {\n        angle += step;\n      }\n    }\n  },\n  _renderPointer: function (seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise) {\n    var group = this.group;\n    var oldData = this._data;\n\n    if (!seriesModel.get('pointer.show')) {\n      // Remove old element\n      oldData && oldData.eachItemGraphicEl(function (el) {\n        group.remove(el);\n      });\n      return;\n    }\n\n    var valueExtent = [+seriesModel.get('min'), +seriesModel.get('max')];\n    var angleExtent = [startAngle, endAngle];\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    data.diff(oldData).add(function (idx) {\n      var pointer = new PointerPath({\n        shape: {\n          angle: startAngle\n        }\n      });\n      graphic.initProps(pointer, {\n        shape: {\n          angle: linearMap(data.get(valueDim, idx), valueExtent, angleExtent, true)\n        }\n      }, seriesModel);\n      group.add(pointer);\n      data.setItemGraphicEl(idx, pointer);\n    }).update(function (newIdx, oldIdx) {\n      var pointer = oldData.getItemGraphicEl(oldIdx);\n      graphic.updateProps(pointer, {\n        shape: {\n          angle: linearMap(data.get(valueDim, newIdx), valueExtent, angleExtent, true)\n        }\n      }, seriesModel);\n      group.add(pointer);\n      data.setItemGraphicEl(newIdx, pointer);\n    }).remove(function (idx) {\n      var pointer = oldData.getItemGraphicEl(idx);\n      group.remove(pointer);\n    }).execute();\n    data.eachItemGraphicEl(function (pointer, idx) {\n      var itemModel = data.getItemModel(idx);\n      var pointerModel = itemModel.getModel('pointer');\n      pointer.setShape({\n        x: posInfo.cx,\n        y: posInfo.cy,\n        width: parsePercent(pointerModel.get('width'), posInfo.r),\n        r: parsePercent(pointerModel.get('length'), posInfo.r)\n      });\n      pointer.useStyle(itemModel.getModel('itemStyle').getItemStyle());\n\n      if (pointer.style.fill === 'auto') {\n        pointer.setStyle('fill', getColor(linearMap(data.get(valueDim, idx), valueExtent, [0, 1], true)));\n      }\n\n      graphic.setHoverStyle(pointer, itemModel.getModel('emphasis.itemStyle').getItemStyle());\n    });\n    this._data = data;\n  },\n  _renderTitle: function (seriesModel, ecModel, api, getColor, posInfo) {\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    var titleModel = seriesModel.getModel('title');\n\n    if (titleModel.get('show')) {\n      var offsetCenter = titleModel.get('offsetCenter');\n      var x = posInfo.cx + parsePercent(offsetCenter[0], posInfo.r);\n      var y = posInfo.cy + parsePercent(offsetCenter[1], posInfo.r);\n      var minVal = +seriesModel.get('min');\n      var maxVal = +seriesModel.get('max');\n      var value = seriesModel.getData().get(valueDim, 0);\n      var autoColor = getColor(linearMap(value, [minVal, maxVal], [0, 1], true));\n      this.group.add(new graphic.Text({\n        silent: true,\n        style: graphic.setTextStyle({}, titleModel, {\n          x: x,\n          y: y,\n          // FIXME First data name ?\n          text: data.getName(0),\n          textAlign: 'center',\n          textVerticalAlign: 'middle'\n        }, {\n          autoColor: autoColor,\n          forceRich: true\n        })\n      }));\n    }\n  },\n  _renderDetail: function (seriesModel, ecModel, api, getColor, posInfo) {\n    var detailModel = seriesModel.getModel('detail');\n    var minVal = +seriesModel.get('min');\n    var maxVal = +seriesModel.get('max');\n\n    if (detailModel.get('show')) {\n      var offsetCenter = detailModel.get('offsetCenter');\n      var x = posInfo.cx + parsePercent(offsetCenter[0], posInfo.r);\n      var y = posInfo.cy + parsePercent(offsetCenter[1], posInfo.r);\n      var width = parsePercent(detailModel.get('width'), posInfo.r);\n      var height = parsePercent(detailModel.get('height'), posInfo.r);\n      var data = seriesModel.getData();\n      var value = data.get(data.mapDimension('value'), 0);\n      var autoColor = getColor(linearMap(value, [minVal, maxVal], [0, 1], true));\n      this.group.add(new graphic.Text({\n        silent: true,\n        style: graphic.setTextStyle({}, detailModel, {\n          x: x,\n          y: y,\n          text: formatLabel( // FIXME First data name ?\n          value, detailModel.get('formatter')),\n          textWidth: isNaN(width) ? null : width,\n          textHeight: isNaN(height) ? null : height,\n          textAlign: 'center',\n          textVerticalAlign: 'middle'\n        }, {\n          autoColor: autoColor,\n          forceRich: true\n        })\n      }));\n    }\n  }\n});\nvar _default = GaugeView;\nmodule.exports = _default;","map":{"version":3,"names":["PointerPath","require","graphic","ChartView","_number","parsePercent","round","linearMap","parsePosition","seriesModel","api","center","get","width","getWidth","height","getHeight","size","Math","min","cx","cy","r","formatLabel","label","labelFormatter","replace","PI2","PI","GaugeView","extend","type","render","ecModel","group","removeAll","colorList","posInfo","_renderMain","dispose","axisLineModel","getModel","lineStyleModel","clockwise","startAngle","endAngle","angleRangeSpan","prevEndAngle","axisLineWidth","i","length","percent","max","sector","Sector","shape","r0","silent","setStyle","fill","getLineStyle","add","getColor","tmp","_renderTicks","_renderPointer","_renderTitle","_renderDetail","minVal","maxVal","splitLineModel","tickModel","labelModel","splitNumber","subSplitNumber","splitLineLen","tickLen","angle","step","subStep","splitLineStyle","tickLineStyle","unitX","cos","unitY","sin","splitLine","Line","x1","y1","x2","y2","style","stroke","distance","autoColor","Text","setTextStyle","text","x","y","textVerticalAlign","textAlign","j","tickLine","oldData","_data","eachItemGraphicEl","el","remove","valueExtent","angleExtent","data","getData","valueDim","mapDimension","diff","idx","pointer","initProps","setItemGraphicEl","update","newIdx","oldIdx","getItemGraphicEl","updateProps","execute","itemModel","getItemModel","pointerModel","setShape","useStyle","getItemStyle","setHoverStyle","titleModel","offsetCenter","value","getName","forceRich","detailModel","textWidth","isNaN","textHeight","_default","module","exports"],"sources":["C:/Users/W/Desktop/vue_map/node_modules/echarts/lib/chart/gauge/GaugeView.js"],"sourcesContent":["var PointerPath = require(\"./PointerPath\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar ChartView = require(\"../../view/Chart\");\n\nvar _number = require(\"../../util/number\");\n\nvar parsePercent = _number.parsePercent;\nvar round = _number.round;\nvar linearMap = _number.linearMap;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction parsePosition(seriesModel, api) {\n  var center = seriesModel.get('center');\n  var width = api.getWidth();\n  var height = api.getHeight();\n  var size = Math.min(width, height);\n  var cx = parsePercent(center[0], api.getWidth());\n  var cy = parsePercent(center[1], api.getHeight());\n  var r = parsePercent(seriesModel.get('radius'), size / 2);\n  return {\n    cx: cx,\n    cy: cy,\n    r: r\n  };\n}\n\nfunction formatLabel(label, labelFormatter) {\n  if (labelFormatter) {\n    if (typeof labelFormatter === 'string') {\n      label = labelFormatter.replace('{value}', label != null ? label : '');\n    } else if (typeof labelFormatter === 'function') {\n      label = labelFormatter(label);\n    }\n  }\n\n  return label;\n}\n\nvar PI2 = Math.PI * 2;\nvar GaugeView = ChartView.extend({\n  type: 'gauge',\n  render: function (seriesModel, ecModel, api) {\n    this.group.removeAll();\n    var colorList = seriesModel.get('axisLine.lineStyle.color');\n    var posInfo = parsePosition(seriesModel, api);\n\n    this._renderMain(seriesModel, ecModel, api, colorList, posInfo);\n  },\n  dispose: function () {},\n  _renderMain: function (seriesModel, ecModel, api, colorList, posInfo) {\n    var group = this.group;\n    var axisLineModel = seriesModel.getModel('axisLine');\n    var lineStyleModel = axisLineModel.getModel('lineStyle');\n    var clockwise = seriesModel.get('clockwise');\n    var startAngle = -seriesModel.get('startAngle') / 180 * Math.PI;\n    var endAngle = -seriesModel.get('endAngle') / 180 * Math.PI;\n    var angleRangeSpan = (endAngle - startAngle) % PI2;\n    var prevEndAngle = startAngle;\n    var axisLineWidth = lineStyleModel.get('width');\n\n    for (var i = 0; i < colorList.length; i++) {\n      // Clamp\n      var percent = Math.min(Math.max(colorList[i][0], 0), 1);\n      var endAngle = startAngle + angleRangeSpan * percent;\n      var sector = new graphic.Sector({\n        shape: {\n          startAngle: prevEndAngle,\n          endAngle: endAngle,\n          cx: posInfo.cx,\n          cy: posInfo.cy,\n          clockwise: clockwise,\n          r0: posInfo.r - axisLineWidth,\n          r: posInfo.r\n        },\n        silent: true\n      });\n      sector.setStyle({\n        fill: colorList[i][1]\n      });\n      sector.setStyle(lineStyleModel.getLineStyle( // Because we use sector to simulate arc\n      // so the properties for stroking are useless\n      ['color', 'borderWidth', 'borderColor']));\n      group.add(sector);\n      prevEndAngle = endAngle;\n    }\n\n    var getColor = function (percent) {\n      // Less than 0\n      if (percent <= 0) {\n        return colorList[0][1];\n      }\n\n      for (var i = 0; i < colorList.length; i++) {\n        if (colorList[i][0] >= percent && (i === 0 ? 0 : colorList[i - 1][0]) < percent) {\n          return colorList[i][1];\n        }\n      } // More than 1\n\n\n      return colorList[i - 1][1];\n    };\n\n    if (!clockwise) {\n      var tmp = startAngle;\n      startAngle = endAngle;\n      endAngle = tmp;\n    }\n\n    this._renderTicks(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise);\n\n    this._renderPointer(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise);\n\n    this._renderTitle(seriesModel, ecModel, api, getColor, posInfo);\n\n    this._renderDetail(seriesModel, ecModel, api, getColor, posInfo);\n  },\n  _renderTicks: function (seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise) {\n    var group = this.group;\n    var cx = posInfo.cx;\n    var cy = posInfo.cy;\n    var r = posInfo.r;\n    var minVal = +seriesModel.get('min');\n    var maxVal = +seriesModel.get('max');\n    var splitLineModel = seriesModel.getModel('splitLine');\n    var tickModel = seriesModel.getModel('axisTick');\n    var labelModel = seriesModel.getModel('axisLabel');\n    var splitNumber = seriesModel.get('splitNumber');\n    var subSplitNumber = tickModel.get('splitNumber');\n    var splitLineLen = parsePercent(splitLineModel.get('length'), r);\n    var tickLen = parsePercent(tickModel.get('length'), r);\n    var angle = startAngle;\n    var step = (endAngle - startAngle) / splitNumber;\n    var subStep = step / subSplitNumber;\n    var splitLineStyle = splitLineModel.getModel('lineStyle').getLineStyle();\n    var tickLineStyle = tickModel.getModel('lineStyle').getLineStyle();\n\n    for (var i = 0; i <= splitNumber; i++) {\n      var unitX = Math.cos(angle);\n      var unitY = Math.sin(angle); // Split line\n\n      if (splitLineModel.get('show')) {\n        var splitLine = new graphic.Line({\n          shape: {\n            x1: unitX * r + cx,\n            y1: unitY * r + cy,\n            x2: unitX * (r - splitLineLen) + cx,\n            y2: unitY * (r - splitLineLen) + cy\n          },\n          style: splitLineStyle,\n          silent: true\n        });\n\n        if (splitLineStyle.stroke === 'auto') {\n          splitLine.setStyle({\n            stroke: getColor(i / splitNumber)\n          });\n        }\n\n        group.add(splitLine);\n      } // Label\n\n\n      if (labelModel.get('show')) {\n        var label = formatLabel(round(i / splitNumber * (maxVal - minVal) + minVal), labelModel.get('formatter'));\n        var distance = labelModel.get('distance');\n        var autoColor = getColor(i / splitNumber);\n        group.add(new graphic.Text({\n          style: graphic.setTextStyle({}, labelModel, {\n            text: label,\n            x: unitX * (r - splitLineLen - distance) + cx,\n            y: unitY * (r - splitLineLen - distance) + cy,\n            textVerticalAlign: unitY < -0.4 ? 'top' : unitY > 0.4 ? 'bottom' : 'middle',\n            textAlign: unitX < -0.4 ? 'left' : unitX > 0.4 ? 'right' : 'center'\n          }, {\n            autoColor: autoColor\n          }),\n          silent: true\n        }));\n      } // Axis tick\n\n\n      if (tickModel.get('show') && i !== splitNumber) {\n        for (var j = 0; j <= subSplitNumber; j++) {\n          var unitX = Math.cos(angle);\n          var unitY = Math.sin(angle);\n          var tickLine = new graphic.Line({\n            shape: {\n              x1: unitX * r + cx,\n              y1: unitY * r + cy,\n              x2: unitX * (r - tickLen) + cx,\n              y2: unitY * (r - tickLen) + cy\n            },\n            silent: true,\n            style: tickLineStyle\n          });\n\n          if (tickLineStyle.stroke === 'auto') {\n            tickLine.setStyle({\n              stroke: getColor((i + j / subSplitNumber) / splitNumber)\n            });\n          }\n\n          group.add(tickLine);\n          angle += subStep;\n        }\n\n        angle -= subStep;\n      } else {\n        angle += step;\n      }\n    }\n  },\n  _renderPointer: function (seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise) {\n    var group = this.group;\n    var oldData = this._data;\n\n    if (!seriesModel.get('pointer.show')) {\n      // Remove old element\n      oldData && oldData.eachItemGraphicEl(function (el) {\n        group.remove(el);\n      });\n      return;\n    }\n\n    var valueExtent = [+seriesModel.get('min'), +seriesModel.get('max')];\n    var angleExtent = [startAngle, endAngle];\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    data.diff(oldData).add(function (idx) {\n      var pointer = new PointerPath({\n        shape: {\n          angle: startAngle\n        }\n      });\n      graphic.initProps(pointer, {\n        shape: {\n          angle: linearMap(data.get(valueDim, idx), valueExtent, angleExtent, true)\n        }\n      }, seriesModel);\n      group.add(pointer);\n      data.setItemGraphicEl(idx, pointer);\n    }).update(function (newIdx, oldIdx) {\n      var pointer = oldData.getItemGraphicEl(oldIdx);\n      graphic.updateProps(pointer, {\n        shape: {\n          angle: linearMap(data.get(valueDim, newIdx), valueExtent, angleExtent, true)\n        }\n      }, seriesModel);\n      group.add(pointer);\n      data.setItemGraphicEl(newIdx, pointer);\n    }).remove(function (idx) {\n      var pointer = oldData.getItemGraphicEl(idx);\n      group.remove(pointer);\n    }).execute();\n    data.eachItemGraphicEl(function (pointer, idx) {\n      var itemModel = data.getItemModel(idx);\n      var pointerModel = itemModel.getModel('pointer');\n      pointer.setShape({\n        x: posInfo.cx,\n        y: posInfo.cy,\n        width: parsePercent(pointerModel.get('width'), posInfo.r),\n        r: parsePercent(pointerModel.get('length'), posInfo.r)\n      });\n      pointer.useStyle(itemModel.getModel('itemStyle').getItemStyle());\n\n      if (pointer.style.fill === 'auto') {\n        pointer.setStyle('fill', getColor(linearMap(data.get(valueDim, idx), valueExtent, [0, 1], true)));\n      }\n\n      graphic.setHoverStyle(pointer, itemModel.getModel('emphasis.itemStyle').getItemStyle());\n    });\n    this._data = data;\n  },\n  _renderTitle: function (seriesModel, ecModel, api, getColor, posInfo) {\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    var titleModel = seriesModel.getModel('title');\n\n    if (titleModel.get('show')) {\n      var offsetCenter = titleModel.get('offsetCenter');\n      var x = posInfo.cx + parsePercent(offsetCenter[0], posInfo.r);\n      var y = posInfo.cy + parsePercent(offsetCenter[1], posInfo.r);\n      var minVal = +seriesModel.get('min');\n      var maxVal = +seriesModel.get('max');\n      var value = seriesModel.getData().get(valueDim, 0);\n      var autoColor = getColor(linearMap(value, [minVal, maxVal], [0, 1], true));\n      this.group.add(new graphic.Text({\n        silent: true,\n        style: graphic.setTextStyle({}, titleModel, {\n          x: x,\n          y: y,\n          // FIXME First data name ?\n          text: data.getName(0),\n          textAlign: 'center',\n          textVerticalAlign: 'middle'\n        }, {\n          autoColor: autoColor,\n          forceRich: true\n        })\n      }));\n    }\n  },\n  _renderDetail: function (seriesModel, ecModel, api, getColor, posInfo) {\n    var detailModel = seriesModel.getModel('detail');\n    var minVal = +seriesModel.get('min');\n    var maxVal = +seriesModel.get('max');\n\n    if (detailModel.get('show')) {\n      var offsetCenter = detailModel.get('offsetCenter');\n      var x = posInfo.cx + parsePercent(offsetCenter[0], posInfo.r);\n      var y = posInfo.cy + parsePercent(offsetCenter[1], posInfo.r);\n      var width = parsePercent(detailModel.get('width'), posInfo.r);\n      var height = parsePercent(detailModel.get('height'), posInfo.r);\n      var data = seriesModel.getData();\n      var value = data.get(data.mapDimension('value'), 0);\n      var autoColor = getColor(linearMap(value, [minVal, maxVal], [0, 1], true));\n      this.group.add(new graphic.Text({\n        silent: true,\n        style: graphic.setTextStyle({}, detailModel, {\n          x: x,\n          y: y,\n          text: formatLabel( // FIXME First data name ?\n          value, detailModel.get('formatter')),\n          textWidth: isNaN(width) ? null : width,\n          textHeight: isNaN(height) ? null : height,\n          textAlign: 'center',\n          textVerticalAlign: 'middle'\n        }, {\n          autoColor: autoColor,\n          forceRich: true\n        })\n      }));\n    }\n  }\n});\nvar _default = GaugeView;\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}